{-
   OpenAI API

   APIs for sampling from and fine-tuning language models

   OpenAPI Version: 3.0.0
   OpenAI API API version: 2.0.0
   Generated by OpenAPI Generator (https://openapi-generator.tech)
-}

{-|
Module : OpenAI.Model
-}

{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE DeriveFoldable #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE DeriveTraversable #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE NamedFieldPuns #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RecordWildCards #-}
{-# LANGUAGE TupleSections #-}
{-# LANGUAGE TypeFamilies #-}
{-# OPTIONS_GHC -fno-warn-unused-matches -fno-warn-unused-binds -fno-warn-unused-imports #-}

module OpenAI.Model where

import OpenAI.Core
import OpenAI.MimeTypes

import Data.Aeson ((.:),(.:!),(.:?),(.=))

import qualified Control.Arrow as P (left)
import qualified Data.Aeson as A
import qualified Data.ByteString as B
import qualified Data.ByteString.Base64 as B64
import qualified Data.ByteString.Char8 as BC
import qualified Data.ByteString.Lazy as BL
import qualified Data.Data as P (Typeable, TypeRep, typeOf, typeRep)
import qualified Data.Foldable as P
import qualified Data.HashMap.Lazy as HM
import qualified Data.Map as Map
import qualified Data.Maybe as P
import qualified Data.Set as Set
import qualified Data.Text as T
import qualified Data.Text.Encoding as T
import qualified Data.Time as TI
import qualified Lens.Micro as L
import qualified Web.FormUrlEncoded as WH
import qualified Web.HttpApiData as WH

import Control.Applicative ((<|>))
import Control.Applicative (Alternative)
import Data.Function ((&))
import Data.Monoid ((<>))
import Data.Text (Text)
import Prelude (($),(/=),(.),(<$>),(<*>),(>>=),(=<<),Maybe(..),Bool(..),Char,Double,FilePath,Float,Int,Integer,String,fmap,undefined,mempty,maybe,pure,Monad,Applicative,Functor)

import qualified Prelude as P



-- * Parameter newtypes


-- ** File
newtype File = File { unFile :: FilePath } deriving (P.Eq, P.Show)

-- ** FileId
newtype FileId = FileId { unFileId :: Text } deriving (P.Eq, P.Show)

-- ** FineTuneId
newtype FineTuneId = FineTuneId { unFineTuneId :: Text } deriving (P.Eq, P.Show)

-- ** Image
newtype Image = Image { unImage :: FilePath } deriving (P.Eq, P.Show)

-- ** Language
newtype Language = Language { unLanguage :: Text } deriving (P.Eq, P.Show)

-- ** Mask
newtype Mask = Mask { unMask :: FilePath } deriving (P.Eq, P.Show)

-- ** Model2
newtype Model2 = Model2 { unModel2 :: String } deriving (P.Eq, P.Show)

-- ** Model3
newtype Model3 = Model3 { unModel3 :: Text } deriving (P.Eq, P.Show)

-- ** N
newtype N = N { unN :: Int } deriving (P.Eq, P.Show)

-- ** Prompt
newtype Prompt = Prompt { unPrompt :: Text } deriving (P.Eq, P.Show)

-- ** Purpose
newtype Purpose = Purpose { unPurpose :: Text } deriving (P.Eq, P.Show)

-- ** ResponseFormat
newtype ResponseFormat = ResponseFormat { unResponseFormat :: E'ResponseFormat } deriving (P.Eq, P.Show)

-- ** ResponseFormatText
newtype ResponseFormatText = ResponseFormatText { unResponseFormatText :: Text } deriving (P.Eq, P.Show)

-- ** Size
newtype Size = Size { unSize :: E'Size } deriving (P.Eq, P.Show)

-- ** Stream
newtype Stream = Stream { unStream :: Bool } deriving (P.Eq, P.Show)

-- ** Temperature
newtype Temperature = Temperature { unTemperature :: Double } deriving (P.Eq, P.Show)

-- ** User
newtype User = User { unUser :: Text } deriving (P.Eq, P.Show)

-- * Models


-- ** ChatCompletionFunctions
-- | ChatCompletionFunctions
data ChatCompletionFunctions = ChatCompletionFunctions
  { chatCompletionFunctionsName :: !(Text) -- ^ /Required/ "name" - The name of the function to be called. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
  , chatCompletionFunctionsDescription :: !(Maybe Text) -- ^ "description" - A description of what the function does, used by the model to choose when and how to call the function.
  , chatCompletionFunctionsParameters :: !((Map.Map String A.Value)) -- ^ /Required/ "parameters" - The parameters the functions accepts, described as a JSON Schema object. See the [guide](/docs/guides/gpt/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format.  To describe a function that accepts no parameters, provide the value &#x60;{\&quot;type\&quot;: \&quot;object\&quot;, \&quot;properties\&quot;: {}}&#x60;.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ChatCompletionFunctions
instance A.FromJSON ChatCompletionFunctions where
  parseJSON = A.withObject "ChatCompletionFunctions" $ \o ->
    ChatCompletionFunctions
      <$> (o .:  "name")
      <*> (o .:? "description")
      <*> (o .:  "parameters")

-- | ToJSON ChatCompletionFunctions
instance A.ToJSON ChatCompletionFunctions where
  toJSON ChatCompletionFunctions {..} =
   _omitNulls
      [ "name" .= chatCompletionFunctionsName
      , "description" .= chatCompletionFunctionsDescription
      , "parameters" .= chatCompletionFunctionsParameters
      ]


-- | Construct a value of type 'ChatCompletionFunctions' (by applying it's required fields, if any)
mkChatCompletionFunctions
  :: Text -- ^ 'chatCompletionFunctionsName': The name of the function to be called. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
  -> (Map.Map String A.Value) -- ^ 'chatCompletionFunctionsParameters': The parameters the functions accepts, described as a JSON Schema object. See the [guide](/docs/guides/gpt/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format.  To describe a function that accepts no parameters, provide the value `{\"type\": \"object\", \"properties\": {}}`.
  -> ChatCompletionFunctions
mkChatCompletionFunctions chatCompletionFunctionsName chatCompletionFunctionsParameters =
  ChatCompletionFunctions
  { chatCompletionFunctionsName
  , chatCompletionFunctionsDescription = Nothing
  , chatCompletionFunctionsParameters
  }

-- ** ChatCompletionRequestMessage
-- | ChatCompletionRequestMessage
data ChatCompletionRequestMessage = ChatCompletionRequestMessage
  { chatCompletionRequestMessageRole :: !(E'Role) -- ^ /Required/ "role" - The role of the messages author. One of &#x60;system&#x60;, &#x60;user&#x60;, &#x60;assistant&#x60;, or &#x60;function&#x60;.
  , chatCompletionRequestMessageContent :: !(Text) -- ^ /Required/ "content" - The contents of the message. &#x60;content&#x60; is required for all messages, and may be null for assistant messages with function calls.
  , chatCompletionRequestMessageName :: !(Maybe Text) -- ^ "name" - The name of the author of this message. &#x60;name&#x60; is required if role is &#x60;function&#x60;, and it should be the name of the function whose response is in the &#x60;content&#x60;. May contain a-z, A-Z, 0-9, and underscores, with a maximum length of 64 characters.
  , chatCompletionRequestMessageFunctionCall :: !(Maybe ChatCompletionRequestMessageFunctionCall) -- ^ "function_call"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ChatCompletionRequestMessage
instance A.FromJSON ChatCompletionRequestMessage where
  parseJSON = A.withObject "ChatCompletionRequestMessage" $ \o ->
    ChatCompletionRequestMessage
      <$> (o .:  "role")
      <*> (o .:  "content")
      <*> (o .:? "name")
      <*> (o .:? "function_call")

-- | ToJSON ChatCompletionRequestMessage
instance A.ToJSON ChatCompletionRequestMessage where
  toJSON ChatCompletionRequestMessage {..} =
   _omitNulls
      [ "role" .= chatCompletionRequestMessageRole
      , "content" .= chatCompletionRequestMessageContent
      , "name" .= chatCompletionRequestMessageName
      , "function_call" .= chatCompletionRequestMessageFunctionCall
      ]


-- | Construct a value of type 'ChatCompletionRequestMessage' (by applying it's required fields, if any)
mkChatCompletionRequestMessage
  :: E'Role -- ^ 'chatCompletionRequestMessageRole': The role of the messages author. One of `system`, `user`, `assistant`, or `function`.
  -> Text -- ^ 'chatCompletionRequestMessageContent': The contents of the message. `content` is required for all messages, and may be null for assistant messages with function calls.
  -> ChatCompletionRequestMessage
mkChatCompletionRequestMessage chatCompletionRequestMessageRole chatCompletionRequestMessageContent =
  ChatCompletionRequestMessage
  { chatCompletionRequestMessageRole
  , chatCompletionRequestMessageContent
  , chatCompletionRequestMessageName = Nothing
  , chatCompletionRequestMessageFunctionCall = Nothing
  }

-- ** ChatCompletionRequestMessageFunctionCall
-- | ChatCompletionRequestMessageFunctionCall
-- The name and arguments of a function that should be called, as generated by the model.
data ChatCompletionRequestMessageFunctionCall = ChatCompletionRequestMessageFunctionCall
  { chatCompletionRequestMessageFunctionCallName :: !(Text) -- ^ /Required/ "name" - The name of the function to call.
  , chatCompletionRequestMessageFunctionCallArguments :: !(Text) -- ^ /Required/ "arguments" - The arguments to call the function with, as generated by the model in JSON format. Note that the model does not always generate valid JSON, and may hallucinate parameters not defined by your function schema. Validate the arguments in your code before calling your function.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ChatCompletionRequestMessageFunctionCall
instance A.FromJSON ChatCompletionRequestMessageFunctionCall where
  parseJSON = A.withObject "ChatCompletionRequestMessageFunctionCall" $ \o ->
    ChatCompletionRequestMessageFunctionCall
      <$> (o .:  "name")
      <*> (o .:  "arguments")

-- | ToJSON ChatCompletionRequestMessageFunctionCall
instance A.ToJSON ChatCompletionRequestMessageFunctionCall where
  toJSON ChatCompletionRequestMessageFunctionCall {..} =
   _omitNulls
      [ "name" .= chatCompletionRequestMessageFunctionCallName
      , "arguments" .= chatCompletionRequestMessageFunctionCallArguments
      ]


-- | Construct a value of type 'ChatCompletionRequestMessageFunctionCall' (by applying it's required fields, if any)
mkChatCompletionRequestMessageFunctionCall
  :: Text -- ^ 'chatCompletionRequestMessageFunctionCallName': The name of the function to call.
  -> Text -- ^ 'chatCompletionRequestMessageFunctionCallArguments': The arguments to call the function with, as generated by the model in JSON format. Note that the model does not always generate valid JSON, and may hallucinate parameters not defined by your function schema. Validate the arguments in your code before calling your function.
  -> ChatCompletionRequestMessageFunctionCall
mkChatCompletionRequestMessageFunctionCall chatCompletionRequestMessageFunctionCallName chatCompletionRequestMessageFunctionCallArguments =
  ChatCompletionRequestMessageFunctionCall
  { chatCompletionRequestMessageFunctionCallName
  , chatCompletionRequestMessageFunctionCallArguments
  }

-- ** ChatCompletionResponseMessage
-- | ChatCompletionResponseMessage
data ChatCompletionResponseMessage = ChatCompletionResponseMessage
  { chatCompletionResponseMessageRole :: !(E'Role) -- ^ /Required/ "role" - The role of the author of this message.
  , chatCompletionResponseMessageContent :: !(Maybe Text) -- ^ "content" - The contents of the message.
  , chatCompletionResponseMessageFunctionCall :: !(Maybe ChatCompletionResponseMessageFunctionCall) -- ^ "function_call"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ChatCompletionResponseMessage
instance A.FromJSON ChatCompletionResponseMessage where
  parseJSON = A.withObject "ChatCompletionResponseMessage" $ \o ->
    ChatCompletionResponseMessage
      <$> (o .:  "role")
      <*> (o .:? "content")
      <*> (o .:? "function_call")

-- | ToJSON ChatCompletionResponseMessage
instance A.ToJSON ChatCompletionResponseMessage where
  toJSON ChatCompletionResponseMessage {..} =
   _omitNulls
      [ "role" .= chatCompletionResponseMessageRole
      , "content" .= chatCompletionResponseMessageContent
      , "function_call" .= chatCompletionResponseMessageFunctionCall
      ]


-- | Construct a value of type 'ChatCompletionResponseMessage' (by applying it's required fields, if any)
mkChatCompletionResponseMessage
  :: E'Role -- ^ 'chatCompletionResponseMessageRole': The role of the author of this message.
  -> ChatCompletionResponseMessage
mkChatCompletionResponseMessage chatCompletionResponseMessageRole =
  ChatCompletionResponseMessage
  { chatCompletionResponseMessageRole
  , chatCompletionResponseMessageContent = Nothing
  , chatCompletionResponseMessageFunctionCall = Nothing
  }

-- ** ChatCompletionResponseMessageFunctionCall
-- | ChatCompletionResponseMessageFunctionCall
-- The name and arguments of a function that should be called, as generated by the model.
data ChatCompletionResponseMessageFunctionCall = ChatCompletionResponseMessageFunctionCall
  { chatCompletionResponseMessageFunctionCallName :: !(Maybe Text) -- ^ "name" - The name of the function to call.
  , chatCompletionResponseMessageFunctionCallArguments :: !(Maybe Text) -- ^ "arguments" - The arguments to call the function with, as generated by the model in JSON format. Note that the model does not always generate valid JSON, and may hallucinate parameters not defined by your function schema. Validate the arguments in your code before calling your function.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ChatCompletionResponseMessageFunctionCall
instance A.FromJSON ChatCompletionResponseMessageFunctionCall where
  parseJSON = A.withObject "ChatCompletionResponseMessageFunctionCall" $ \o ->
    ChatCompletionResponseMessageFunctionCall
      <$> (o .:? "name")
      <*> (o .:? "arguments")

-- | ToJSON ChatCompletionResponseMessageFunctionCall
instance A.ToJSON ChatCompletionResponseMessageFunctionCall where
  toJSON ChatCompletionResponseMessageFunctionCall {..} =
   _omitNulls
      [ "name" .= chatCompletionResponseMessageFunctionCallName
      , "arguments" .= chatCompletionResponseMessageFunctionCallArguments
      ]


-- | Construct a value of type 'ChatCompletionResponseMessageFunctionCall' (by applying it's required fields, if any)
mkChatCompletionResponseMessageFunctionCall
  :: ChatCompletionResponseMessageFunctionCall
mkChatCompletionResponseMessageFunctionCall =
  ChatCompletionResponseMessageFunctionCall
  { chatCompletionResponseMessageFunctionCallName = Nothing
  , chatCompletionResponseMessageFunctionCallArguments = Nothing
  }

-- ** ChatCompletionStreamResponseDelta
-- | ChatCompletionStreamResponseDelta
data ChatCompletionStreamResponseDelta = ChatCompletionStreamResponseDelta
  { chatCompletionStreamResponseDeltaRole :: !(Maybe E'Role) -- ^ "role" - The role of the author of this message.
  , chatCompletionStreamResponseDeltaContent :: !(Maybe Text) -- ^ "content" - The contents of the chunk message.
  , chatCompletionStreamResponseDeltaFunctionCall :: !(Maybe ChatCompletionResponseMessageFunctionCall) -- ^ "function_call"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ChatCompletionStreamResponseDelta
instance A.FromJSON ChatCompletionStreamResponseDelta where
  parseJSON = A.withObject "ChatCompletionStreamResponseDelta" $ \o ->
    ChatCompletionStreamResponseDelta
      <$> (o .:? "role")
      <*> (o .:? "content")
      <*> (o .:? "function_call")

-- | ToJSON ChatCompletionStreamResponseDelta
instance A.ToJSON ChatCompletionStreamResponseDelta where
  toJSON ChatCompletionStreamResponseDelta {..} =
   _omitNulls
      [ "role" .= chatCompletionStreamResponseDeltaRole
      , "content" .= chatCompletionStreamResponseDeltaContent
      , "function_call" .= chatCompletionStreamResponseDeltaFunctionCall
      ]


-- | Construct a value of type 'ChatCompletionStreamResponseDelta' (by applying it's required fields, if any)
mkChatCompletionStreamResponseDelta
  :: ChatCompletionStreamResponseDelta
mkChatCompletionStreamResponseDelta =
  ChatCompletionStreamResponseDelta
  { chatCompletionStreamResponseDeltaRole = Nothing
  , chatCompletionStreamResponseDeltaContent = Nothing
  , chatCompletionStreamResponseDeltaFunctionCall = Nothing
  }

-- ** CreateChatCompletionRequest
-- | CreateChatCompletionRequest
data CreateChatCompletionRequest = CreateChatCompletionRequest
  { createChatCompletionRequestModel :: !(CreateChatCompletionRequestModel) -- ^ /Required/ "model"
  , createChatCompletionRequestMessages :: !([ChatCompletionRequestMessage]) -- ^ /Required/ "messages" - A list of messages comprising the conversation so far. [Example Python code](https://github.com/openai/openai-cookbook/blob/main/examples/How_to_format_inputs_to_ChatGPT_models.ipynb).
  , createChatCompletionRequestFunctions :: !(Maybe [ChatCompletionFunctions]) -- ^ "functions" - A list of functions the model may generate JSON inputs for.
  , createChatCompletionRequestFunctionCall :: !(Maybe CreateChatCompletionRequestFunctionCall) -- ^ "function_call"
  , createChatCompletionRequestTemperature :: !(Maybe Double) -- ^ "temperature" - What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.  We generally recommend altering this or &#x60;top_p&#x60; but not both. 
  , createChatCompletionRequestTopP :: !(Maybe Double) -- ^ "top_p" - An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass. So 0.1 means only the tokens comprising the top 10% probability mass are considered.  We generally recommend altering this or &#x60;temperature&#x60; but not both. 
  , createChatCompletionRequestN :: !(Maybe Int) -- ^ "n" - How many chat completion choices to generate for each input message.
  , createChatCompletionRequestStream :: !(Maybe Bool) -- ^ "stream" - If set, partial message deltas will be sent, like in ChatGPT. Tokens will be sent as data-only [server-sent events](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events#Event_stream_format) as they become available, with the stream terminated by a &#x60;data: [DONE]&#x60; message. [Example Python code](https://github.com/openai/openai-cookbook/blob/main/examples/How_to_stream_completions.ipynb). 
  , createChatCompletionRequestStop :: !(Maybe CreateChatCompletionRequestStop) -- ^ "stop"
  , createChatCompletionRequestMaxTokens :: !(Maybe Int) -- ^ "max_tokens" - The maximum number of [tokens](/tokenizer) to generate in the chat completion.  The total length of input tokens and generated tokens is limited by the model&#39;s context length. [Example Python code](https://github.com/openai/openai-cookbook/blob/main/examples/How_to_count_tokens_with_tiktoken.ipynb) for counting tokens. 
  , createChatCompletionRequestPresencePenalty :: !(Maybe Double) -- ^ "presence_penalty" - Number between -2.0 and 2.0. Positive values penalize new tokens based on whether they appear in the text so far, increasing the model&#39;s likelihood to talk about new topics.  [See more information about frequency and presence penalties.](/docs/api-reference/parameter-details) 
  , createChatCompletionRequestFrequencyPenalty :: !(Maybe Double) -- ^ "frequency_penalty" - Number between -2.0 and 2.0. Positive values penalize new tokens based on their existing frequency in the text so far, decreasing the model&#39;s likelihood to repeat the same line verbatim.  [See more information about frequency and presence penalties.](/docs/api-reference/parameter-details) 
  , createChatCompletionRequestLogitBias :: !(Maybe A.Value) -- ^ "logit_bias" - Modify the likelihood of specified tokens appearing in the completion.  Accepts a json object that maps tokens (specified by their token ID in the tokenizer) to an associated bias value from -100 to 100. Mathematically, the bias is added to the logits generated by the model prior to sampling. The exact effect will vary per model, but values between -1 and 1 should decrease or increase likelihood of selection; values like -100 or 100 should result in a ban or exclusive selection of the relevant token. 
  , createChatCompletionRequestUser :: !(Maybe Text) -- ^ "user" - A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse. [Learn more](/docs/guides/safety-best-practices/end-user-ids). 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateChatCompletionRequest
instance A.FromJSON CreateChatCompletionRequest where
  parseJSON = A.withObject "CreateChatCompletionRequest" $ \o ->
    CreateChatCompletionRequest
      <$> (o .:  "model")
      <*> (o .:  "messages")
      <*> (o .:? "functions")
      <*> (o .:? "function_call")
      <*> (o .:? "temperature")
      <*> (o .:? "top_p")
      <*> (o .:? "n")
      <*> (o .:? "stream")
      <*> (o .:? "stop")
      <*> (o .:? "max_tokens")
      <*> (o .:? "presence_penalty")
      <*> (o .:? "frequency_penalty")
      <*> (o .:? "logit_bias")
      <*> (o .:? "user")

-- | ToJSON CreateChatCompletionRequest
instance A.ToJSON CreateChatCompletionRequest where
  toJSON CreateChatCompletionRequest {..} =
   _omitNulls
      [ "model" .= createChatCompletionRequestModel
      , "messages" .= createChatCompletionRequestMessages
      , "functions" .= createChatCompletionRequestFunctions
      , "function_call" .= createChatCompletionRequestFunctionCall
      , "temperature" .= createChatCompletionRequestTemperature
      , "top_p" .= createChatCompletionRequestTopP
      , "n" .= createChatCompletionRequestN
      , "stream" .= createChatCompletionRequestStream
      , "stop" .= createChatCompletionRequestStop
      , "max_tokens" .= createChatCompletionRequestMaxTokens
      , "presence_penalty" .= createChatCompletionRequestPresencePenalty
      , "frequency_penalty" .= createChatCompletionRequestFrequencyPenalty
      , "logit_bias" .= createChatCompletionRequestLogitBias
      , "user" .= createChatCompletionRequestUser
      ]


-- | Construct a value of type 'CreateChatCompletionRequest' (by applying it's required fields, if any)
mkCreateChatCompletionRequest
  :: CreateChatCompletionRequestModel -- ^ 'createChatCompletionRequestModel' 
  -> [ChatCompletionRequestMessage] -- ^ 'createChatCompletionRequestMessages': A list of messages comprising the conversation so far. [Example Python code](https://github.com/openai/openai-cookbook/blob/main/examples/How_to_format_inputs_to_ChatGPT_models.ipynb).
  -> CreateChatCompletionRequest
mkCreateChatCompletionRequest createChatCompletionRequestModel createChatCompletionRequestMessages =
  CreateChatCompletionRequest
  { createChatCompletionRequestModel
  , createChatCompletionRequestMessages
  , createChatCompletionRequestFunctions = Nothing
  , createChatCompletionRequestFunctionCall = Nothing
  , createChatCompletionRequestTemperature = Nothing
  , createChatCompletionRequestTopP = Nothing
  , createChatCompletionRequestN = Nothing
  , createChatCompletionRequestStream = Nothing
  , createChatCompletionRequestStop = Nothing
  , createChatCompletionRequestMaxTokens = Nothing
  , createChatCompletionRequestPresencePenalty = Nothing
  , createChatCompletionRequestFrequencyPenalty = Nothing
  , createChatCompletionRequestLogitBias = Nothing
  , createChatCompletionRequestUser = Nothing
  }

-- ** CreateChatCompletionRequestFunctionCall
-- | CreateChatCompletionRequestFunctionCall
-- Controls how the model responds to function calls. \"none\" means the model does not call a function, and responds to the end-user. \"auto\" means the model can pick between an end-user or calling a function.  Specifying a particular function via `{\"name\":\\ \"my_function\"}` forces the model to call that function. \"none\" is the default when no functions are present. \"auto\" is the default if functions are present.
data CreateChatCompletionRequestFunctionCall = CreateChatCompletionRequestFunctionCall
  { createChatCompletionRequestFunctionCallName :: !(Text) -- ^ /Required/ "name" - The name of the function to call.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateChatCompletionRequestFunctionCall
instance A.FromJSON CreateChatCompletionRequestFunctionCall where
  parseJSON = A.withObject "CreateChatCompletionRequestFunctionCall" $ \o ->
    CreateChatCompletionRequestFunctionCall
      <$> (o .:  "name")

-- | ToJSON CreateChatCompletionRequestFunctionCall
instance A.ToJSON CreateChatCompletionRequestFunctionCall where
  toJSON CreateChatCompletionRequestFunctionCall {..} =
   _omitNulls
      [ "name" .= createChatCompletionRequestFunctionCallName
      ]


-- | Construct a value of type 'CreateChatCompletionRequestFunctionCall' (by applying it's required fields, if any)
mkCreateChatCompletionRequestFunctionCall
  :: Text -- ^ 'createChatCompletionRequestFunctionCallName': The name of the function to call.
  -> CreateChatCompletionRequestFunctionCall
mkCreateChatCompletionRequestFunctionCall createChatCompletionRequestFunctionCallName =
  CreateChatCompletionRequestFunctionCall
  { createChatCompletionRequestFunctionCallName
  }

-- ** CreateChatCompletionRequestFunctionCallOneOf
-- | CreateChatCompletionRequestFunctionCallOneOf
data CreateChatCompletionRequestFunctionCallOneOf = CreateChatCompletionRequestFunctionCallOneOf
  { createChatCompletionRequestFunctionCallOneOfName :: !(Text) -- ^ /Required/ "name" - The name of the function to call.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateChatCompletionRequestFunctionCallOneOf
instance A.FromJSON CreateChatCompletionRequestFunctionCallOneOf where
  parseJSON = A.withObject "CreateChatCompletionRequestFunctionCallOneOf" $ \o ->
    CreateChatCompletionRequestFunctionCallOneOf
      <$> (o .:  "name")

-- | ToJSON CreateChatCompletionRequestFunctionCallOneOf
instance A.ToJSON CreateChatCompletionRequestFunctionCallOneOf where
  toJSON CreateChatCompletionRequestFunctionCallOneOf {..} =
   _omitNulls
      [ "name" .= createChatCompletionRequestFunctionCallOneOfName
      ]


-- | Construct a value of type 'CreateChatCompletionRequestFunctionCallOneOf' (by applying it's required fields, if any)
mkCreateChatCompletionRequestFunctionCallOneOf
  :: Text -- ^ 'createChatCompletionRequestFunctionCallOneOfName': The name of the function to call.
  -> CreateChatCompletionRequestFunctionCallOneOf
mkCreateChatCompletionRequestFunctionCallOneOf createChatCompletionRequestFunctionCallOneOfName =
  CreateChatCompletionRequestFunctionCallOneOf
  { createChatCompletionRequestFunctionCallOneOfName
  }

-- ** CreateChatCompletionRequestModel
-- | CreateChatCompletionRequestModel
-- ID of the model to use. See the [model endpoint compatibility](/docs/models/model-endpoint-compatibility) table for details on which models work with the Chat API.
data CreateChatCompletionRequestModel = CreateChatCompletionRequestModel
  { 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateChatCompletionRequestModel
instance A.FromJSON CreateChatCompletionRequestModel where
  parseJSON = A.withObject "CreateChatCompletionRequestModel" $ \o ->
    pure CreateChatCompletionRequestModel
      

-- | ToJSON CreateChatCompletionRequestModel
instance A.ToJSON CreateChatCompletionRequestModel where
  toJSON CreateChatCompletionRequestModel  =
   _omitNulls
      [ 
      ]


-- | Construct a value of type 'CreateChatCompletionRequestModel' (by applying it's required fields, if any)
mkCreateChatCompletionRequestModel
  :: CreateChatCompletionRequestModel
mkCreateChatCompletionRequestModel =
  CreateChatCompletionRequestModel
  { 
  }

-- ** CreateChatCompletionRequestStop
-- | CreateChatCompletionRequestStop
-- Up to 4 sequences where the API will stop generating further tokens. 
data CreateChatCompletionRequestStop = CreateChatCompletionRequestStop
  { 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateChatCompletionRequestStop
instance A.FromJSON CreateChatCompletionRequestStop where
  parseJSON = A.withObject "CreateChatCompletionRequestStop" $ \o ->
    pure CreateChatCompletionRequestStop
      

-- | ToJSON CreateChatCompletionRequestStop
instance A.ToJSON CreateChatCompletionRequestStop where
  toJSON CreateChatCompletionRequestStop  =
   _omitNulls
      [ 
      ]


-- | Construct a value of type 'CreateChatCompletionRequestStop' (by applying it's required fields, if any)
mkCreateChatCompletionRequestStop
  :: CreateChatCompletionRequestStop
mkCreateChatCompletionRequestStop =
  CreateChatCompletionRequestStop
  { 
  }

-- ** CreateChatCompletionResponse
-- | CreateChatCompletionResponse
data CreateChatCompletionResponse = CreateChatCompletionResponse
  { createChatCompletionResponseId :: !(Text) -- ^ /Required/ "id"
  , createChatCompletionResponseObject :: !(Text) -- ^ /Required/ "object"
  , createChatCompletionResponseCreated :: !(Int) -- ^ /Required/ "created"
  , createChatCompletionResponseModel :: !(Text) -- ^ /Required/ "model"
  , createChatCompletionResponseChoices :: !([CreateChatCompletionResponseChoicesInner]) -- ^ /Required/ "choices"
  , createChatCompletionResponseUsage :: !(Maybe CreateCompletionResponseUsage) -- ^ "usage"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateChatCompletionResponse
instance A.FromJSON CreateChatCompletionResponse where
  parseJSON = A.withObject "CreateChatCompletionResponse" $ \o ->
    CreateChatCompletionResponse
      <$> (o .:  "id")
      <*> (o .:  "object")
      <*> (o .:  "created")
      <*> (o .:  "model")
      <*> (o .:  "choices")
      <*> (o .:? "usage")

-- | ToJSON CreateChatCompletionResponse
instance A.ToJSON CreateChatCompletionResponse where
  toJSON CreateChatCompletionResponse {..} =
   _omitNulls
      [ "id" .= createChatCompletionResponseId
      , "object" .= createChatCompletionResponseObject
      , "created" .= createChatCompletionResponseCreated
      , "model" .= createChatCompletionResponseModel
      , "choices" .= createChatCompletionResponseChoices
      , "usage" .= createChatCompletionResponseUsage
      ]


-- | Construct a value of type 'CreateChatCompletionResponse' (by applying it's required fields, if any)
mkCreateChatCompletionResponse
  :: Text -- ^ 'createChatCompletionResponseId' 
  -> Text -- ^ 'createChatCompletionResponseObject' 
  -> Int -- ^ 'createChatCompletionResponseCreated' 
  -> Text -- ^ 'createChatCompletionResponseModel' 
  -> [CreateChatCompletionResponseChoicesInner] -- ^ 'createChatCompletionResponseChoices' 
  -> CreateChatCompletionResponse
mkCreateChatCompletionResponse createChatCompletionResponseId createChatCompletionResponseObject createChatCompletionResponseCreated createChatCompletionResponseModel createChatCompletionResponseChoices =
  CreateChatCompletionResponse
  { createChatCompletionResponseId
  , createChatCompletionResponseObject
  , createChatCompletionResponseCreated
  , createChatCompletionResponseModel
  , createChatCompletionResponseChoices
  , createChatCompletionResponseUsage = Nothing
  }

-- ** CreateChatCompletionResponseChoicesInner
-- | CreateChatCompletionResponseChoicesInner
data CreateChatCompletionResponseChoicesInner = CreateChatCompletionResponseChoicesInner
  { createChatCompletionResponseChoicesInnerIndex :: !(Maybe Int) -- ^ "index"
  , createChatCompletionResponseChoicesInnerMessage :: !(Maybe ChatCompletionResponseMessage) -- ^ "message"
  , createChatCompletionResponseChoicesInnerFinishReason :: !(Maybe E'FinishReason2) -- ^ "finish_reason"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateChatCompletionResponseChoicesInner
instance A.FromJSON CreateChatCompletionResponseChoicesInner where
  parseJSON = A.withObject "CreateChatCompletionResponseChoicesInner" $ \o ->
    CreateChatCompletionResponseChoicesInner
      <$> (o .:? "index")
      <*> (o .:? "message")
      <*> (o .:? "finish_reason")

-- | ToJSON CreateChatCompletionResponseChoicesInner
instance A.ToJSON CreateChatCompletionResponseChoicesInner where
  toJSON CreateChatCompletionResponseChoicesInner {..} =
   _omitNulls
      [ "index" .= createChatCompletionResponseChoicesInnerIndex
      , "message" .= createChatCompletionResponseChoicesInnerMessage
      , "finish_reason" .= createChatCompletionResponseChoicesInnerFinishReason
      ]


-- | Construct a value of type 'CreateChatCompletionResponseChoicesInner' (by applying it's required fields, if any)
mkCreateChatCompletionResponseChoicesInner
  :: CreateChatCompletionResponseChoicesInner
mkCreateChatCompletionResponseChoicesInner =
  CreateChatCompletionResponseChoicesInner
  { createChatCompletionResponseChoicesInnerIndex = Nothing
  , createChatCompletionResponseChoicesInnerMessage = Nothing
  , createChatCompletionResponseChoicesInnerFinishReason = Nothing
  }

-- ** CreateChatCompletionStreamResponse
-- | CreateChatCompletionStreamResponse
data CreateChatCompletionStreamResponse = CreateChatCompletionStreamResponse
  { createChatCompletionStreamResponseId :: !(Text) -- ^ /Required/ "id"
  , createChatCompletionStreamResponseObject :: !(Text) -- ^ /Required/ "object"
  , createChatCompletionStreamResponseCreated :: !(Int) -- ^ /Required/ "created"
  , createChatCompletionStreamResponseModel :: !(Text) -- ^ /Required/ "model"
  , createChatCompletionStreamResponseChoices :: !([CreateChatCompletionStreamResponseChoicesInner]) -- ^ /Required/ "choices"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateChatCompletionStreamResponse
instance A.FromJSON CreateChatCompletionStreamResponse where
  parseJSON = A.withObject "CreateChatCompletionStreamResponse" $ \o ->
    CreateChatCompletionStreamResponse
      <$> (o .:  "id")
      <*> (o .:  "object")
      <*> (o .:  "created")
      <*> (o .:  "model")
      <*> (o .:  "choices")

-- | ToJSON CreateChatCompletionStreamResponse
instance A.ToJSON CreateChatCompletionStreamResponse where
  toJSON CreateChatCompletionStreamResponse {..} =
   _omitNulls
      [ "id" .= createChatCompletionStreamResponseId
      , "object" .= createChatCompletionStreamResponseObject
      , "created" .= createChatCompletionStreamResponseCreated
      , "model" .= createChatCompletionStreamResponseModel
      , "choices" .= createChatCompletionStreamResponseChoices
      ]


-- | Construct a value of type 'CreateChatCompletionStreamResponse' (by applying it's required fields, if any)
mkCreateChatCompletionStreamResponse
  :: Text -- ^ 'createChatCompletionStreamResponseId' 
  -> Text -- ^ 'createChatCompletionStreamResponseObject' 
  -> Int -- ^ 'createChatCompletionStreamResponseCreated' 
  -> Text -- ^ 'createChatCompletionStreamResponseModel' 
  -> [CreateChatCompletionStreamResponseChoicesInner] -- ^ 'createChatCompletionStreamResponseChoices' 
  -> CreateChatCompletionStreamResponse
mkCreateChatCompletionStreamResponse createChatCompletionStreamResponseId createChatCompletionStreamResponseObject createChatCompletionStreamResponseCreated createChatCompletionStreamResponseModel createChatCompletionStreamResponseChoices =
  CreateChatCompletionStreamResponse
  { createChatCompletionStreamResponseId
  , createChatCompletionStreamResponseObject
  , createChatCompletionStreamResponseCreated
  , createChatCompletionStreamResponseModel
  , createChatCompletionStreamResponseChoices
  }

-- ** CreateChatCompletionStreamResponseChoicesInner
-- | CreateChatCompletionStreamResponseChoicesInner
data CreateChatCompletionStreamResponseChoicesInner = CreateChatCompletionStreamResponseChoicesInner
  { createChatCompletionStreamResponseChoicesInnerIndex :: !(Maybe Int) -- ^ "index"
  , createChatCompletionStreamResponseChoicesInnerDelta :: !(Maybe ChatCompletionStreamResponseDelta) -- ^ "delta"
  , createChatCompletionStreamResponseChoicesInnerFinishReason :: !(Maybe E'FinishReason2) -- ^ "finish_reason"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateChatCompletionStreamResponseChoicesInner
instance A.FromJSON CreateChatCompletionStreamResponseChoicesInner where
  parseJSON = A.withObject "CreateChatCompletionStreamResponseChoicesInner" $ \o ->
    CreateChatCompletionStreamResponseChoicesInner
      <$> (o .:? "index")
      <*> (o .:? "delta")
      <*> (o .:? "finish_reason")

-- | ToJSON CreateChatCompletionStreamResponseChoicesInner
instance A.ToJSON CreateChatCompletionStreamResponseChoicesInner where
  toJSON CreateChatCompletionStreamResponseChoicesInner {..} =
   _omitNulls
      [ "index" .= createChatCompletionStreamResponseChoicesInnerIndex
      , "delta" .= createChatCompletionStreamResponseChoicesInnerDelta
      , "finish_reason" .= createChatCompletionStreamResponseChoicesInnerFinishReason
      ]


-- | Construct a value of type 'CreateChatCompletionStreamResponseChoicesInner' (by applying it's required fields, if any)
mkCreateChatCompletionStreamResponseChoicesInner
  :: CreateChatCompletionStreamResponseChoicesInner
mkCreateChatCompletionStreamResponseChoicesInner =
  CreateChatCompletionStreamResponseChoicesInner
  { createChatCompletionStreamResponseChoicesInnerIndex = Nothing
  , createChatCompletionStreamResponseChoicesInnerDelta = Nothing
  , createChatCompletionStreamResponseChoicesInnerFinishReason = Nothing
  }

-- ** CreateCompletionRequest
-- | CreateCompletionRequest
data CreateCompletionRequest = CreateCompletionRequest
  { createCompletionRequestModel :: !(CreateCompletionRequestModel) -- ^ /Required/ "model"
  , createCompletionRequestPrompt :: !(CreateCompletionRequestPrompt) -- ^ /Required/ "prompt"
  , createCompletionRequestSuffix :: !(Maybe Text) -- ^ "suffix" - The suffix that comes after a completion of inserted text.
  , createCompletionRequestMaxTokens :: !(Maybe Int) -- ^ "max_tokens" - The maximum number of [tokens](/tokenizer) to generate in the completion.  The token count of your prompt plus &#x60;max_tokens&#x60; cannot exceed the model&#39;s context length. [Example Python code](https://github.com/openai/openai-cookbook/blob/main/examples/How_to_count_tokens_with_tiktoken.ipynb) for counting tokens. 
  , createCompletionRequestTemperature :: !(Maybe Double) -- ^ "temperature" - What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.  We generally recommend altering this or &#x60;top_p&#x60; but not both. 
  , createCompletionRequestTopP :: !(Maybe Double) -- ^ "top_p" - An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass. So 0.1 means only the tokens comprising the top 10% probability mass are considered.  We generally recommend altering this or &#x60;temperature&#x60; but not both. 
  , createCompletionRequestN :: !(Maybe Int) -- ^ "n" - How many completions to generate for each prompt.  **Note:** Because this parameter generates many completions, it can quickly consume your token quota. Use carefully and ensure that you have reasonable settings for &#x60;max_tokens&#x60; and &#x60;stop&#x60;. 
  , createCompletionRequestStream :: !(Maybe Bool) -- ^ "stream" - Whether to stream back partial progress. If set, tokens will be sent as data-only [server-sent events](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events#Event_stream_format) as they become available, with the stream terminated by a &#x60;data: [DONE]&#x60; message. [Example Python code](https://github.com/openai/openai-cookbook/blob/main/examples/How_to_stream_completions.ipynb). 
  , createCompletionRequestLogprobs :: !(Maybe Int) -- ^ "logprobs" - Include the log probabilities on the &#x60;logprobs&#x60; most likely tokens, as well the chosen tokens. For example, if &#x60;logprobs&#x60; is 5, the API will return a list of the 5 most likely tokens. The API will always return the &#x60;logprob&#x60; of the sampled token, so there may be up to &#x60;logprobs+1&#x60; elements in the response.  The maximum value for &#x60;logprobs&#x60; is 5. 
  , createCompletionRequestEcho :: !(Maybe Bool) -- ^ "echo" - Echo back the prompt in addition to the completion 
  , createCompletionRequestStop :: !(Maybe CreateCompletionRequestStop) -- ^ "stop"
  , createCompletionRequestPresencePenalty :: !(Maybe Double) -- ^ "presence_penalty" - Number between -2.0 and 2.0. Positive values penalize new tokens based on whether they appear in the text so far, increasing the model&#39;s likelihood to talk about new topics.  [See more information about frequency and presence penalties.](/docs/api-reference/parameter-details) 
  , createCompletionRequestFrequencyPenalty :: !(Maybe Double) -- ^ "frequency_penalty" - Number between -2.0 and 2.0. Positive values penalize new tokens based on their existing frequency in the text so far, decreasing the model&#39;s likelihood to repeat the same line verbatim.  [See more information about frequency and presence penalties.](/docs/api-reference/parameter-details) 
  , createCompletionRequestBestOf :: !(Maybe Int) -- ^ "best_of" - Generates &#x60;best_of&#x60; completions server-side and returns the \&quot;best\&quot; (the one with the highest log probability per token). Results cannot be streamed.  When used with &#x60;n&#x60;, &#x60;best_of&#x60; controls the number of candidate completions and &#x60;n&#x60; specifies how many to return â€“ &#x60;best_of&#x60; must be greater than &#x60;n&#x60;.  **Note:** Because this parameter generates many completions, it can quickly consume your token quota. Use carefully and ensure that you have reasonable settings for &#x60;max_tokens&#x60; and &#x60;stop&#x60;. 
  , createCompletionRequestLogitBias :: !(Maybe A.Value) -- ^ "logit_bias" - Modify the likelihood of specified tokens appearing in the completion.  Accepts a json object that maps tokens (specified by their token ID in the GPT tokenizer) to an associated bias value from -100 to 100. You can use this [tokenizer tool](/tokenizer?view&#x3D;bpe) (which works for both GPT-2 and GPT-3) to convert text to token IDs. Mathematically, the bias is added to the logits generated by the model prior to sampling. The exact effect will vary per model, but values between -1 and 1 should decrease or increase likelihood of selection; values like -100 or 100 should result in a ban or exclusive selection of the relevant token.  As an example, you can pass &#x60;{\&quot;50256\&quot;: -100}&#x60; to prevent the &lt;|endoftext|&gt; token from being generated. 
  , createCompletionRequestUser :: !(Maybe Text) -- ^ "user" - A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse. [Learn more](/docs/guides/safety-best-practices/end-user-ids). 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateCompletionRequest
instance A.FromJSON CreateCompletionRequest where
  parseJSON = A.withObject "CreateCompletionRequest" $ \o ->
    CreateCompletionRequest
      <$> (o .:  "model")
      <*> (o .:  "prompt")
      <*> (o .:? "suffix")
      <*> (o .:? "max_tokens")
      <*> (o .:? "temperature")
      <*> (o .:? "top_p")
      <*> (o .:? "n")
      <*> (o .:? "stream")
      <*> (o .:? "logprobs")
      <*> (o .:? "echo")
      <*> (o .:? "stop")
      <*> (o .:? "presence_penalty")
      <*> (o .:? "frequency_penalty")
      <*> (o .:? "best_of")
      <*> (o .:? "logit_bias")
      <*> (o .:? "user")

-- | ToJSON CreateCompletionRequest
instance A.ToJSON CreateCompletionRequest where
  toJSON CreateCompletionRequest {..} =
   _omitNulls
      [ "model" .= createCompletionRequestModel
      , "prompt" .= createCompletionRequestPrompt
      , "suffix" .= createCompletionRequestSuffix
      , "max_tokens" .= createCompletionRequestMaxTokens
      , "temperature" .= createCompletionRequestTemperature
      , "top_p" .= createCompletionRequestTopP
      , "n" .= createCompletionRequestN
      , "stream" .= createCompletionRequestStream
      , "logprobs" .= createCompletionRequestLogprobs
      , "echo" .= createCompletionRequestEcho
      , "stop" .= createCompletionRequestStop
      , "presence_penalty" .= createCompletionRequestPresencePenalty
      , "frequency_penalty" .= createCompletionRequestFrequencyPenalty
      , "best_of" .= createCompletionRequestBestOf
      , "logit_bias" .= createCompletionRequestLogitBias
      , "user" .= createCompletionRequestUser
      ]


-- | Construct a value of type 'CreateCompletionRequest' (by applying it's required fields, if any)
mkCreateCompletionRequest
  :: CreateCompletionRequestModel -- ^ 'createCompletionRequestModel' 
  -> CreateCompletionRequestPrompt -- ^ 'createCompletionRequestPrompt' 
  -> CreateCompletionRequest
mkCreateCompletionRequest createCompletionRequestModel createCompletionRequestPrompt =
  CreateCompletionRequest
  { createCompletionRequestModel
  , createCompletionRequestPrompt
  , createCompletionRequestSuffix = Nothing
  , createCompletionRequestMaxTokens = Nothing
  , createCompletionRequestTemperature = Nothing
  , createCompletionRequestTopP = Nothing
  , createCompletionRequestN = Nothing
  , createCompletionRequestStream = Nothing
  , createCompletionRequestLogprobs = Nothing
  , createCompletionRequestEcho = Nothing
  , createCompletionRequestStop = Nothing
  , createCompletionRequestPresencePenalty = Nothing
  , createCompletionRequestFrequencyPenalty = Nothing
  , createCompletionRequestBestOf = Nothing
  , createCompletionRequestLogitBias = Nothing
  , createCompletionRequestUser = Nothing
  }

-- ** CreateCompletionRequestModel
-- | CreateCompletionRequestModel
-- ID of the model to use. You can use the [List models](/docs/api-reference/models/list) API to see all of your available models, or see our [Model overview](/docs/models/overview) for descriptions of them. 
data CreateCompletionRequestModel = CreateCompletionRequestModel
  { 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateCompletionRequestModel
instance A.FromJSON CreateCompletionRequestModel where
  parseJSON = A.withObject "CreateCompletionRequestModel" $ \o ->
    pure CreateCompletionRequestModel
      

-- | ToJSON CreateCompletionRequestModel
instance A.ToJSON CreateCompletionRequestModel where
  toJSON CreateCompletionRequestModel  =
   _omitNulls
      [ 
      ]


-- | Construct a value of type 'CreateCompletionRequestModel' (by applying it's required fields, if any)
mkCreateCompletionRequestModel
  :: CreateCompletionRequestModel
mkCreateCompletionRequestModel =
  CreateCompletionRequestModel
  { 
  }

-- ** CreateCompletionRequestPrompt
-- | CreateCompletionRequestPrompt
-- The prompt(s) to generate completions for, encoded as a string, array of strings, array of tokens, or array of token arrays.  Note that <|endoftext|> is the document separator that the model sees during training, so if a prompt is not specified the model will generate as if from the beginning of a new document. 
data CreateCompletionRequestPrompt = CreateCompletionRequestPrompt
  { 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateCompletionRequestPrompt
instance A.FromJSON CreateCompletionRequestPrompt where
  parseJSON = A.withObject "CreateCompletionRequestPrompt" $ \o ->
    pure CreateCompletionRequestPrompt
      

-- | ToJSON CreateCompletionRequestPrompt
instance A.ToJSON CreateCompletionRequestPrompt where
  toJSON CreateCompletionRequestPrompt  =
   _omitNulls
      [ 
      ]


-- | Construct a value of type 'CreateCompletionRequestPrompt' (by applying it's required fields, if any)
mkCreateCompletionRequestPrompt
  :: CreateCompletionRequestPrompt
mkCreateCompletionRequestPrompt =
  CreateCompletionRequestPrompt
  { 
  }

-- ** CreateCompletionRequestStop
-- | CreateCompletionRequestStop
-- Up to 4 sequences where the API will stop generating further tokens. The returned text will not contain the stop sequence. 
data CreateCompletionRequestStop = CreateCompletionRequestStop
  { 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateCompletionRequestStop
instance A.FromJSON CreateCompletionRequestStop where
  parseJSON = A.withObject "CreateCompletionRequestStop" $ \o ->
    pure CreateCompletionRequestStop
      

-- | ToJSON CreateCompletionRequestStop
instance A.ToJSON CreateCompletionRequestStop where
  toJSON CreateCompletionRequestStop  =
   _omitNulls
      [ 
      ]


-- | Construct a value of type 'CreateCompletionRequestStop' (by applying it's required fields, if any)
mkCreateCompletionRequestStop
  :: CreateCompletionRequestStop
mkCreateCompletionRequestStop =
  CreateCompletionRequestStop
  { 
  }

-- ** CreateCompletionResponse
-- | CreateCompletionResponse
data CreateCompletionResponse = CreateCompletionResponse
  { createCompletionResponseId :: !(Text) -- ^ /Required/ "id"
  , createCompletionResponseObject :: !(Text) -- ^ /Required/ "object"
  , createCompletionResponseCreated :: !(Int) -- ^ /Required/ "created"
  , createCompletionResponseModel :: !(Text) -- ^ /Required/ "model"
  , createCompletionResponseChoices :: !([CreateCompletionResponseChoicesInner]) -- ^ /Required/ "choices"
  , createCompletionResponseUsage :: !(Maybe CreateCompletionResponseUsage) -- ^ "usage"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateCompletionResponse
instance A.FromJSON CreateCompletionResponse where
  parseJSON = A.withObject "CreateCompletionResponse" $ \o ->
    CreateCompletionResponse
      <$> (o .:  "id")
      <*> (o .:  "object")
      <*> (o .:  "created")
      <*> (o .:  "model")
      <*> (o .:  "choices")
      <*> (o .:? "usage")

-- | ToJSON CreateCompletionResponse
instance A.ToJSON CreateCompletionResponse where
  toJSON CreateCompletionResponse {..} =
   _omitNulls
      [ "id" .= createCompletionResponseId
      , "object" .= createCompletionResponseObject
      , "created" .= createCompletionResponseCreated
      , "model" .= createCompletionResponseModel
      , "choices" .= createCompletionResponseChoices
      , "usage" .= createCompletionResponseUsage
      ]


-- | Construct a value of type 'CreateCompletionResponse' (by applying it's required fields, if any)
mkCreateCompletionResponse
  :: Text -- ^ 'createCompletionResponseId' 
  -> Text -- ^ 'createCompletionResponseObject' 
  -> Int -- ^ 'createCompletionResponseCreated' 
  -> Text -- ^ 'createCompletionResponseModel' 
  -> [CreateCompletionResponseChoicesInner] -- ^ 'createCompletionResponseChoices' 
  -> CreateCompletionResponse
mkCreateCompletionResponse createCompletionResponseId createCompletionResponseObject createCompletionResponseCreated createCompletionResponseModel createCompletionResponseChoices =
  CreateCompletionResponse
  { createCompletionResponseId
  , createCompletionResponseObject
  , createCompletionResponseCreated
  , createCompletionResponseModel
  , createCompletionResponseChoices
  , createCompletionResponseUsage = Nothing
  }

-- ** CreateCompletionResponseChoicesInner
-- | CreateCompletionResponseChoicesInner
data CreateCompletionResponseChoicesInner = CreateCompletionResponseChoicesInner
  { createCompletionResponseChoicesInnerText :: !(Text) -- ^ /Required/ "text"
  , createCompletionResponseChoicesInnerIndex :: !(Int) -- ^ /Required/ "index"
  , createCompletionResponseChoicesInnerLogprobs :: !(CreateCompletionResponseChoicesInnerLogprobs) -- ^ /Required/ "logprobs"
  , createCompletionResponseChoicesInnerFinishReason :: !(E'FinishReason) -- ^ /Required/ "finish_reason"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateCompletionResponseChoicesInner
instance A.FromJSON CreateCompletionResponseChoicesInner where
  parseJSON = A.withObject "CreateCompletionResponseChoicesInner" $ \o ->
    CreateCompletionResponseChoicesInner
      <$> (o .:  "text")
      <*> (o .:  "index")
      <*> (o .:  "logprobs")
      <*> (o .:  "finish_reason")

-- | ToJSON CreateCompletionResponseChoicesInner
instance A.ToJSON CreateCompletionResponseChoicesInner where
  toJSON CreateCompletionResponseChoicesInner {..} =
   _omitNulls
      [ "text" .= createCompletionResponseChoicesInnerText
      , "index" .= createCompletionResponseChoicesInnerIndex
      , "logprobs" .= createCompletionResponseChoicesInnerLogprobs
      , "finish_reason" .= createCompletionResponseChoicesInnerFinishReason
      ]


-- | Construct a value of type 'CreateCompletionResponseChoicesInner' (by applying it's required fields, if any)
mkCreateCompletionResponseChoicesInner
  :: Text -- ^ 'createCompletionResponseChoicesInnerText' 
  -> Int -- ^ 'createCompletionResponseChoicesInnerIndex' 
  -> CreateCompletionResponseChoicesInnerLogprobs -- ^ 'createCompletionResponseChoicesInnerLogprobs' 
  -> E'FinishReason -- ^ 'createCompletionResponseChoicesInnerFinishReason' 
  -> CreateCompletionResponseChoicesInner
mkCreateCompletionResponseChoicesInner createCompletionResponseChoicesInnerText createCompletionResponseChoicesInnerIndex createCompletionResponseChoicesInnerLogprobs createCompletionResponseChoicesInnerFinishReason =
  CreateCompletionResponseChoicesInner
  { createCompletionResponseChoicesInnerText
  , createCompletionResponseChoicesInnerIndex
  , createCompletionResponseChoicesInnerLogprobs
  , createCompletionResponseChoicesInnerFinishReason
  }

-- ** CreateCompletionResponseChoicesInnerLogprobs
-- | CreateCompletionResponseChoicesInnerLogprobs
data CreateCompletionResponseChoicesInnerLogprobs = CreateCompletionResponseChoicesInnerLogprobs
  { createCompletionResponseChoicesInnerLogprobsTokens :: !(Maybe [Text]) -- ^ "tokens"
  , createCompletionResponseChoicesInnerLogprobsTokenLogprobs :: !(Maybe [Double]) -- ^ "token_logprobs"
  , createCompletionResponseChoicesInnerLogprobsTopLogprobs :: !(Maybe [A.Value]) -- ^ "top_logprobs"
  , createCompletionResponseChoicesInnerLogprobsTextOffset :: !(Maybe [Int]) -- ^ "text_offset"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateCompletionResponseChoicesInnerLogprobs
instance A.FromJSON CreateCompletionResponseChoicesInnerLogprobs where
  parseJSON = A.withObject "CreateCompletionResponseChoicesInnerLogprobs" $ \o ->
    CreateCompletionResponseChoicesInnerLogprobs
      <$> (o .:? "tokens")
      <*> (o .:? "token_logprobs")
      <*> (o .:? "top_logprobs")
      <*> (o .:? "text_offset")

-- | ToJSON CreateCompletionResponseChoicesInnerLogprobs
instance A.ToJSON CreateCompletionResponseChoicesInnerLogprobs where
  toJSON CreateCompletionResponseChoicesInnerLogprobs {..} =
   _omitNulls
      [ "tokens" .= createCompletionResponseChoicesInnerLogprobsTokens
      , "token_logprobs" .= createCompletionResponseChoicesInnerLogprobsTokenLogprobs
      , "top_logprobs" .= createCompletionResponseChoicesInnerLogprobsTopLogprobs
      , "text_offset" .= createCompletionResponseChoicesInnerLogprobsTextOffset
      ]


-- | Construct a value of type 'CreateCompletionResponseChoicesInnerLogprobs' (by applying it's required fields, if any)
mkCreateCompletionResponseChoicesInnerLogprobs
  :: CreateCompletionResponseChoicesInnerLogprobs
mkCreateCompletionResponseChoicesInnerLogprobs =
  CreateCompletionResponseChoicesInnerLogprobs
  { createCompletionResponseChoicesInnerLogprobsTokens = Nothing
  , createCompletionResponseChoicesInnerLogprobsTokenLogprobs = Nothing
  , createCompletionResponseChoicesInnerLogprobsTopLogprobs = Nothing
  , createCompletionResponseChoicesInnerLogprobsTextOffset = Nothing
  }

-- ** CreateCompletionResponseUsage
-- | CreateCompletionResponseUsage
data CreateCompletionResponseUsage = CreateCompletionResponseUsage
  { createCompletionResponseUsagePromptTokens :: !(Int) -- ^ /Required/ "prompt_tokens"
  , createCompletionResponseUsageCompletionTokens :: !(Int) -- ^ /Required/ "completion_tokens"
  , createCompletionResponseUsageTotalTokens :: !(Int) -- ^ /Required/ "total_tokens"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateCompletionResponseUsage
instance A.FromJSON CreateCompletionResponseUsage where
  parseJSON = A.withObject "CreateCompletionResponseUsage" $ \o ->
    CreateCompletionResponseUsage
      <$> (o .:  "prompt_tokens")
      <*> (o .:  "completion_tokens")
      <*> (o .:  "total_tokens")

-- | ToJSON CreateCompletionResponseUsage
instance A.ToJSON CreateCompletionResponseUsage where
  toJSON CreateCompletionResponseUsage {..} =
   _omitNulls
      [ "prompt_tokens" .= createCompletionResponseUsagePromptTokens
      , "completion_tokens" .= createCompletionResponseUsageCompletionTokens
      , "total_tokens" .= createCompletionResponseUsageTotalTokens
      ]


-- | Construct a value of type 'CreateCompletionResponseUsage' (by applying it's required fields, if any)
mkCreateCompletionResponseUsage
  :: Int -- ^ 'createCompletionResponseUsagePromptTokens' 
  -> Int -- ^ 'createCompletionResponseUsageCompletionTokens' 
  -> Int -- ^ 'createCompletionResponseUsageTotalTokens' 
  -> CreateCompletionResponseUsage
mkCreateCompletionResponseUsage createCompletionResponseUsagePromptTokens createCompletionResponseUsageCompletionTokens createCompletionResponseUsageTotalTokens =
  CreateCompletionResponseUsage
  { createCompletionResponseUsagePromptTokens
  , createCompletionResponseUsageCompletionTokens
  , createCompletionResponseUsageTotalTokens
  }

-- ** CreateEditRequest
-- | CreateEditRequest
data CreateEditRequest = CreateEditRequest
  { createEditRequestModel :: !(CreateEditRequestModel) -- ^ /Required/ "model"
  , createEditRequestInput :: !(Maybe Text) -- ^ "input" - The input text to use as a starting point for the edit.
  , createEditRequestInstruction :: !(Text) -- ^ /Required/ "instruction" - The instruction that tells the model how to edit the prompt.
  , createEditRequestN :: !(Maybe Int) -- ^ "n" - How many edits to generate for the input and instruction.
  , createEditRequestTemperature :: !(Maybe Double) -- ^ "temperature" - What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.  We generally recommend altering this or &#x60;top_p&#x60; but not both. 
  , createEditRequestTopP :: !(Maybe Double) -- ^ "top_p" - An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass. So 0.1 means only the tokens comprising the top 10% probability mass are considered.  We generally recommend altering this or &#x60;temperature&#x60; but not both. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateEditRequest
instance A.FromJSON CreateEditRequest where
  parseJSON = A.withObject "CreateEditRequest" $ \o ->
    CreateEditRequest
      <$> (o .:  "model")
      <*> (o .:? "input")
      <*> (o .:  "instruction")
      <*> (o .:? "n")
      <*> (o .:? "temperature")
      <*> (o .:? "top_p")

-- | ToJSON CreateEditRequest
instance A.ToJSON CreateEditRequest where
  toJSON CreateEditRequest {..} =
   _omitNulls
      [ "model" .= createEditRequestModel
      , "input" .= createEditRequestInput
      , "instruction" .= createEditRequestInstruction
      , "n" .= createEditRequestN
      , "temperature" .= createEditRequestTemperature
      , "top_p" .= createEditRequestTopP
      ]


-- | Construct a value of type 'CreateEditRequest' (by applying it's required fields, if any)
mkCreateEditRequest
  :: CreateEditRequestModel -- ^ 'createEditRequestModel' 
  -> Text -- ^ 'createEditRequestInstruction': The instruction that tells the model how to edit the prompt.
  -> CreateEditRequest
mkCreateEditRequest createEditRequestModel createEditRequestInstruction =
  CreateEditRequest
  { createEditRequestModel
  , createEditRequestInput = Nothing
  , createEditRequestInstruction
  , createEditRequestN = Nothing
  , createEditRequestTemperature = Nothing
  , createEditRequestTopP = Nothing
  }

-- ** CreateEditRequestModel
-- | CreateEditRequestModel
-- ID of the model to use. You can use the `text-davinci-edit-001` or `code-davinci-edit-001` model with this endpoint.
data CreateEditRequestModel = CreateEditRequestModel
  { 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateEditRequestModel
instance A.FromJSON CreateEditRequestModel where
  parseJSON = A.withObject "CreateEditRequestModel" $ \o ->
    pure CreateEditRequestModel
      

-- | ToJSON CreateEditRequestModel
instance A.ToJSON CreateEditRequestModel where
  toJSON CreateEditRequestModel  =
   _omitNulls
      [ 
      ]


-- | Construct a value of type 'CreateEditRequestModel' (by applying it's required fields, if any)
mkCreateEditRequestModel
  :: CreateEditRequestModel
mkCreateEditRequestModel =
  CreateEditRequestModel
  { 
  }

-- ** CreateEditResponse
-- | CreateEditResponse
data CreateEditResponse = CreateEditResponse
  { createEditResponseObject :: !(Text) -- ^ /Required/ "object"
  , createEditResponseCreated :: !(Int) -- ^ /Required/ "created"
  , createEditResponseChoices :: !([CreateEditResponseChoicesInner]) -- ^ /Required/ "choices"
  , createEditResponseUsage :: !(CreateCompletionResponseUsage) -- ^ /Required/ "usage"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateEditResponse
instance A.FromJSON CreateEditResponse where
  parseJSON = A.withObject "CreateEditResponse" $ \o ->
    CreateEditResponse
      <$> (o .:  "object")
      <*> (o .:  "created")
      <*> (o .:  "choices")
      <*> (o .:  "usage")

-- | ToJSON CreateEditResponse
instance A.ToJSON CreateEditResponse where
  toJSON CreateEditResponse {..} =
   _omitNulls
      [ "object" .= createEditResponseObject
      , "created" .= createEditResponseCreated
      , "choices" .= createEditResponseChoices
      , "usage" .= createEditResponseUsage
      ]


-- | Construct a value of type 'CreateEditResponse' (by applying it's required fields, if any)
mkCreateEditResponse
  :: Text -- ^ 'createEditResponseObject' 
  -> Int -- ^ 'createEditResponseCreated' 
  -> [CreateEditResponseChoicesInner] -- ^ 'createEditResponseChoices' 
  -> CreateCompletionResponseUsage -- ^ 'createEditResponseUsage' 
  -> CreateEditResponse
mkCreateEditResponse createEditResponseObject createEditResponseCreated createEditResponseChoices createEditResponseUsage =
  CreateEditResponse
  { createEditResponseObject
  , createEditResponseCreated
  , createEditResponseChoices
  , createEditResponseUsage
  }

-- ** CreateEditResponseChoicesInner
-- | CreateEditResponseChoicesInner
data CreateEditResponseChoicesInner = CreateEditResponseChoicesInner
  { createEditResponseChoicesInnerText :: !(Maybe Text) -- ^ "text"
  , createEditResponseChoicesInnerIndex :: !(Maybe Int) -- ^ "index"
  , createEditResponseChoicesInnerLogprobs :: !(Maybe CreateCompletionResponseChoicesInnerLogprobs) -- ^ "logprobs"
  , createEditResponseChoicesInnerFinishReason :: !(Maybe E'FinishReason) -- ^ "finish_reason"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateEditResponseChoicesInner
instance A.FromJSON CreateEditResponseChoicesInner where
  parseJSON = A.withObject "CreateEditResponseChoicesInner" $ \o ->
    CreateEditResponseChoicesInner
      <$> (o .:? "text")
      <*> (o .:? "index")
      <*> (o .:? "logprobs")
      <*> (o .:? "finish_reason")

-- | ToJSON CreateEditResponseChoicesInner
instance A.ToJSON CreateEditResponseChoicesInner where
  toJSON CreateEditResponseChoicesInner {..} =
   _omitNulls
      [ "text" .= createEditResponseChoicesInnerText
      , "index" .= createEditResponseChoicesInnerIndex
      , "logprobs" .= createEditResponseChoicesInnerLogprobs
      , "finish_reason" .= createEditResponseChoicesInnerFinishReason
      ]


-- | Construct a value of type 'CreateEditResponseChoicesInner' (by applying it's required fields, if any)
mkCreateEditResponseChoicesInner
  :: CreateEditResponseChoicesInner
mkCreateEditResponseChoicesInner =
  CreateEditResponseChoicesInner
  { createEditResponseChoicesInnerText = Nothing
  , createEditResponseChoicesInnerIndex = Nothing
  , createEditResponseChoicesInnerLogprobs = Nothing
  , createEditResponseChoicesInnerFinishReason = Nothing
  }

-- ** CreateEmbeddingRequest
-- | CreateEmbeddingRequest
data CreateEmbeddingRequest = CreateEmbeddingRequest
  { createEmbeddingRequestModel :: !(CreateEmbeddingRequestModel) -- ^ /Required/ "model"
  , createEmbeddingRequestInput :: !(CreateEmbeddingRequestInput) -- ^ /Required/ "input"
  , createEmbeddingRequestUser :: !(Maybe Text) -- ^ "user" - A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse. [Learn more](/docs/guides/safety-best-practices/end-user-ids). 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateEmbeddingRequest
instance A.FromJSON CreateEmbeddingRequest where
  parseJSON = A.withObject "CreateEmbeddingRequest" $ \o ->
    CreateEmbeddingRequest
      <$> (o .:  "model")
      <*> (o .:  "input")
      <*> (o .:? "user")

-- | ToJSON CreateEmbeddingRequest
instance A.ToJSON CreateEmbeddingRequest where
  toJSON CreateEmbeddingRequest {..} =
   _omitNulls
      [ "model" .= createEmbeddingRequestModel
      , "input" .= createEmbeddingRequestInput
      , "user" .= createEmbeddingRequestUser
      ]


-- | Construct a value of type 'CreateEmbeddingRequest' (by applying it's required fields, if any)
mkCreateEmbeddingRequest
  :: CreateEmbeddingRequestModel -- ^ 'createEmbeddingRequestModel' 
  -> CreateEmbeddingRequestInput -- ^ 'createEmbeddingRequestInput' 
  -> CreateEmbeddingRequest
mkCreateEmbeddingRequest createEmbeddingRequestModel createEmbeddingRequestInput =
  CreateEmbeddingRequest
  { createEmbeddingRequestModel
  , createEmbeddingRequestInput
  , createEmbeddingRequestUser = Nothing
  }

-- ** CreateEmbeddingRequestInput
-- | CreateEmbeddingRequestInput
-- Input text to embed, encoded as a string or array of tokens. To embed multiple inputs in a single request, pass an array of strings or array of token arrays. Each input must not exceed the max input tokens for the model (8191 tokens for `text-embedding-ada-002`). [Example Python code](https://github.com/openai/openai-cookbook/blob/main/examples/How_to_count_tokens_with_tiktoken.ipynb) for counting tokens. 
data CreateEmbeddingRequestInput = CreateEmbeddingRequestInput
  { 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateEmbeddingRequestInput
instance A.FromJSON CreateEmbeddingRequestInput where
  parseJSON = A.withObject "CreateEmbeddingRequestInput" $ \o ->
    pure CreateEmbeddingRequestInput
      

-- | ToJSON CreateEmbeddingRequestInput
instance A.ToJSON CreateEmbeddingRequestInput where
  toJSON CreateEmbeddingRequestInput  =
   _omitNulls
      [ 
      ]


-- | Construct a value of type 'CreateEmbeddingRequestInput' (by applying it's required fields, if any)
mkCreateEmbeddingRequestInput
  :: CreateEmbeddingRequestInput
mkCreateEmbeddingRequestInput =
  CreateEmbeddingRequestInput
  { 
  }

-- ** CreateEmbeddingRequestModel
-- | CreateEmbeddingRequestModel
-- ID of the model to use. You can use the [List models](/docs/api-reference/models/list) API to see all of your available models, or see our [Model overview](/docs/models/overview) for descriptions of them. 
data CreateEmbeddingRequestModel = CreateEmbeddingRequestModel
  { 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateEmbeddingRequestModel
instance A.FromJSON CreateEmbeddingRequestModel where
  parseJSON = A.withObject "CreateEmbeddingRequestModel" $ \o ->
    pure CreateEmbeddingRequestModel
      

-- | ToJSON CreateEmbeddingRequestModel
instance A.ToJSON CreateEmbeddingRequestModel where
  toJSON CreateEmbeddingRequestModel  =
   _omitNulls
      [ 
      ]


-- | Construct a value of type 'CreateEmbeddingRequestModel' (by applying it's required fields, if any)
mkCreateEmbeddingRequestModel
  :: CreateEmbeddingRequestModel
mkCreateEmbeddingRequestModel =
  CreateEmbeddingRequestModel
  { 
  }

-- ** CreateEmbeddingResponse
-- | CreateEmbeddingResponse
data CreateEmbeddingResponse = CreateEmbeddingResponse
  { createEmbeddingResponseObject :: !(Text) -- ^ /Required/ "object"
  , createEmbeddingResponseModel :: !(Text) -- ^ /Required/ "model"
  , createEmbeddingResponseData :: !([CreateEmbeddingResponseDataInner]) -- ^ /Required/ "data"
  , createEmbeddingResponseUsage :: !(CreateEmbeddingResponseUsage) -- ^ /Required/ "usage"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateEmbeddingResponse
instance A.FromJSON CreateEmbeddingResponse where
  parseJSON = A.withObject "CreateEmbeddingResponse" $ \o ->
    CreateEmbeddingResponse
      <$> (o .:  "object")
      <*> (o .:  "model")
      <*> (o .:  "data")
      <*> (o .:  "usage")

-- | ToJSON CreateEmbeddingResponse
instance A.ToJSON CreateEmbeddingResponse where
  toJSON CreateEmbeddingResponse {..} =
   _omitNulls
      [ "object" .= createEmbeddingResponseObject
      , "model" .= createEmbeddingResponseModel
      , "data" .= createEmbeddingResponseData
      , "usage" .= createEmbeddingResponseUsage
      ]


-- | Construct a value of type 'CreateEmbeddingResponse' (by applying it's required fields, if any)
mkCreateEmbeddingResponse
  :: Text -- ^ 'createEmbeddingResponseObject' 
  -> Text -- ^ 'createEmbeddingResponseModel' 
  -> [CreateEmbeddingResponseDataInner] -- ^ 'createEmbeddingResponseData' 
  -> CreateEmbeddingResponseUsage -- ^ 'createEmbeddingResponseUsage' 
  -> CreateEmbeddingResponse
mkCreateEmbeddingResponse createEmbeddingResponseObject createEmbeddingResponseModel createEmbeddingResponseData createEmbeddingResponseUsage =
  CreateEmbeddingResponse
  { createEmbeddingResponseObject
  , createEmbeddingResponseModel
  , createEmbeddingResponseData
  , createEmbeddingResponseUsage
  }

-- ** CreateEmbeddingResponseDataInner
-- | CreateEmbeddingResponseDataInner
data CreateEmbeddingResponseDataInner = CreateEmbeddingResponseDataInner
  { createEmbeddingResponseDataInnerIndex :: !(Int) -- ^ /Required/ "index"
  , createEmbeddingResponseDataInnerObject :: !(Text) -- ^ /Required/ "object"
  , createEmbeddingResponseDataInnerEmbedding :: !([Double]) -- ^ /Required/ "embedding"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateEmbeddingResponseDataInner
instance A.FromJSON CreateEmbeddingResponseDataInner where
  parseJSON = A.withObject "CreateEmbeddingResponseDataInner" $ \o ->
    CreateEmbeddingResponseDataInner
      <$> (o .:  "index")
      <*> (o .:  "object")
      <*> (o .:  "embedding")

-- | ToJSON CreateEmbeddingResponseDataInner
instance A.ToJSON CreateEmbeddingResponseDataInner where
  toJSON CreateEmbeddingResponseDataInner {..} =
   _omitNulls
      [ "index" .= createEmbeddingResponseDataInnerIndex
      , "object" .= createEmbeddingResponseDataInnerObject
      , "embedding" .= createEmbeddingResponseDataInnerEmbedding
      ]


-- | Construct a value of type 'CreateEmbeddingResponseDataInner' (by applying it's required fields, if any)
mkCreateEmbeddingResponseDataInner
  :: Int -- ^ 'createEmbeddingResponseDataInnerIndex' 
  -> Text -- ^ 'createEmbeddingResponseDataInnerObject' 
  -> [Double] -- ^ 'createEmbeddingResponseDataInnerEmbedding' 
  -> CreateEmbeddingResponseDataInner
mkCreateEmbeddingResponseDataInner createEmbeddingResponseDataInnerIndex createEmbeddingResponseDataInnerObject createEmbeddingResponseDataInnerEmbedding =
  CreateEmbeddingResponseDataInner
  { createEmbeddingResponseDataInnerIndex
  , createEmbeddingResponseDataInnerObject
  , createEmbeddingResponseDataInnerEmbedding
  }

-- ** CreateEmbeddingResponseUsage
-- | CreateEmbeddingResponseUsage
data CreateEmbeddingResponseUsage = CreateEmbeddingResponseUsage
  { createEmbeddingResponseUsagePromptTokens :: !(Int) -- ^ /Required/ "prompt_tokens"
  , createEmbeddingResponseUsageTotalTokens :: !(Int) -- ^ /Required/ "total_tokens"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateEmbeddingResponseUsage
instance A.FromJSON CreateEmbeddingResponseUsage where
  parseJSON = A.withObject "CreateEmbeddingResponseUsage" $ \o ->
    CreateEmbeddingResponseUsage
      <$> (o .:  "prompt_tokens")
      <*> (o .:  "total_tokens")

-- | ToJSON CreateEmbeddingResponseUsage
instance A.ToJSON CreateEmbeddingResponseUsage where
  toJSON CreateEmbeddingResponseUsage {..} =
   _omitNulls
      [ "prompt_tokens" .= createEmbeddingResponseUsagePromptTokens
      , "total_tokens" .= createEmbeddingResponseUsageTotalTokens
      ]


-- | Construct a value of type 'CreateEmbeddingResponseUsage' (by applying it's required fields, if any)
mkCreateEmbeddingResponseUsage
  :: Int -- ^ 'createEmbeddingResponseUsagePromptTokens' 
  -> Int -- ^ 'createEmbeddingResponseUsageTotalTokens' 
  -> CreateEmbeddingResponseUsage
mkCreateEmbeddingResponseUsage createEmbeddingResponseUsagePromptTokens createEmbeddingResponseUsageTotalTokens =
  CreateEmbeddingResponseUsage
  { createEmbeddingResponseUsagePromptTokens
  , createEmbeddingResponseUsageTotalTokens
  }

-- ** CreateFineTuneRequest
-- | CreateFineTuneRequest
data CreateFineTuneRequest = CreateFineTuneRequest
  { createFineTuneRequestTrainingFile :: !(Text) -- ^ /Required/ "training_file" - The ID of an uploaded file that contains training data.  See [upload file](/docs/api-reference/files/upload) for how to upload a file.  Your dataset must be formatted as a JSONL file, where each training example is a JSON object with the keys \&quot;prompt\&quot; and \&quot;completion\&quot;. Additionally, you must upload your file with the purpose &#x60;fine-tune&#x60;.  See the [fine-tuning guide](/docs/guides/fine-tuning/creating-training-data) for more details. 
  , createFineTuneRequestValidationFile :: !(Maybe Text) -- ^ "validation_file" - The ID of an uploaded file that contains validation data.  If you provide this file, the data is used to generate validation metrics periodically during fine-tuning. These metrics can be viewed in the [fine-tuning results file](/docs/guides/fine-tuning/analyzing-your-fine-tuned-model). Your train and validation data should be mutually exclusive.  Your dataset must be formatted as a JSONL file, where each validation example is a JSON object with the keys \&quot;prompt\&quot; and \&quot;completion\&quot;. Additionally, you must upload your file with the purpose &#x60;fine-tune&#x60;.  See the [fine-tuning guide](/docs/guides/fine-tuning/creating-training-data) for more details. 
  , createFineTuneRequestModel :: !(Maybe CreateFineTuneRequestModel) -- ^ "model"
  , createFineTuneRequestNEpochs :: !(Maybe Int) -- ^ "n_epochs" - The number of epochs to train the model for. An epoch refers to one full cycle through the training dataset. 
  , createFineTuneRequestBatchSize :: !(Maybe Int) -- ^ "batch_size" - The batch size to use for training. The batch size is the number of training examples used to train a single forward and backward pass.  By default, the batch size will be dynamically configured to be ~0.2% of the number of examples in the training set, capped at 256 - in general, we&#39;ve found that larger batch sizes tend to work better for larger datasets. 
  , createFineTuneRequestLearningRateMultiplier :: !(Maybe Double) -- ^ "learning_rate_multiplier" - The learning rate multiplier to use for training. The fine-tuning learning rate is the original learning rate used for pretraining multiplied by this value.  By default, the learning rate multiplier is the 0.05, 0.1, or 0.2 depending on final &#x60;batch_size&#x60; (larger learning rates tend to perform better with larger batch sizes). We recommend experimenting with values in the range 0.02 to 0.2 to see what produces the best results. 
  , createFineTuneRequestPromptLossWeight :: !(Maybe Double) -- ^ "prompt_loss_weight" - The weight to use for loss on the prompt tokens. This controls how much the model tries to learn to generate the prompt (as compared to the completion which always has a weight of 1.0), and can add a stabilizing effect to training when completions are short.  If prompts are extremely long (relative to completions), it may make sense to reduce this weight so as to avoid over-prioritizing learning the prompt. 
  , createFineTuneRequestComputeClassificationMetrics :: !(Maybe Bool) -- ^ "compute_classification_metrics" - If set, we calculate classification-specific metrics such as accuracy and F-1 score using the validation set at the end of every epoch. These metrics can be viewed in the [results file](/docs/guides/fine-tuning/analyzing-your-fine-tuned-model).  In order to compute classification metrics, you must provide a &#x60;validation_file&#x60;. Additionally, you must specify &#x60;classification_n_classes&#x60; for multiclass classification or &#x60;classification_positive_class&#x60; for binary classification. 
  , createFineTuneRequestClassificationNClasses :: !(Maybe Int) -- ^ "classification_n_classes" - The number of classes in a classification task.  This parameter is required for multiclass classification. 
  , createFineTuneRequestClassificationPositiveClass :: !(Maybe Text) -- ^ "classification_positive_class" - The positive class in binary classification.  This parameter is needed to generate precision, recall, and F1 metrics when doing binary classification. 
  , createFineTuneRequestClassificationBetas :: !(Maybe [Double]) -- ^ "classification_betas" - If this is provided, we calculate F-beta scores at the specified beta values. The F-beta score is a generalization of F-1 score. This is only used for binary classification.  With a beta of 1 (i.e. the F-1 score), precision and recall are given the same weight. A larger beta score puts more weight on recall and less on precision. A smaller beta score puts more weight on precision and less on recall. 
  , createFineTuneRequestSuffix :: !(Maybe Text) -- ^ "suffix" - A string of up to 40 characters that will be added to your fine-tuned model name.  For example, a &#x60;suffix&#x60; of \&quot;custom-model-name\&quot; would produce a model name like &#x60;ada:ft-your-org:custom-model-name-2022-02-15-04-21-04&#x60;. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateFineTuneRequest
instance A.FromJSON CreateFineTuneRequest where
  parseJSON = A.withObject "CreateFineTuneRequest" $ \o ->
    CreateFineTuneRequest
      <$> (o .:  "training_file")
      <*> (o .:? "validation_file")
      <*> (o .:? "model")
      <*> (o .:? "n_epochs")
      <*> (o .:? "batch_size")
      <*> (o .:? "learning_rate_multiplier")
      <*> (o .:? "prompt_loss_weight")
      <*> (o .:? "compute_classification_metrics")
      <*> (o .:? "classification_n_classes")
      <*> (o .:? "classification_positive_class")
      <*> (o .:? "classification_betas")
      <*> (o .:? "suffix")

-- | ToJSON CreateFineTuneRequest
instance A.ToJSON CreateFineTuneRequest where
  toJSON CreateFineTuneRequest {..} =
   _omitNulls
      [ "training_file" .= createFineTuneRequestTrainingFile
      , "validation_file" .= createFineTuneRequestValidationFile
      , "model" .= createFineTuneRequestModel
      , "n_epochs" .= createFineTuneRequestNEpochs
      , "batch_size" .= createFineTuneRequestBatchSize
      , "learning_rate_multiplier" .= createFineTuneRequestLearningRateMultiplier
      , "prompt_loss_weight" .= createFineTuneRequestPromptLossWeight
      , "compute_classification_metrics" .= createFineTuneRequestComputeClassificationMetrics
      , "classification_n_classes" .= createFineTuneRequestClassificationNClasses
      , "classification_positive_class" .= createFineTuneRequestClassificationPositiveClass
      , "classification_betas" .= createFineTuneRequestClassificationBetas
      , "suffix" .= createFineTuneRequestSuffix
      ]


-- | Construct a value of type 'CreateFineTuneRequest' (by applying it's required fields, if any)
mkCreateFineTuneRequest
  :: Text -- ^ 'createFineTuneRequestTrainingFile': The ID of an uploaded file that contains training data.  See [upload file](/docs/api-reference/files/upload) for how to upload a file.  Your dataset must be formatted as a JSONL file, where each training example is a JSON object with the keys \"prompt\" and \"completion\". Additionally, you must upload your file with the purpose `fine-tune`.  See the [fine-tuning guide](/docs/guides/fine-tuning/creating-training-data) for more details. 
  -> CreateFineTuneRequest
mkCreateFineTuneRequest createFineTuneRequestTrainingFile =
  CreateFineTuneRequest
  { createFineTuneRequestTrainingFile
  , createFineTuneRequestValidationFile = Nothing
  , createFineTuneRequestModel = Nothing
  , createFineTuneRequestNEpochs = Nothing
  , createFineTuneRequestBatchSize = Nothing
  , createFineTuneRequestLearningRateMultiplier = Nothing
  , createFineTuneRequestPromptLossWeight = Nothing
  , createFineTuneRequestComputeClassificationMetrics = Nothing
  , createFineTuneRequestClassificationNClasses = Nothing
  , createFineTuneRequestClassificationPositiveClass = Nothing
  , createFineTuneRequestClassificationBetas = Nothing
  , createFineTuneRequestSuffix = Nothing
  }

-- ** CreateFineTuneRequestModel
-- | CreateFineTuneRequestModel
-- The name of the base model to fine-tune. You can select one of \"ada\", \"babbage\", \"curie\", \"davinci\", or a fine-tuned model created after 2022-04-21. To learn more about these models, see the [Models](https://platform.openai.com/docs/models) documentation. 
data CreateFineTuneRequestModel = CreateFineTuneRequestModel
  { 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateFineTuneRequestModel
instance A.FromJSON CreateFineTuneRequestModel where
  parseJSON = A.withObject "CreateFineTuneRequestModel" $ \o ->
    pure CreateFineTuneRequestModel
      

-- | ToJSON CreateFineTuneRequestModel
instance A.ToJSON CreateFineTuneRequestModel where
  toJSON CreateFineTuneRequestModel  =
   _omitNulls
      [ 
      ]


-- | Construct a value of type 'CreateFineTuneRequestModel' (by applying it's required fields, if any)
mkCreateFineTuneRequestModel
  :: CreateFineTuneRequestModel
mkCreateFineTuneRequestModel =
  CreateFineTuneRequestModel
  { 
  }

-- ** CreateImageRequest
-- | CreateImageRequest
data CreateImageRequest = CreateImageRequest
  { createImageRequestPrompt :: !(Text) -- ^ /Required/ "prompt" - A text description of the desired image(s). The maximum length is 1000 characters.
  , createImageRequestN :: !(Maybe Int) -- ^ "n" - The number of images to generate. Must be between 1 and 10.
  , createImageRequestSize :: !(Maybe E'Size) -- ^ "size" - The size of the generated images. Must be one of &#x60;256x256&#x60;, &#x60;512x512&#x60;, or &#x60;1024x1024&#x60;.
  , createImageRequestResponseFormat :: !(Maybe E'ResponseFormat) -- ^ "response_format" - The format in which the generated images are returned. Must be one of &#x60;url&#x60; or &#x60;b64_json&#x60;.
  , createImageRequestUser :: !(Maybe Text) -- ^ "user" - A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse. [Learn more](/docs/guides/safety-best-practices/end-user-ids). 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateImageRequest
instance A.FromJSON CreateImageRequest where
  parseJSON = A.withObject "CreateImageRequest" $ \o ->
    CreateImageRequest
      <$> (o .:  "prompt")
      <*> (o .:? "n")
      <*> (o .:? "size")
      <*> (o .:? "response_format")
      <*> (o .:? "user")

-- | ToJSON CreateImageRequest
instance A.ToJSON CreateImageRequest where
  toJSON CreateImageRequest {..} =
   _omitNulls
      [ "prompt" .= createImageRequestPrompt
      , "n" .= createImageRequestN
      , "size" .= createImageRequestSize
      , "response_format" .= createImageRequestResponseFormat
      , "user" .= createImageRequestUser
      ]


-- | Construct a value of type 'CreateImageRequest' (by applying it's required fields, if any)
mkCreateImageRequest
  :: Text -- ^ 'createImageRequestPrompt': A text description of the desired image(s). The maximum length is 1000 characters.
  -> CreateImageRequest
mkCreateImageRequest createImageRequestPrompt =
  CreateImageRequest
  { createImageRequestPrompt
  , createImageRequestN = Nothing
  , createImageRequestSize = Nothing
  , createImageRequestResponseFormat = Nothing
  , createImageRequestUser = Nothing
  }

-- ** CreateModerationRequest
-- | CreateModerationRequest
data CreateModerationRequest = CreateModerationRequest
  { createModerationRequestInput :: !(CreateModerationRequestInput) -- ^ /Required/ "input"
  , createModerationRequestModel :: !(Maybe CreateModerationRequestModel) -- ^ "model"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateModerationRequest
instance A.FromJSON CreateModerationRequest where
  parseJSON = A.withObject "CreateModerationRequest" $ \o ->
    CreateModerationRequest
      <$> (o .:  "input")
      <*> (o .:? "model")

-- | ToJSON CreateModerationRequest
instance A.ToJSON CreateModerationRequest where
  toJSON CreateModerationRequest {..} =
   _omitNulls
      [ "input" .= createModerationRequestInput
      , "model" .= createModerationRequestModel
      ]


-- | Construct a value of type 'CreateModerationRequest' (by applying it's required fields, if any)
mkCreateModerationRequest
  :: CreateModerationRequestInput -- ^ 'createModerationRequestInput' 
  -> CreateModerationRequest
mkCreateModerationRequest createModerationRequestInput =
  CreateModerationRequest
  { createModerationRequestInput
  , createModerationRequestModel = Nothing
  }

-- ** CreateModerationRequestInput
-- | CreateModerationRequestInput
-- The input text to classify
data CreateModerationRequestInput = CreateModerationRequestInput
  { 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateModerationRequestInput
instance A.FromJSON CreateModerationRequestInput where
  parseJSON = A.withObject "CreateModerationRequestInput" $ \o ->
    pure CreateModerationRequestInput
      

-- | ToJSON CreateModerationRequestInput
instance A.ToJSON CreateModerationRequestInput where
  toJSON CreateModerationRequestInput  =
   _omitNulls
      [ 
      ]


-- | Construct a value of type 'CreateModerationRequestInput' (by applying it's required fields, if any)
mkCreateModerationRequestInput
  :: CreateModerationRequestInput
mkCreateModerationRequestInput =
  CreateModerationRequestInput
  { 
  }

-- ** CreateModerationRequestModel
-- | CreateModerationRequestModel
-- Two content moderations models are available: `text-moderation-stable` and `text-moderation-latest`.  The default is `text-moderation-latest` which will be automatically upgraded over time. This ensures you are always using our most accurate model. If you use `text-moderation-stable`, we will provide advanced notice before updating the model. Accuracy of `text-moderation-stable` may be slightly lower than for `text-moderation-latest`. 
data CreateModerationRequestModel = CreateModerationRequestModel
  { 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateModerationRequestModel
instance A.FromJSON CreateModerationRequestModel where
  parseJSON = A.withObject "CreateModerationRequestModel" $ \o ->
    pure CreateModerationRequestModel
      

-- | ToJSON CreateModerationRequestModel
instance A.ToJSON CreateModerationRequestModel where
  toJSON CreateModerationRequestModel  =
   _omitNulls
      [ 
      ]


-- | Construct a value of type 'CreateModerationRequestModel' (by applying it's required fields, if any)
mkCreateModerationRequestModel
  :: CreateModerationRequestModel
mkCreateModerationRequestModel =
  CreateModerationRequestModel
  { 
  }

-- ** CreateModerationResponse
-- | CreateModerationResponse
data CreateModerationResponse = CreateModerationResponse
  { createModerationResponseId :: !(Text) -- ^ /Required/ "id"
  , createModerationResponseModel :: !(Text) -- ^ /Required/ "model"
  , createModerationResponseResults :: !([CreateModerationResponseResultsInner]) -- ^ /Required/ "results"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateModerationResponse
instance A.FromJSON CreateModerationResponse where
  parseJSON = A.withObject "CreateModerationResponse" $ \o ->
    CreateModerationResponse
      <$> (o .:  "id")
      <*> (o .:  "model")
      <*> (o .:  "results")

-- | ToJSON CreateModerationResponse
instance A.ToJSON CreateModerationResponse where
  toJSON CreateModerationResponse {..} =
   _omitNulls
      [ "id" .= createModerationResponseId
      , "model" .= createModerationResponseModel
      , "results" .= createModerationResponseResults
      ]


-- | Construct a value of type 'CreateModerationResponse' (by applying it's required fields, if any)
mkCreateModerationResponse
  :: Text -- ^ 'createModerationResponseId' 
  -> Text -- ^ 'createModerationResponseModel' 
  -> [CreateModerationResponseResultsInner] -- ^ 'createModerationResponseResults' 
  -> CreateModerationResponse
mkCreateModerationResponse createModerationResponseId createModerationResponseModel createModerationResponseResults =
  CreateModerationResponse
  { createModerationResponseId
  , createModerationResponseModel
  , createModerationResponseResults
  }

-- ** CreateModerationResponseResultsInner
-- | CreateModerationResponseResultsInner
data CreateModerationResponseResultsInner = CreateModerationResponseResultsInner
  { createModerationResponseResultsInnerFlagged :: !(Bool) -- ^ /Required/ "flagged"
  , createModerationResponseResultsInnerCategories :: !(CreateModerationResponseResultsInnerCategories) -- ^ /Required/ "categories"
  , createModerationResponseResultsInnerCategoryScores :: !(CreateModerationResponseResultsInnerCategoryScores) -- ^ /Required/ "category_scores"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateModerationResponseResultsInner
instance A.FromJSON CreateModerationResponseResultsInner where
  parseJSON = A.withObject "CreateModerationResponseResultsInner" $ \o ->
    CreateModerationResponseResultsInner
      <$> (o .:  "flagged")
      <*> (o .:  "categories")
      <*> (o .:  "category_scores")

-- | ToJSON CreateModerationResponseResultsInner
instance A.ToJSON CreateModerationResponseResultsInner where
  toJSON CreateModerationResponseResultsInner {..} =
   _omitNulls
      [ "flagged" .= createModerationResponseResultsInnerFlagged
      , "categories" .= createModerationResponseResultsInnerCategories
      , "category_scores" .= createModerationResponseResultsInnerCategoryScores
      ]


-- | Construct a value of type 'CreateModerationResponseResultsInner' (by applying it's required fields, if any)
mkCreateModerationResponseResultsInner
  :: Bool -- ^ 'createModerationResponseResultsInnerFlagged' 
  -> CreateModerationResponseResultsInnerCategories -- ^ 'createModerationResponseResultsInnerCategories' 
  -> CreateModerationResponseResultsInnerCategoryScores -- ^ 'createModerationResponseResultsInnerCategoryScores' 
  -> CreateModerationResponseResultsInner
mkCreateModerationResponseResultsInner createModerationResponseResultsInnerFlagged createModerationResponseResultsInnerCategories createModerationResponseResultsInnerCategoryScores =
  CreateModerationResponseResultsInner
  { createModerationResponseResultsInnerFlagged
  , createModerationResponseResultsInnerCategories
  , createModerationResponseResultsInnerCategoryScores
  }

-- ** CreateModerationResponseResultsInnerCategories
-- | CreateModerationResponseResultsInnerCategories
data CreateModerationResponseResultsInnerCategories = CreateModerationResponseResultsInnerCategories
  { createModerationResponseResultsInnerCategoriesHate :: !(Bool) -- ^ /Required/ "hate"
  , createModerationResponseResultsInnerCategoriesHateThreatening :: !(Bool) -- ^ /Required/ "hate/threatening"
  , createModerationResponseResultsInnerCategoriesSelfHarm :: !(Bool) -- ^ /Required/ "self-harm"
  , createModerationResponseResultsInnerCategoriesSexual :: !(Bool) -- ^ /Required/ "sexual"
  , createModerationResponseResultsInnerCategoriesSexualMinors :: !(Bool) -- ^ /Required/ "sexual/minors"
  , createModerationResponseResultsInnerCategoriesViolence :: !(Bool) -- ^ /Required/ "violence"
  , createModerationResponseResultsInnerCategoriesViolenceGraphic :: !(Bool) -- ^ /Required/ "violence/graphic"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateModerationResponseResultsInnerCategories
instance A.FromJSON CreateModerationResponseResultsInnerCategories where
  parseJSON = A.withObject "CreateModerationResponseResultsInnerCategories" $ \o ->
    CreateModerationResponseResultsInnerCategories
      <$> (o .:  "hate")
      <*> (o .:  "hate/threatening")
      <*> (o .:  "self-harm")
      <*> (o .:  "sexual")
      <*> (o .:  "sexual/minors")
      <*> (o .:  "violence")
      <*> (o .:  "violence/graphic")

-- | ToJSON CreateModerationResponseResultsInnerCategories
instance A.ToJSON CreateModerationResponseResultsInnerCategories where
  toJSON CreateModerationResponseResultsInnerCategories {..} =
   _omitNulls
      [ "hate" .= createModerationResponseResultsInnerCategoriesHate
      , "hate/threatening" .= createModerationResponseResultsInnerCategoriesHateThreatening
      , "self-harm" .= createModerationResponseResultsInnerCategoriesSelfHarm
      , "sexual" .= createModerationResponseResultsInnerCategoriesSexual
      , "sexual/minors" .= createModerationResponseResultsInnerCategoriesSexualMinors
      , "violence" .= createModerationResponseResultsInnerCategoriesViolence
      , "violence/graphic" .= createModerationResponseResultsInnerCategoriesViolenceGraphic
      ]


-- | Construct a value of type 'CreateModerationResponseResultsInnerCategories' (by applying it's required fields, if any)
mkCreateModerationResponseResultsInnerCategories
  :: Bool -- ^ 'createModerationResponseResultsInnerCategoriesHate' 
  -> Bool -- ^ 'createModerationResponseResultsInnerCategoriesHateThreatening' 
  -> Bool -- ^ 'createModerationResponseResultsInnerCategoriesSelfHarm' 
  -> Bool -- ^ 'createModerationResponseResultsInnerCategoriesSexual' 
  -> Bool -- ^ 'createModerationResponseResultsInnerCategoriesSexualMinors' 
  -> Bool -- ^ 'createModerationResponseResultsInnerCategoriesViolence' 
  -> Bool -- ^ 'createModerationResponseResultsInnerCategoriesViolenceGraphic' 
  -> CreateModerationResponseResultsInnerCategories
mkCreateModerationResponseResultsInnerCategories createModerationResponseResultsInnerCategoriesHate createModerationResponseResultsInnerCategoriesHateThreatening createModerationResponseResultsInnerCategoriesSelfHarm createModerationResponseResultsInnerCategoriesSexual createModerationResponseResultsInnerCategoriesSexualMinors createModerationResponseResultsInnerCategoriesViolence createModerationResponseResultsInnerCategoriesViolenceGraphic =
  CreateModerationResponseResultsInnerCategories
  { createModerationResponseResultsInnerCategoriesHate
  , createModerationResponseResultsInnerCategoriesHateThreatening
  , createModerationResponseResultsInnerCategoriesSelfHarm
  , createModerationResponseResultsInnerCategoriesSexual
  , createModerationResponseResultsInnerCategoriesSexualMinors
  , createModerationResponseResultsInnerCategoriesViolence
  , createModerationResponseResultsInnerCategoriesViolenceGraphic
  }

-- ** CreateModerationResponseResultsInnerCategoryScores
-- | CreateModerationResponseResultsInnerCategoryScores
data CreateModerationResponseResultsInnerCategoryScores = CreateModerationResponseResultsInnerCategoryScores
  { createModerationResponseResultsInnerCategoryScoresHate :: !(Double) -- ^ /Required/ "hate"
  , createModerationResponseResultsInnerCategoryScoresHateThreatening :: !(Double) -- ^ /Required/ "hate/threatening"
  , createModerationResponseResultsInnerCategoryScoresSelfHarm :: !(Double) -- ^ /Required/ "self-harm"
  , createModerationResponseResultsInnerCategoryScoresSexual :: !(Double) -- ^ /Required/ "sexual"
  , createModerationResponseResultsInnerCategoryScoresSexualMinors :: !(Double) -- ^ /Required/ "sexual/minors"
  , createModerationResponseResultsInnerCategoryScoresViolence :: !(Double) -- ^ /Required/ "violence"
  , createModerationResponseResultsInnerCategoryScoresViolenceGraphic :: !(Double) -- ^ /Required/ "violence/graphic"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateModerationResponseResultsInnerCategoryScores
instance A.FromJSON CreateModerationResponseResultsInnerCategoryScores where
  parseJSON = A.withObject "CreateModerationResponseResultsInnerCategoryScores" $ \o ->
    CreateModerationResponseResultsInnerCategoryScores
      <$> (o .:  "hate")
      <*> (o .:  "hate/threatening")
      <*> (o .:  "self-harm")
      <*> (o .:  "sexual")
      <*> (o .:  "sexual/minors")
      <*> (o .:  "violence")
      <*> (o .:  "violence/graphic")

-- | ToJSON CreateModerationResponseResultsInnerCategoryScores
instance A.ToJSON CreateModerationResponseResultsInnerCategoryScores where
  toJSON CreateModerationResponseResultsInnerCategoryScores {..} =
   _omitNulls
      [ "hate" .= createModerationResponseResultsInnerCategoryScoresHate
      , "hate/threatening" .= createModerationResponseResultsInnerCategoryScoresHateThreatening
      , "self-harm" .= createModerationResponseResultsInnerCategoryScoresSelfHarm
      , "sexual" .= createModerationResponseResultsInnerCategoryScoresSexual
      , "sexual/minors" .= createModerationResponseResultsInnerCategoryScoresSexualMinors
      , "violence" .= createModerationResponseResultsInnerCategoryScoresViolence
      , "violence/graphic" .= createModerationResponseResultsInnerCategoryScoresViolenceGraphic
      ]


-- | Construct a value of type 'CreateModerationResponseResultsInnerCategoryScores' (by applying it's required fields, if any)
mkCreateModerationResponseResultsInnerCategoryScores
  :: Double -- ^ 'createModerationResponseResultsInnerCategoryScoresHate' 
  -> Double -- ^ 'createModerationResponseResultsInnerCategoryScoresHateThreatening' 
  -> Double -- ^ 'createModerationResponseResultsInnerCategoryScoresSelfHarm' 
  -> Double -- ^ 'createModerationResponseResultsInnerCategoryScoresSexual' 
  -> Double -- ^ 'createModerationResponseResultsInnerCategoryScoresSexualMinors' 
  -> Double -- ^ 'createModerationResponseResultsInnerCategoryScoresViolence' 
  -> Double -- ^ 'createModerationResponseResultsInnerCategoryScoresViolenceGraphic' 
  -> CreateModerationResponseResultsInnerCategoryScores
mkCreateModerationResponseResultsInnerCategoryScores createModerationResponseResultsInnerCategoryScoresHate createModerationResponseResultsInnerCategoryScoresHateThreatening createModerationResponseResultsInnerCategoryScoresSelfHarm createModerationResponseResultsInnerCategoryScoresSexual createModerationResponseResultsInnerCategoryScoresSexualMinors createModerationResponseResultsInnerCategoryScoresViolence createModerationResponseResultsInnerCategoryScoresViolenceGraphic =
  CreateModerationResponseResultsInnerCategoryScores
  { createModerationResponseResultsInnerCategoryScoresHate
  , createModerationResponseResultsInnerCategoryScoresHateThreatening
  , createModerationResponseResultsInnerCategoryScoresSelfHarm
  , createModerationResponseResultsInnerCategoryScoresSexual
  , createModerationResponseResultsInnerCategoryScoresSexualMinors
  , createModerationResponseResultsInnerCategoryScoresViolence
  , createModerationResponseResultsInnerCategoryScoresViolenceGraphic
  }

-- ** CreateTranscriptionResponse
-- | CreateTranscriptionResponse
data CreateTranscriptionResponse = CreateTranscriptionResponse
  { createTranscriptionResponseText :: !(Text) -- ^ /Required/ "text"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateTranscriptionResponse
instance A.FromJSON CreateTranscriptionResponse where
  parseJSON = A.withObject "CreateTranscriptionResponse" $ \o ->
    CreateTranscriptionResponse
      <$> (o .:  "text")

-- | ToJSON CreateTranscriptionResponse
instance A.ToJSON CreateTranscriptionResponse where
  toJSON CreateTranscriptionResponse {..} =
   _omitNulls
      [ "text" .= createTranscriptionResponseText
      ]


-- | Construct a value of type 'CreateTranscriptionResponse' (by applying it's required fields, if any)
mkCreateTranscriptionResponse
  :: Text -- ^ 'createTranscriptionResponseText' 
  -> CreateTranscriptionResponse
mkCreateTranscriptionResponse createTranscriptionResponseText =
  CreateTranscriptionResponse
  { createTranscriptionResponseText
  }

-- ** CreateTranslationResponse
-- | CreateTranslationResponse
data CreateTranslationResponse = CreateTranslationResponse
  { createTranslationResponseText :: !(Text) -- ^ /Required/ "text"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateTranslationResponse
instance A.FromJSON CreateTranslationResponse where
  parseJSON = A.withObject "CreateTranslationResponse" $ \o ->
    CreateTranslationResponse
      <$> (o .:  "text")

-- | ToJSON CreateTranslationResponse
instance A.ToJSON CreateTranslationResponse where
  toJSON CreateTranslationResponse {..} =
   _omitNulls
      [ "text" .= createTranslationResponseText
      ]


-- | Construct a value of type 'CreateTranslationResponse' (by applying it's required fields, if any)
mkCreateTranslationResponse
  :: Text -- ^ 'createTranslationResponseText' 
  -> CreateTranslationResponse
mkCreateTranslationResponse createTranslationResponseText =
  CreateTranslationResponse
  { createTranslationResponseText
  }

-- ** DeleteFileResponse
-- | DeleteFileResponse
data DeleteFileResponse = DeleteFileResponse
  { deleteFileResponseId :: !(Text) -- ^ /Required/ "id"
  , deleteFileResponseObject :: !(Text) -- ^ /Required/ "object"
  , deleteFileResponseDeleted :: !(Bool) -- ^ /Required/ "deleted"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON DeleteFileResponse
instance A.FromJSON DeleteFileResponse where
  parseJSON = A.withObject "DeleteFileResponse" $ \o ->
    DeleteFileResponse
      <$> (o .:  "id")
      <*> (o .:  "object")
      <*> (o .:  "deleted")

-- | ToJSON DeleteFileResponse
instance A.ToJSON DeleteFileResponse where
  toJSON DeleteFileResponse {..} =
   _omitNulls
      [ "id" .= deleteFileResponseId
      , "object" .= deleteFileResponseObject
      , "deleted" .= deleteFileResponseDeleted
      ]


-- | Construct a value of type 'DeleteFileResponse' (by applying it's required fields, if any)
mkDeleteFileResponse
  :: Text -- ^ 'deleteFileResponseId' 
  -> Text -- ^ 'deleteFileResponseObject' 
  -> Bool -- ^ 'deleteFileResponseDeleted' 
  -> DeleteFileResponse
mkDeleteFileResponse deleteFileResponseId deleteFileResponseObject deleteFileResponseDeleted =
  DeleteFileResponse
  { deleteFileResponseId
  , deleteFileResponseObject
  , deleteFileResponseDeleted
  }

-- ** DeleteModelResponse
-- | DeleteModelResponse
data DeleteModelResponse = DeleteModelResponse
  { deleteModelResponseId :: !(Text) -- ^ /Required/ "id"
  , deleteModelResponseObject :: !(Text) -- ^ /Required/ "object"
  , deleteModelResponseDeleted :: !(Bool) -- ^ /Required/ "deleted"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON DeleteModelResponse
instance A.FromJSON DeleteModelResponse where
  parseJSON = A.withObject "DeleteModelResponse" $ \o ->
    DeleteModelResponse
      <$> (o .:  "id")
      <*> (o .:  "object")
      <*> (o .:  "deleted")

-- | ToJSON DeleteModelResponse
instance A.ToJSON DeleteModelResponse where
  toJSON DeleteModelResponse {..} =
   _omitNulls
      [ "id" .= deleteModelResponseId
      , "object" .= deleteModelResponseObject
      , "deleted" .= deleteModelResponseDeleted
      ]


-- | Construct a value of type 'DeleteModelResponse' (by applying it's required fields, if any)
mkDeleteModelResponse
  :: Text -- ^ 'deleteModelResponseId' 
  -> Text -- ^ 'deleteModelResponseObject' 
  -> Bool -- ^ 'deleteModelResponseDeleted' 
  -> DeleteModelResponse
mkDeleteModelResponse deleteModelResponseId deleteModelResponseObject deleteModelResponseDeleted =
  DeleteModelResponse
  { deleteModelResponseId
  , deleteModelResponseObject
  , deleteModelResponseDeleted
  }

-- ** Error
-- | Error
data Error = Error
  { errorType :: !(Text) -- ^ /Required/ "type"
  , errorMessage :: !(Text) -- ^ /Required/ "message"
  , errorParam :: !(Text) -- ^ /Required/ "param"
  , errorCode :: !(Text) -- ^ /Required/ "code"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Error
instance A.FromJSON Error where
  parseJSON = A.withObject "Error" $ \o ->
    Error
      <$> (o .:  "type")
      <*> (o .:  "message")
      <*> (o .:  "param")
      <*> (o .:  "code")

-- | ToJSON Error
instance A.ToJSON Error where
  toJSON Error {..} =
   _omitNulls
      [ "type" .= errorType
      , "message" .= errorMessage
      , "param" .= errorParam
      , "code" .= errorCode
      ]


-- | Construct a value of type 'Error' (by applying it's required fields, if any)
mkError
  :: Text -- ^ 'errorType' 
  -> Text -- ^ 'errorMessage' 
  -> Text -- ^ 'errorParam' 
  -> Text -- ^ 'errorCode' 
  -> Error
mkError errorType errorMessage errorParam errorCode =
  Error
  { errorType
  , errorMessage
  , errorParam
  , errorCode
  }

-- ** ErrorResponse
-- | ErrorResponse
data ErrorResponse = ErrorResponse
  { errorResponseError :: !(Error) -- ^ /Required/ "error"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ErrorResponse
instance A.FromJSON ErrorResponse where
  parseJSON = A.withObject "ErrorResponse" $ \o ->
    ErrorResponse
      <$> (o .:  "error")

-- | ToJSON ErrorResponse
instance A.ToJSON ErrorResponse where
  toJSON ErrorResponse {..} =
   _omitNulls
      [ "error" .= errorResponseError
      ]


-- | Construct a value of type 'ErrorResponse' (by applying it's required fields, if any)
mkErrorResponse
  :: Error -- ^ 'errorResponseError' 
  -> ErrorResponse
mkErrorResponse errorResponseError =
  ErrorResponse
  { errorResponseError
  }

-- ** FineTune
-- | FineTune
-- FineTune
-- 
data FineTune = FineTune
  { fineTuneId :: !(Text) -- ^ /Required/ "id"
  , fineTuneObject :: !(Text) -- ^ /Required/ "object"
  , fineTuneCreatedAt :: !(Int) -- ^ /Required/ "created_at"
  , fineTuneUpdatedAt :: !(Int) -- ^ /Required/ "updated_at"
  , fineTuneModel :: !(Text) -- ^ /Required/ "model"
  , fineTuneFineTunedModel :: !(Text) -- ^ /Required/ "fine_tuned_model"
  , fineTuneOrganizationId :: !(Text) -- ^ /Required/ "organization_id"
  , fineTuneStatus :: !(Text) -- ^ /Required/ "status"
  , fineTuneHyperparams :: !(A.Value) -- ^ /Required/ "hyperparams"
  , fineTuneTrainingFiles :: !([OpenAIFile]) -- ^ /Required/ "training_files"
  , fineTuneValidationFiles :: !([OpenAIFile]) -- ^ /Required/ "validation_files"
  , fineTuneResultFiles :: !([OpenAIFile]) -- ^ /Required/ "result_files"
  , fineTuneEvents :: !(Maybe [FineTuneEvent]) -- ^ "events"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON FineTune
instance A.FromJSON FineTune where
  parseJSON = A.withObject "FineTune" $ \o ->
    FineTune
      <$> (o .:  "id")
      <*> (o .:  "object")
      <*> (o .:  "created_at")
      <*> (o .:  "updated_at")
      <*> (o .:  "model")
      <*> (o .:  "fine_tuned_model")
      <*> (o .:  "organization_id")
      <*> (o .:  "status")
      <*> (o .:  "hyperparams")
      <*> (o .:  "training_files")
      <*> (o .:  "validation_files")
      <*> (o .:  "result_files")
      <*> (o .:? "events")

-- | ToJSON FineTune
instance A.ToJSON FineTune where
  toJSON FineTune {..} =
   _omitNulls
      [ "id" .= fineTuneId
      , "object" .= fineTuneObject
      , "created_at" .= fineTuneCreatedAt
      , "updated_at" .= fineTuneUpdatedAt
      , "model" .= fineTuneModel
      , "fine_tuned_model" .= fineTuneFineTunedModel
      , "organization_id" .= fineTuneOrganizationId
      , "status" .= fineTuneStatus
      , "hyperparams" .= fineTuneHyperparams
      , "training_files" .= fineTuneTrainingFiles
      , "validation_files" .= fineTuneValidationFiles
      , "result_files" .= fineTuneResultFiles
      , "events" .= fineTuneEvents
      ]


-- | Construct a value of type 'FineTune' (by applying it's required fields, if any)
mkFineTune
  :: Text -- ^ 'fineTuneId' 
  -> Text -- ^ 'fineTuneObject' 
  -> Int -- ^ 'fineTuneCreatedAt' 
  -> Int -- ^ 'fineTuneUpdatedAt' 
  -> Text -- ^ 'fineTuneModel' 
  -> Text -- ^ 'fineTuneFineTunedModel' 
  -> Text -- ^ 'fineTuneOrganizationId' 
  -> Text -- ^ 'fineTuneStatus' 
  -> A.Value -- ^ 'fineTuneHyperparams' 
  -> [OpenAIFile] -- ^ 'fineTuneTrainingFiles' 
  -> [OpenAIFile] -- ^ 'fineTuneValidationFiles' 
  -> [OpenAIFile] -- ^ 'fineTuneResultFiles' 
  -> FineTune
mkFineTune fineTuneId fineTuneObject fineTuneCreatedAt fineTuneUpdatedAt fineTuneModel fineTuneFineTunedModel fineTuneOrganizationId fineTuneStatus fineTuneHyperparams fineTuneTrainingFiles fineTuneValidationFiles fineTuneResultFiles =
  FineTune
  { fineTuneId
  , fineTuneObject
  , fineTuneCreatedAt
  , fineTuneUpdatedAt
  , fineTuneModel
  , fineTuneFineTunedModel
  , fineTuneOrganizationId
  , fineTuneStatus
  , fineTuneHyperparams
  , fineTuneTrainingFiles
  , fineTuneValidationFiles
  , fineTuneResultFiles
  , fineTuneEvents = Nothing
  }

-- ** FineTuneEvent
-- | FineTuneEvent
-- FineTuneEvent
-- 
data FineTuneEvent = FineTuneEvent
  { fineTuneEventObject :: !(Text) -- ^ /Required/ "object"
  , fineTuneEventCreatedAt :: !(Int) -- ^ /Required/ "created_at"
  , fineTuneEventLevel :: !(Text) -- ^ /Required/ "level"
  , fineTuneEventMessage :: !(Text) -- ^ /Required/ "message"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON FineTuneEvent
instance A.FromJSON FineTuneEvent where
  parseJSON = A.withObject "FineTuneEvent" $ \o ->
    FineTuneEvent
      <$> (o .:  "object")
      <*> (o .:  "created_at")
      <*> (o .:  "level")
      <*> (o .:  "message")

-- | ToJSON FineTuneEvent
instance A.ToJSON FineTuneEvent where
  toJSON FineTuneEvent {..} =
   _omitNulls
      [ "object" .= fineTuneEventObject
      , "created_at" .= fineTuneEventCreatedAt
      , "level" .= fineTuneEventLevel
      , "message" .= fineTuneEventMessage
      ]


-- | Construct a value of type 'FineTuneEvent' (by applying it's required fields, if any)
mkFineTuneEvent
  :: Text -- ^ 'fineTuneEventObject' 
  -> Int -- ^ 'fineTuneEventCreatedAt' 
  -> Text -- ^ 'fineTuneEventLevel' 
  -> Text -- ^ 'fineTuneEventMessage' 
  -> FineTuneEvent
mkFineTuneEvent fineTuneEventObject fineTuneEventCreatedAt fineTuneEventLevel fineTuneEventMessage =
  FineTuneEvent
  { fineTuneEventObject
  , fineTuneEventCreatedAt
  , fineTuneEventLevel
  , fineTuneEventMessage
  }

-- ** ImagesResponse
-- | ImagesResponse
data ImagesResponse = ImagesResponse
  { imagesResponseCreated :: !(Int) -- ^ /Required/ "created"
  , imagesResponseData :: !([ImagesResponseDataInner]) -- ^ /Required/ "data"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ImagesResponse
instance A.FromJSON ImagesResponse where
  parseJSON = A.withObject "ImagesResponse" $ \o ->
    ImagesResponse
      <$> (o .:  "created")
      <*> (o .:  "data")

-- | ToJSON ImagesResponse
instance A.ToJSON ImagesResponse where
  toJSON ImagesResponse {..} =
   _omitNulls
      [ "created" .= imagesResponseCreated
      , "data" .= imagesResponseData
      ]


-- | Construct a value of type 'ImagesResponse' (by applying it's required fields, if any)
mkImagesResponse
  :: Int -- ^ 'imagesResponseCreated' 
  -> [ImagesResponseDataInner] -- ^ 'imagesResponseData' 
  -> ImagesResponse
mkImagesResponse imagesResponseCreated imagesResponseData =
  ImagesResponse
  { imagesResponseCreated
  , imagesResponseData
  }

-- ** ImagesResponseDataInner
-- | ImagesResponseDataInner
data ImagesResponseDataInner = ImagesResponseDataInner
  { imagesResponseDataInnerUrl :: !(Maybe Text) -- ^ "url"
  , imagesResponseDataInnerB64Json :: !(Maybe Text) -- ^ "b64_json"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ImagesResponseDataInner
instance A.FromJSON ImagesResponseDataInner where
  parseJSON = A.withObject "ImagesResponseDataInner" $ \o ->
    ImagesResponseDataInner
      <$> (o .:? "url")
      <*> (o .:? "b64_json")

-- | ToJSON ImagesResponseDataInner
instance A.ToJSON ImagesResponseDataInner where
  toJSON ImagesResponseDataInner {..} =
   _omitNulls
      [ "url" .= imagesResponseDataInnerUrl
      , "b64_json" .= imagesResponseDataInnerB64Json
      ]


-- | Construct a value of type 'ImagesResponseDataInner' (by applying it's required fields, if any)
mkImagesResponseDataInner
  :: ImagesResponseDataInner
mkImagesResponseDataInner =
  ImagesResponseDataInner
  { imagesResponseDataInnerUrl = Nothing
  , imagesResponseDataInnerB64Json = Nothing
  }

-- ** ListFilesResponse
-- | ListFilesResponse
data ListFilesResponse = ListFilesResponse
  { listFilesResponseObject :: !(Text) -- ^ /Required/ "object"
  , listFilesResponseData :: !([OpenAIFile]) -- ^ /Required/ "data"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ListFilesResponse
instance A.FromJSON ListFilesResponse where
  parseJSON = A.withObject "ListFilesResponse" $ \o ->
    ListFilesResponse
      <$> (o .:  "object")
      <*> (o .:  "data")

-- | ToJSON ListFilesResponse
instance A.ToJSON ListFilesResponse where
  toJSON ListFilesResponse {..} =
   _omitNulls
      [ "object" .= listFilesResponseObject
      , "data" .= listFilesResponseData
      ]


-- | Construct a value of type 'ListFilesResponse' (by applying it's required fields, if any)
mkListFilesResponse
  :: Text -- ^ 'listFilesResponseObject' 
  -> [OpenAIFile] -- ^ 'listFilesResponseData' 
  -> ListFilesResponse
mkListFilesResponse listFilesResponseObject listFilesResponseData =
  ListFilesResponse
  { listFilesResponseObject
  , listFilesResponseData
  }

-- ** ListFineTuneEventsResponse
-- | ListFineTuneEventsResponse
data ListFineTuneEventsResponse = ListFineTuneEventsResponse
  { listFineTuneEventsResponseObject :: !(Text) -- ^ /Required/ "object"
  , listFineTuneEventsResponseData :: !([FineTuneEvent]) -- ^ /Required/ "data"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ListFineTuneEventsResponse
instance A.FromJSON ListFineTuneEventsResponse where
  parseJSON = A.withObject "ListFineTuneEventsResponse" $ \o ->
    ListFineTuneEventsResponse
      <$> (o .:  "object")
      <*> (o .:  "data")

-- | ToJSON ListFineTuneEventsResponse
instance A.ToJSON ListFineTuneEventsResponse where
  toJSON ListFineTuneEventsResponse {..} =
   _omitNulls
      [ "object" .= listFineTuneEventsResponseObject
      , "data" .= listFineTuneEventsResponseData
      ]


-- | Construct a value of type 'ListFineTuneEventsResponse' (by applying it's required fields, if any)
mkListFineTuneEventsResponse
  :: Text -- ^ 'listFineTuneEventsResponseObject' 
  -> [FineTuneEvent] -- ^ 'listFineTuneEventsResponseData' 
  -> ListFineTuneEventsResponse
mkListFineTuneEventsResponse listFineTuneEventsResponseObject listFineTuneEventsResponseData =
  ListFineTuneEventsResponse
  { listFineTuneEventsResponseObject
  , listFineTuneEventsResponseData
  }

-- ** ListFineTunesResponse
-- | ListFineTunesResponse
data ListFineTunesResponse = ListFineTunesResponse
  { listFineTunesResponseObject :: !(Text) -- ^ /Required/ "object"
  , listFineTunesResponseData :: !([FineTune]) -- ^ /Required/ "data"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ListFineTunesResponse
instance A.FromJSON ListFineTunesResponse where
  parseJSON = A.withObject "ListFineTunesResponse" $ \o ->
    ListFineTunesResponse
      <$> (o .:  "object")
      <*> (o .:  "data")

-- | ToJSON ListFineTunesResponse
instance A.ToJSON ListFineTunesResponse where
  toJSON ListFineTunesResponse {..} =
   _omitNulls
      [ "object" .= listFineTunesResponseObject
      , "data" .= listFineTunesResponseData
      ]


-- | Construct a value of type 'ListFineTunesResponse' (by applying it's required fields, if any)
mkListFineTunesResponse
  :: Text -- ^ 'listFineTunesResponseObject' 
  -> [FineTune] -- ^ 'listFineTunesResponseData' 
  -> ListFineTunesResponse
mkListFineTunesResponse listFineTunesResponseObject listFineTunesResponseData =
  ListFineTunesResponse
  { listFineTunesResponseObject
  , listFineTunesResponseData
  }

-- ** ListModelsResponse
-- | ListModelsResponse
data ListModelsResponse = ListModelsResponse
  { listModelsResponseObject :: !(Text) -- ^ /Required/ "object"
  , listModelsResponseData :: !([Model]) -- ^ /Required/ "data"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ListModelsResponse
instance A.FromJSON ListModelsResponse where
  parseJSON = A.withObject "ListModelsResponse" $ \o ->
    ListModelsResponse
      <$> (o .:  "object")
      <*> (o .:  "data")

-- | ToJSON ListModelsResponse
instance A.ToJSON ListModelsResponse where
  toJSON ListModelsResponse {..} =
   _omitNulls
      [ "object" .= listModelsResponseObject
      , "data" .= listModelsResponseData
      ]


-- | Construct a value of type 'ListModelsResponse' (by applying it's required fields, if any)
mkListModelsResponse
  :: Text -- ^ 'listModelsResponseObject' 
  -> [Model] -- ^ 'listModelsResponseData' 
  -> ListModelsResponse
mkListModelsResponse listModelsResponseObject listModelsResponseData =
  ListModelsResponse
  { listModelsResponseObject
  , listModelsResponseData
  }

-- ** Model
-- | Model
-- Model
-- 
data Model = Model
  { modelId :: !(Text) -- ^ /Required/ "id"
  , modelObject :: !(Text) -- ^ /Required/ "object"
  , modelCreated :: !(Int) -- ^ /Required/ "created"
  , modelOwnedBy :: !(Text) -- ^ /Required/ "owned_by"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Model
instance A.FromJSON Model where
  parseJSON = A.withObject "Model" $ \o ->
    Model
      <$> (o .:  "id")
      <*> (o .:  "object")
      <*> (o .:  "created")
      <*> (o .:  "owned_by")

-- | ToJSON Model
instance A.ToJSON Model where
  toJSON Model {..} =
   _omitNulls
      [ "id" .= modelId
      , "object" .= modelObject
      , "created" .= modelCreated
      , "owned_by" .= modelOwnedBy
      ]


-- | Construct a value of type 'Model' (by applying it's required fields, if any)
mkModel
  :: Text -- ^ 'modelId' 
  -> Text -- ^ 'modelObject' 
  -> Int -- ^ 'modelCreated' 
  -> Text -- ^ 'modelOwnedBy' 
  -> Model
mkModel modelId modelObject modelCreated modelOwnedBy =
  Model
  { modelId
  , modelObject
  , modelCreated
  , modelOwnedBy
  }

-- ** OpenAIFile
-- | OpenAIFile
-- OpenAIFile
-- 
data OpenAIFile = OpenAIFile
  { openAIFileId :: !(Text) -- ^ /Required/ "id"
  , openAIFileObject :: !(Text) -- ^ /Required/ "object"
  , openAIFileBytes :: !(Int) -- ^ /Required/ "bytes"
  , openAIFileCreatedAt :: !(Int) -- ^ /Required/ "created_at"
  , openAIFileFilename :: !(Text) -- ^ /Required/ "filename"
  , openAIFilePurpose :: !(Text) -- ^ /Required/ "purpose"
  , openAIFileStatus :: !(Maybe Text) -- ^ "status"
  , openAIFileStatusDetails :: !(Maybe A.Value) -- ^ "status_details"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OpenAIFile
instance A.FromJSON OpenAIFile where
  parseJSON = A.withObject "OpenAIFile" $ \o ->
    OpenAIFile
      <$> (o .:  "id")
      <*> (o .:  "object")
      <*> (o .:  "bytes")
      <*> (o .:  "created_at")
      <*> (o .:  "filename")
      <*> (o .:  "purpose")
      <*> (o .:? "status")
      <*> (o .:? "status_details")

-- | ToJSON OpenAIFile
instance A.ToJSON OpenAIFile where
  toJSON OpenAIFile {..} =
   _omitNulls
      [ "id" .= openAIFileId
      , "object" .= openAIFileObject
      , "bytes" .= openAIFileBytes
      , "created_at" .= openAIFileCreatedAt
      , "filename" .= openAIFileFilename
      , "purpose" .= openAIFilePurpose
      , "status" .= openAIFileStatus
      , "status_details" .= openAIFileStatusDetails
      ]


-- | Construct a value of type 'OpenAIFile' (by applying it's required fields, if any)
mkOpenAIFile
  :: Text -- ^ 'openAIFileId' 
  -> Text -- ^ 'openAIFileObject' 
  -> Int -- ^ 'openAIFileBytes' 
  -> Int -- ^ 'openAIFileCreatedAt' 
  -> Text -- ^ 'openAIFileFilename' 
  -> Text -- ^ 'openAIFilePurpose' 
  -> OpenAIFile
mkOpenAIFile openAIFileId openAIFileObject openAIFileBytes openAIFileCreatedAt openAIFileFilename openAIFilePurpose =
  OpenAIFile
  { openAIFileId
  , openAIFileObject
  , openAIFileBytes
  , openAIFileCreatedAt
  , openAIFileFilename
  , openAIFilePurpose
  , openAIFileStatus = Nothing
  , openAIFileStatusDetails = Nothing
  }


-- * Enums


-- ** E'AnyOf1

-- | Enum of 'Text'
data E'AnyOf1
  = E'AnyOf1'Text_davinci_003 -- ^ @"text-davinci-003"@
  | E'AnyOf1'Text_davinci_002 -- ^ @"text-davinci-002"@
  | E'AnyOf1'Text_davinci_001 -- ^ @"text-davinci-001"@
  | E'AnyOf1'Code_davinci_002 -- ^ @"code-davinci-002"@
  | E'AnyOf1'Text_curie_001 -- ^ @"text-curie-001"@
  | E'AnyOf1'Text_babbage_001 -- ^ @"text-babbage-001"@
  | E'AnyOf1'Text_ada_001 -- ^ @"text-ada-001"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'AnyOf1 where toJSON = A.toJSON . fromE'AnyOf1
instance A.FromJSON E'AnyOf1 where parseJSON o = P.either P.fail (pure . P.id) . toE'AnyOf1 =<< A.parseJSON o
instance WH.ToHttpApiData E'AnyOf1 where toQueryParam = WH.toQueryParam . fromE'AnyOf1
instance WH.FromHttpApiData E'AnyOf1 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'AnyOf1
instance MimeRender MimeMultipartFormData E'AnyOf1 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'AnyOf1' enum
fromE'AnyOf1 :: E'AnyOf1 -> Text
fromE'AnyOf1 = \case
  E'AnyOf1'Text_davinci_003 -> "text-davinci-003"
  E'AnyOf1'Text_davinci_002 -> "text-davinci-002"
  E'AnyOf1'Text_davinci_001 -> "text-davinci-001"
  E'AnyOf1'Code_davinci_002 -> "code-davinci-002"
  E'AnyOf1'Text_curie_001 -> "text-curie-001"
  E'AnyOf1'Text_babbage_001 -> "text-babbage-001"
  E'AnyOf1'Text_ada_001 -> "text-ada-001"

-- | parse 'E'AnyOf1' enum
toE'AnyOf1 :: Text -> P.Either String E'AnyOf1
toE'AnyOf1 = \case
  "text-davinci-003" -> P.Right E'AnyOf1'Text_davinci_003
  "text-davinci-002" -> P.Right E'AnyOf1'Text_davinci_002
  "text-davinci-001" -> P.Right E'AnyOf1'Text_davinci_001
  "code-davinci-002" -> P.Right E'AnyOf1'Code_davinci_002
  "text-curie-001" -> P.Right E'AnyOf1'Text_curie_001
  "text-babbage-001" -> P.Right E'AnyOf1'Text_babbage_001
  "text-ada-001" -> P.Right E'AnyOf1'Text_ada_001
  s -> P.Left $ "toE'AnyOf1: enum parse failure: " P.++ P.show s


-- ** E'AnyOf2

-- | Enum of 'Text'
data E'AnyOf2
  = E'AnyOf2'4 -- ^ @"gpt-4"@
  | E'AnyOf2'4_0314 -- ^ @"gpt-4-0314"@
  | E'AnyOf2'4_0613 -- ^ @"gpt-4-0613"@
  | E'AnyOf2'4_32k -- ^ @"gpt-4-32k"@
  | E'AnyOf2'4_32k_0314 -- ^ @"gpt-4-32k-0314"@
  | E'AnyOf2'4_32k_0613 -- ^ @"gpt-4-32k-0613"@
  | E'AnyOf2'3_5_turbo -- ^ @"gpt-3.5-turbo"@
  | E'AnyOf2'3_5_turbo_16k -- ^ @"gpt-3.5-turbo-16k"@
  | E'AnyOf2'3_5_turbo_0301 -- ^ @"gpt-3.5-turbo-0301"@
  | E'AnyOf2'3_5_turbo_0613 -- ^ @"gpt-3.5-turbo-0613"@
  | E'AnyOf2'3_5_turbo_16k_0613 -- ^ @"gpt-3.5-turbo-16k-0613"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'AnyOf2 where toJSON = A.toJSON . fromE'AnyOf2
instance A.FromJSON E'AnyOf2 where parseJSON o = P.either P.fail (pure . P.id) . toE'AnyOf2 =<< A.parseJSON o
instance WH.ToHttpApiData E'AnyOf2 where toQueryParam = WH.toQueryParam . fromE'AnyOf2
instance WH.FromHttpApiData E'AnyOf2 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'AnyOf2
instance MimeRender MimeMultipartFormData E'AnyOf2 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'AnyOf2' enum
fromE'AnyOf2 :: E'AnyOf2 -> Text
fromE'AnyOf2 = \case
  E'AnyOf2'4 -> "gpt-4"
  E'AnyOf2'4_0314 -> "gpt-4-0314"
  E'AnyOf2'4_0613 -> "gpt-4-0613"
  E'AnyOf2'4_32k -> "gpt-4-32k"
  E'AnyOf2'4_32k_0314 -> "gpt-4-32k-0314"
  E'AnyOf2'4_32k_0613 -> "gpt-4-32k-0613"
  E'AnyOf2'3_5_turbo -> "gpt-3.5-turbo"
  E'AnyOf2'3_5_turbo_16k -> "gpt-3.5-turbo-16k"
  E'AnyOf2'3_5_turbo_0301 -> "gpt-3.5-turbo-0301"
  E'AnyOf2'3_5_turbo_0613 -> "gpt-3.5-turbo-0613"
  E'AnyOf2'3_5_turbo_16k_0613 -> "gpt-3.5-turbo-16k-0613"

-- | parse 'E'AnyOf2' enum
toE'AnyOf2 :: Text -> P.Either String E'AnyOf2
toE'AnyOf2 = \case
  "gpt-4" -> P.Right E'AnyOf2'4
  "gpt-4-0314" -> P.Right E'AnyOf2'4_0314
  "gpt-4-0613" -> P.Right E'AnyOf2'4_0613
  "gpt-4-32k" -> P.Right E'AnyOf2'4_32k
  "gpt-4-32k-0314" -> P.Right E'AnyOf2'4_32k_0314
  "gpt-4-32k-0613" -> P.Right E'AnyOf2'4_32k_0613
  "gpt-3.5-turbo" -> P.Right E'AnyOf2'3_5_turbo
  "gpt-3.5-turbo-16k" -> P.Right E'AnyOf2'3_5_turbo_16k
  "gpt-3.5-turbo-0301" -> P.Right E'AnyOf2'3_5_turbo_0301
  "gpt-3.5-turbo-0613" -> P.Right E'AnyOf2'3_5_turbo_0613
  "gpt-3.5-turbo-16k-0613" -> P.Right E'AnyOf2'3_5_turbo_16k_0613
  s -> P.Left $ "toE'AnyOf2: enum parse failure: " P.++ P.show s


-- ** E'AnyOf3

-- | Enum of 'Text'
data E'AnyOf3
  = E'AnyOf3'Text_davinci_edit_001 -- ^ @"text-davinci-edit-001"@
  | E'AnyOf3'Code_davinci_edit_001 -- ^ @"code-davinci-edit-001"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'AnyOf3 where toJSON = A.toJSON . fromE'AnyOf3
instance A.FromJSON E'AnyOf3 where parseJSON o = P.either P.fail (pure . P.id) . toE'AnyOf3 =<< A.parseJSON o
instance WH.ToHttpApiData E'AnyOf3 where toQueryParam = WH.toQueryParam . fromE'AnyOf3
instance WH.FromHttpApiData E'AnyOf3 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'AnyOf3
instance MimeRender MimeMultipartFormData E'AnyOf3 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'AnyOf3' enum
fromE'AnyOf3 :: E'AnyOf3 -> Text
fromE'AnyOf3 = \case
  E'AnyOf3'Text_davinci_edit_001 -> "text-davinci-edit-001"
  E'AnyOf3'Code_davinci_edit_001 -> "code-davinci-edit-001"

-- | parse 'E'AnyOf3' enum
toE'AnyOf3 :: Text -> P.Either String E'AnyOf3
toE'AnyOf3 = \case
  "text-davinci-edit-001" -> P.Right E'AnyOf3'Text_davinci_edit_001
  "code-davinci-edit-001" -> P.Right E'AnyOf3'Code_davinci_edit_001
  s -> P.Left $ "toE'AnyOf3: enum parse failure: " P.++ P.show s


-- ** E'AnyOf4

-- | Enum of 'Text'
data E'AnyOf4
  = E'AnyOf4'Latest -- ^ @"text-moderation-latest"@
  | E'AnyOf4'Stable -- ^ @"text-moderation-stable"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'AnyOf4 where toJSON = A.toJSON . fromE'AnyOf4
instance A.FromJSON E'AnyOf4 where parseJSON o = P.either P.fail (pure . P.id) . toE'AnyOf4 =<< A.parseJSON o
instance WH.ToHttpApiData E'AnyOf4 where toQueryParam = WH.toQueryParam . fromE'AnyOf4
instance WH.FromHttpApiData E'AnyOf4 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'AnyOf4
instance MimeRender MimeMultipartFormData E'AnyOf4 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'AnyOf4' enum
fromE'AnyOf4 :: E'AnyOf4 -> Text
fromE'AnyOf4 = \case
  E'AnyOf4'Latest -> "text-moderation-latest"
  E'AnyOf4'Stable -> "text-moderation-stable"

-- | parse 'E'AnyOf4' enum
toE'AnyOf4 :: Text -> P.Either String E'AnyOf4
toE'AnyOf4 = \case
  "text-moderation-latest" -> P.Right E'AnyOf4'Latest
  "text-moderation-stable" -> P.Right E'AnyOf4'Stable
  s -> P.Left $ "toE'AnyOf4: enum parse failure: " P.++ P.show s


-- ** E'AnyOf5

-- | Enum of 'Text'
data E'AnyOf5
  = E'AnyOf5'Ada -- ^ @"ada"@
  | E'AnyOf5'Babbage -- ^ @"babbage"@
  | E'AnyOf5'Curie -- ^ @"curie"@
  | E'AnyOf5'Davinci -- ^ @"davinci"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'AnyOf5 where toJSON = A.toJSON . fromE'AnyOf5
instance A.FromJSON E'AnyOf5 where parseJSON o = P.either P.fail (pure . P.id) . toE'AnyOf5 =<< A.parseJSON o
instance WH.ToHttpApiData E'AnyOf5 where toQueryParam = WH.toQueryParam . fromE'AnyOf5
instance WH.FromHttpApiData E'AnyOf5 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'AnyOf5
instance MimeRender MimeMultipartFormData E'AnyOf5 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'AnyOf5' enum
fromE'AnyOf5 :: E'AnyOf5 -> Text
fromE'AnyOf5 = \case
  E'AnyOf5'Ada -> "ada"
  E'AnyOf5'Babbage -> "babbage"
  E'AnyOf5'Curie -> "curie"
  E'AnyOf5'Davinci -> "davinci"

-- | parse 'E'AnyOf5' enum
toE'AnyOf5 :: Text -> P.Either String E'AnyOf5
toE'AnyOf5 = \case
  "ada" -> P.Right E'AnyOf5'Ada
  "babbage" -> P.Right E'AnyOf5'Babbage
  "curie" -> P.Right E'AnyOf5'Curie
  "davinci" -> P.Right E'AnyOf5'Davinci
  s -> P.Left $ "toE'AnyOf5: enum parse failure: " P.++ P.show s


-- ** E'AnyOf6

-- | Enum of 'Text'
data E'AnyOf6
  = E'AnyOf6'Text_embedding_ada_002 -- ^ @"text-embedding-ada-002"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'AnyOf6 where toJSON = A.toJSON . fromE'AnyOf6
instance A.FromJSON E'AnyOf6 where parseJSON o = P.either P.fail (pure . P.id) . toE'AnyOf6 =<< A.parseJSON o
instance WH.ToHttpApiData E'AnyOf6 where toQueryParam = WH.toQueryParam . fromE'AnyOf6
instance WH.FromHttpApiData E'AnyOf6 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'AnyOf6
instance MimeRender MimeMultipartFormData E'AnyOf6 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'AnyOf6' enum
fromE'AnyOf6 :: E'AnyOf6 -> Text
fromE'AnyOf6 = \case
  E'AnyOf6'Text_embedding_ada_002 -> "text-embedding-ada-002"

-- | parse 'E'AnyOf6' enum
toE'AnyOf6 :: Text -> P.Either String E'AnyOf6
toE'AnyOf6 = \case
  "text-embedding-ada-002" -> P.Right E'AnyOf6'Text_embedding_ada_002
  s -> P.Left $ "toE'AnyOf6: enum parse failure: " P.++ P.show s


-- ** E'FinishReason

-- | Enum of 'Text'
data E'FinishReason
  = E'FinishReason'Stop -- ^ @"stop"@
  | E'FinishReason'Length -- ^ @"length"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'FinishReason where toJSON = A.toJSON . fromE'FinishReason
instance A.FromJSON E'FinishReason where parseJSON o = P.either P.fail (pure . P.id) . toE'FinishReason =<< A.parseJSON o
instance WH.ToHttpApiData E'FinishReason where toQueryParam = WH.toQueryParam . fromE'FinishReason
instance WH.FromHttpApiData E'FinishReason where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'FinishReason
instance MimeRender MimeMultipartFormData E'FinishReason where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'FinishReason' enum
fromE'FinishReason :: E'FinishReason -> Text
fromE'FinishReason = \case
  E'FinishReason'Stop -> "stop"
  E'FinishReason'Length -> "length"

-- | parse 'E'FinishReason' enum
toE'FinishReason :: Text -> P.Either String E'FinishReason
toE'FinishReason = \case
  "stop" -> P.Right E'FinishReason'Stop
  "length" -> P.Right E'FinishReason'Length
  s -> P.Left $ "toE'FinishReason: enum parse failure: " P.++ P.show s


-- ** E'FinishReason2

-- | Enum of 'Text'
data E'FinishReason2
  = E'FinishReason2'Stop -- ^ @"stop"@
  | E'FinishReason2'Length -- ^ @"length"@
  | E'FinishReason2'Function_call -- ^ @"function_call"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'FinishReason2 where toJSON = A.toJSON . fromE'FinishReason2
instance A.FromJSON E'FinishReason2 where parseJSON o = P.either P.fail (pure . P.id) . toE'FinishReason2 =<< A.parseJSON o
instance WH.ToHttpApiData E'FinishReason2 where toQueryParam = WH.toQueryParam . fromE'FinishReason2
instance WH.FromHttpApiData E'FinishReason2 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'FinishReason2
instance MimeRender MimeMultipartFormData E'FinishReason2 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'FinishReason2' enum
fromE'FinishReason2 :: E'FinishReason2 -> Text
fromE'FinishReason2 = \case
  E'FinishReason2'Stop -> "stop"
  E'FinishReason2'Length -> "length"
  E'FinishReason2'Function_call -> "function_call"

-- | parse 'E'FinishReason2' enum
toE'FinishReason2 :: Text -> P.Either String E'FinishReason2
toE'FinishReason2 = \case
  "stop" -> P.Right E'FinishReason2'Stop
  "length" -> P.Right E'FinishReason2'Length
  "function_call" -> P.Right E'FinishReason2'Function_call
  s -> P.Left $ "toE'FinishReason2: enum parse failure: " P.++ P.show s


-- ** E'OneOf0

-- | Enum of 'Text'
data E'OneOf0
  = E'OneOf0'None -- ^ @"none"@
  | E'OneOf0'Auto -- ^ @"auto"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'OneOf0 where toJSON = A.toJSON . fromE'OneOf0
instance A.FromJSON E'OneOf0 where parseJSON o = P.either P.fail (pure . P.id) . toE'OneOf0 =<< A.parseJSON o
instance WH.ToHttpApiData E'OneOf0 where toQueryParam = WH.toQueryParam . fromE'OneOf0
instance WH.FromHttpApiData E'OneOf0 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'OneOf0
instance MimeRender MimeMultipartFormData E'OneOf0 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'OneOf0' enum
fromE'OneOf0 :: E'OneOf0 -> Text
fromE'OneOf0 = \case
  E'OneOf0'None -> "none"
  E'OneOf0'Auto -> "auto"

-- | parse 'E'OneOf0' enum
toE'OneOf0 :: Text -> P.Either String E'OneOf0
toE'OneOf0 = \case
  "none" -> P.Right E'OneOf0'None
  "auto" -> P.Right E'OneOf0'Auto
  s -> P.Left $ "toE'OneOf0: enum parse failure: " P.++ P.show s


-- ** E'ResponseFormat

-- | Enum of 'Text' .
-- The format in which the generated images are returned. Must be one of `url` or `b64_json`.
data E'ResponseFormat
  = E'ResponseFormat'Url -- ^ @"url"@
  | E'ResponseFormat'B64_json -- ^ @"b64_json"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'ResponseFormat where toJSON = A.toJSON . fromE'ResponseFormat
instance A.FromJSON E'ResponseFormat where parseJSON o = P.either P.fail (pure . P.id) . toE'ResponseFormat =<< A.parseJSON o
instance WH.ToHttpApiData E'ResponseFormat where toQueryParam = WH.toQueryParam . fromE'ResponseFormat
instance WH.FromHttpApiData E'ResponseFormat where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'ResponseFormat
instance MimeRender MimeMultipartFormData E'ResponseFormat where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'ResponseFormat' enum
fromE'ResponseFormat :: E'ResponseFormat -> Text
fromE'ResponseFormat = \case
  E'ResponseFormat'Url -> "url"
  E'ResponseFormat'B64_json -> "b64_json"

-- | parse 'E'ResponseFormat' enum
toE'ResponseFormat :: Text -> P.Either String E'ResponseFormat
toE'ResponseFormat = \case
  "url" -> P.Right E'ResponseFormat'Url
  "b64_json" -> P.Right E'ResponseFormat'B64_json
  s -> P.Left $ "toE'ResponseFormat: enum parse failure: " P.++ P.show s


-- ** E'Role

-- | Enum of 'Text' .
-- The role of the messages author. One of `system`, `user`, `assistant`, or `function`.
data E'Role
  = E'Role'System -- ^ @"system"@
  | E'Role'User -- ^ @"user"@
  | E'Role'Assistant -- ^ @"assistant"@
  | E'Role'Function -- ^ @"function"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Role where toJSON = A.toJSON . fromE'Role
instance A.FromJSON E'Role where parseJSON o = P.either P.fail (pure . P.id) . toE'Role =<< A.parseJSON o
instance WH.ToHttpApiData E'Role where toQueryParam = WH.toQueryParam . fromE'Role
instance WH.FromHttpApiData E'Role where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Role
instance MimeRender MimeMultipartFormData E'Role where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Role' enum
fromE'Role :: E'Role -> Text
fromE'Role = \case
  E'Role'System -> "system"
  E'Role'User -> "user"
  E'Role'Assistant -> "assistant"
  E'Role'Function -> "function"

-- | parse 'E'Role' enum
toE'Role :: Text -> P.Either String E'Role
toE'Role = \case
  "system" -> P.Right E'Role'System
  "user" -> P.Right E'Role'User
  "assistant" -> P.Right E'Role'Assistant
  "function" -> P.Right E'Role'Function
  s -> P.Left $ "toE'Role: enum parse failure: " P.++ P.show s


-- ** E'Size

-- | Enum of 'Text' .
-- The size of the generated images. Must be one of `256x256`, `512x512`, or `1024x1024`.
data E'Size
  = E'Size'256x256 -- ^ @"256x256"@
  | E'Size'512x512 -- ^ @"512x512"@
  | E'Size'1024x1024 -- ^ @"1024x1024"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Size where toJSON = A.toJSON . fromE'Size
instance A.FromJSON E'Size where parseJSON o = P.either P.fail (pure . P.id) . toE'Size =<< A.parseJSON o
instance WH.ToHttpApiData E'Size where toQueryParam = WH.toQueryParam . fromE'Size
instance WH.FromHttpApiData E'Size where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Size
instance MimeRender MimeMultipartFormData E'Size where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Size' enum
fromE'Size :: E'Size -> Text
fromE'Size = \case
  E'Size'256x256 -> "256x256"
  E'Size'512x512 -> "512x512"
  E'Size'1024x1024 -> "1024x1024"

-- | parse 'E'Size' enum
toE'Size :: Text -> P.Either String E'Size
toE'Size = \case
  "256x256" -> P.Right E'Size'256x256
  "512x512" -> P.Right E'Size'512x512
  "1024x1024" -> P.Right E'Size'1024x1024
  s -> P.Left $ "toE'Size: enum parse failure: " P.++ P.show s



