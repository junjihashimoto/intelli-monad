{-
   OpenAI API

   The OpenAI REST API. Please see https://platform.openai.com/docs/api-reference for more details.

   OpenAPI Version: 3.0.0
   OpenAI API API version: 2.0.0
   Generated by OpenAPI Generator (https://openapi-generator.tech)
-}

{-|
Module : OpenAI.Model
-}

{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE DeriveFoldable #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE DeriveTraversable #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE NamedFieldPuns #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RecordWildCards #-}
{-# LANGUAGE TupleSections #-}
{-# LANGUAGE TypeFamilies #-}
{-# OPTIONS_GHC -fno-warn-unused-matches -fno-warn-unused-binds -fno-warn-unused-imports #-}

module OpenAI.Model where

import OpenAI.Core
import OpenAI.MimeTypes

import Data.Aeson ((.:),(.:!),(.:?),(.=))

import qualified Control.Arrow as P (left)
import qualified Data.Aeson as A
import qualified Data.ByteString as B
import qualified Data.ByteString.Base64 as B64
import qualified Data.ByteString.Char8 as BC
import qualified Data.ByteString.Lazy as BL
import qualified Data.Data as P (Typeable, TypeRep, typeOf, typeRep)
import qualified Data.Foldable as P
import qualified Data.HashMap.Lazy as HM
import qualified Data.Map as Map
import qualified Data.Maybe as P
import qualified Data.Set as Set
import qualified Data.Text as T
import qualified Data.Text.Encoding as T
import qualified Data.Time as TI
import qualified Lens.Micro as L
import qualified Web.FormUrlEncoded as WH
import qualified Web.HttpApiData as WH

import Control.Applicative ((<|>))
import Control.Applicative (Alternative)
import Data.Function ((&))
import Data.Monoid ((<>))
import Data.Text (Text)
import Prelude (($),(/=),(.),(<$>),(<*>),(>>=),(=<<),Maybe(..),Bool(..),Char,Double,FilePath,Float,Int,Integer,String,fmap,undefined,mempty,maybe,pure,Monad,Applicative,Functor)

import qualified Prelude as P



-- * Parameter newtypes


-- ** After
newtype After = After { unAfter :: Text } deriving (P.Eq, P.Show)

-- ** AssistantId
newtype AssistantId = AssistantId { unAssistantId :: Text } deriving (P.Eq, P.Show)

-- ** Before
newtype Before = Before { unBefore :: Text } deriving (P.Eq, P.Show)

-- ** File
newtype File = File { unFile :: FilePath } deriving (P.Eq, P.Show)

-- ** FileId
newtype FileId = FileId { unFileId :: Text } deriving (P.Eq, P.Show)

-- ** FineTuningJobId
newtype FineTuningJobId = FineTuningJobId { unFineTuningJobId :: Text } deriving (P.Eq, P.Show)

-- ** Image2
newtype Image2 = Image2 { unImage2 :: FilePath } deriving (P.Eq, P.Show)

-- ** Language
newtype Language = Language { unLanguage :: Text } deriving (P.Eq, P.Show)

-- ** Limit
newtype Limit = Limit { unLimit :: Int } deriving (P.Eq, P.Show)

-- ** Mask
newtype Mask = Mask { unMask :: FilePath } deriving (P.Eq, P.Show)

-- ** MessageId
newtype MessageId = MessageId { unMessageId :: Text } deriving (P.Eq, P.Show)

-- ** Model2
-- newtype Model2 = Model2 { unModel2 :: CreateImageEditRequestModel } deriving (P.Eq, P.Show)

-- ** Model3
newtype Model3 = Model3 { unModel3 :: String } deriving (P.Eq, P.Show)

-- ** Model4
newtype Model4 = Model4 { unModel4 :: Text } deriving (P.Eq, P.Show)

-- ** N
newtype N = N { unN :: Int } deriving (P.Eq, P.Show)

-- ** Order
newtype Order = Order { unOrder :: E'Order } deriving (P.Eq, P.Show)

-- ** Prompt
newtype Prompt = Prompt { unPrompt :: Text } deriving (P.Eq, P.Show)

-- ** Purpose
newtype Purpose = Purpose { unPurpose :: Text } deriving (P.Eq, P.Show)

-- ** Purpose2
newtype Purpose2 = Purpose2 { unPurpose2 :: E'Purpose2 } deriving (P.Eq, P.Show)

-- ** ResponseFormat
newtype ResponseFormat = ResponseFormat { unResponseFormat :: E'ResponseFormat } deriving (P.Eq, P.Show)

-- ** ResponseFormat2
newtype ResponseFormat2 = ResponseFormat2 { unResponseFormat2 :: E'ResponseFormat3 } deriving (P.Eq, P.Show)

-- ** ResponseFormatText
newtype ResponseFormatText = ResponseFormatText { unResponseFormatText :: Text } deriving (P.Eq, P.Show)

-- ** RunId
newtype RunId = RunId { unRunId :: Text } deriving (P.Eq, P.Show)

-- ** Size
newtype Size = Size { unSize :: E'Size2 } deriving (P.Eq, P.Show)

-- ** StepId
newtype StepId = StepId { unStepId :: Text } deriving (P.Eq, P.Show)

-- ** Temperature
newtype Temperature = Temperature { unTemperature :: Double } deriving (P.Eq, P.Show)

-- ** ThreadId
newtype ThreadId = ThreadId { unThreadId :: Text } deriving (P.Eq, P.Show)

-- ** TimestampGranularities
newtype TimestampGranularities = TimestampGranularities { unTimestampGranularities :: [E'TimestampGranularities] } deriving (P.Eq, P.Show)

-- ** User
newtype User = User { unUser :: Text } deriving (P.Eq, P.Show)

-- * Models


-- ** AssistantFileObject
-- | AssistantFileObject
-- Assistant files
-- 
-- A list of [Files](/docs/api-reference/files) attached to an `assistant`.
data AssistantFileObject = AssistantFileObject
  { assistantFileObjectId :: !(Text) -- ^ /Required/ "id" - The identifier, which can be referenced in API endpoints.
  , assistantFileObjectObject :: !(E'Object17) -- ^ /Required/ "object" - The object type, which is always &#x60;assistant.file&#x60;.
  , assistantFileObjectCreatedAt :: !(Int) -- ^ /Required/ "created_at" - The Unix timestamp (in seconds) for when the assistant file was created.
  , assistantFileObjectAssistantId :: !(Text) -- ^ /Required/ "assistant_id" - The assistant ID that the file is attached to.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AssistantFileObject
instance A.FromJSON AssistantFileObject where
  parseJSON = A.withObject "AssistantFileObject" $ \o ->
    AssistantFileObject
      <$> (o .:  "id")
      <*> (o .:  "object")
      <*> (o .:  "created_at")
      <*> (o .:  "assistant_id")

-- | ToJSON AssistantFileObject
instance A.ToJSON AssistantFileObject where
  toJSON AssistantFileObject {..} =
   _omitNulls
      [ "id" .= assistantFileObjectId
      , "object" .= assistantFileObjectObject
      , "created_at" .= assistantFileObjectCreatedAt
      , "assistant_id" .= assistantFileObjectAssistantId
      ]


-- | Construct a value of type 'AssistantFileObject' (by applying it's required fields, if any)
mkAssistantFileObject
  :: Text -- ^ 'assistantFileObjectId': The identifier, which can be referenced in API endpoints.
  -> E'Object17 -- ^ 'assistantFileObjectObject': The object type, which is always `assistant.file`.
  -> Int -- ^ 'assistantFileObjectCreatedAt': The Unix timestamp (in seconds) for when the assistant file was created.
  -> Text -- ^ 'assistantFileObjectAssistantId': The assistant ID that the file is attached to.
  -> AssistantFileObject
mkAssistantFileObject assistantFileObjectId assistantFileObjectObject assistantFileObjectCreatedAt assistantFileObjectAssistantId =
  AssistantFileObject
  { assistantFileObjectId
  , assistantFileObjectObject
  , assistantFileObjectCreatedAt
  , assistantFileObjectAssistantId
  }

-- ** AssistantObject
-- | AssistantObject
-- Assistant
-- 
-- Represents an `assistant` that can call the model and use tools.
data AssistantObject = AssistantObject
  { assistantObjectId :: !(Text) -- ^ /Required/ "id" - The identifier, which can be referenced in API endpoints.
  , assistantObjectObject :: !(E'Role4) -- ^ /Required/ "object" - The object type, which is always &#x60;assistant&#x60;.
  , assistantObjectCreatedAt :: !(Int) -- ^ /Required/ "created_at" - The Unix timestamp (in seconds) for when the assistant was created.
  , assistantObjectName :: !(Text) -- ^ /Required/ "name" - The name of the assistant. The maximum length is 256 characters. 
  , assistantObjectDescription :: !(Text) -- ^ /Required/ "description" - The description of the assistant. The maximum length is 512 characters. 
  , assistantObjectModel :: !(Text) -- ^ /Required/ "model" - ID of the model to use. You can use the [List models](/docs/api-reference/models/list) API to see all of your available models, or see our [Model overview](/docs/models/overview) for descriptions of them. 
  , assistantObjectInstructions :: !(Text) -- ^ /Required/ "instructions" - The system instructions that the assistant uses. The maximum length is 32768 characters. 
  , assistantObjectTools :: !([AssistantObjectToolsInner]) -- ^ /Required/ "tools" - A list of tool enabled on the assistant. There can be a maximum of 128 tools per assistant. Tools can be of types &#x60;code_interpreter&#x60;, &#x60;retrieval&#x60;, or &#x60;function&#x60;. 
  , assistantObjectFileIds :: !([Text]) -- ^ /Required/ "file_ids" - A list of [file](/docs/api-reference/files) IDs attached to this assistant. There can be a maximum of 20 files attached to the assistant. Files are ordered by their creation date in ascending order. 
  , assistantObjectMetadata :: !(A.Value) -- ^ /Required/ "metadata" - Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AssistantObject
instance A.FromJSON AssistantObject where
  parseJSON = A.withObject "AssistantObject" $ \o ->
    AssistantObject
      <$> (o .:  "id")
      <*> (o .:  "object")
      <*> (o .:  "created_at")
      <*> (o .:  "name")
      <*> (o .:  "description")
      <*> (o .:  "model")
      <*> (o .:  "instructions")
      <*> (o .:  "tools")
      <*> (o .:  "file_ids")
      <*> (o .:  "metadata")

-- | ToJSON AssistantObject
instance A.ToJSON AssistantObject where
  toJSON AssistantObject {..} =
   _omitNulls
      [ "id" .= assistantObjectId
      , "object" .= assistantObjectObject
      , "created_at" .= assistantObjectCreatedAt
      , "name" .= assistantObjectName
      , "description" .= assistantObjectDescription
      , "model" .= assistantObjectModel
      , "instructions" .= assistantObjectInstructions
      , "tools" .= assistantObjectTools
      , "file_ids" .= assistantObjectFileIds
      , "metadata" .= assistantObjectMetadata
      ]


-- | Construct a value of type 'AssistantObject' (by applying it's required fields, if any)
mkAssistantObject
  :: Text -- ^ 'assistantObjectId': The identifier, which can be referenced in API endpoints.
  -> E'Role4 -- ^ 'assistantObjectObject': The object type, which is always `assistant`.
  -> Int -- ^ 'assistantObjectCreatedAt': The Unix timestamp (in seconds) for when the assistant was created.
  -> Text -- ^ 'assistantObjectName': The name of the assistant. The maximum length is 256 characters. 
  -> Text -- ^ 'assistantObjectDescription': The description of the assistant. The maximum length is 512 characters. 
  -> Text -- ^ 'assistantObjectModel': ID of the model to use. You can use the [List models](/docs/api-reference/models/list) API to see all of your available models, or see our [Model overview](/docs/models/overview) for descriptions of them. 
  -> Text -- ^ 'assistantObjectInstructions': The system instructions that the assistant uses. The maximum length is 32768 characters. 
  -> [AssistantObjectToolsInner] -- ^ 'assistantObjectTools': A list of tool enabled on the assistant. There can be a maximum of 128 tools per assistant. Tools can be of types `code_interpreter`, `retrieval`, or `function`. 
  -> [Text] -- ^ 'assistantObjectFileIds': A list of [file](/docs/api-reference/files) IDs attached to this assistant. There can be a maximum of 20 files attached to the assistant. Files are ordered by their creation date in ascending order. 
  -> A.Value -- ^ 'assistantObjectMetadata': Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long. 
  -> AssistantObject
mkAssistantObject assistantObjectId assistantObjectObject assistantObjectCreatedAt assistantObjectName assistantObjectDescription assistantObjectModel assistantObjectInstructions assistantObjectTools assistantObjectFileIds assistantObjectMetadata =
  AssistantObject
  { assistantObjectId
  , assistantObjectObject
  , assistantObjectCreatedAt
  , assistantObjectName
  , assistantObjectDescription
  , assistantObjectModel
  , assistantObjectInstructions
  , assistantObjectTools
  , assistantObjectFileIds
  , assistantObjectMetadata
  }

-- ** AssistantObjectToolsInner
-- | AssistantObjectToolsInner
data AssistantObjectToolsInner = AssistantObjectToolsInner
  { assistantObjectToolsInnerType :: !(E'Role) -- ^ /Required/ "type" - The type of tool being defined: &#x60;function&#x60;
  , assistantObjectToolsInnerFunction :: !(FunctionObject) -- ^ /Required/ "function"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AssistantObjectToolsInner
instance A.FromJSON AssistantObjectToolsInner where
  parseJSON = A.withObject "AssistantObjectToolsInner" $ \o ->
    AssistantObjectToolsInner
      <$> (o .:  "type")
      <*> (o .:  "function")

-- | ToJSON AssistantObjectToolsInner
instance A.ToJSON AssistantObjectToolsInner where
  toJSON AssistantObjectToolsInner {..} =
   _omitNulls
      [ "type" .= assistantObjectToolsInnerType
      , "function" .= assistantObjectToolsInnerFunction
      ]


-- | Construct a value of type 'AssistantObjectToolsInner' (by applying it's required fields, if any)
mkAssistantObjectToolsInner
  :: E'Role -- ^ 'assistantObjectToolsInnerType': The type of tool being defined: `function`
  -> FunctionObject -- ^ 'assistantObjectToolsInnerFunction' 
  -> AssistantObjectToolsInner
mkAssistantObjectToolsInner assistantObjectToolsInnerType assistantObjectToolsInnerFunction =
  AssistantObjectToolsInner
  { assistantObjectToolsInnerType
  , assistantObjectToolsInnerFunction
  }

-- ** AssistantToolsCode
-- | AssistantToolsCode
-- Code interpreter tool
-- 
data AssistantToolsCode = AssistantToolsCode
  { assistantToolsCodeType :: !(E'Type3) -- ^ /Required/ "type" - The type of tool being defined: &#x60;code_interpreter&#x60;
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AssistantToolsCode
instance A.FromJSON AssistantToolsCode where
  parseJSON = A.withObject "AssistantToolsCode" $ \o ->
    AssistantToolsCode
      <$> (o .:  "type")

-- | ToJSON AssistantToolsCode
instance A.ToJSON AssistantToolsCode where
  toJSON AssistantToolsCode {..} =
   _omitNulls
      [ "type" .= assistantToolsCodeType
      ]


-- | Construct a value of type 'AssistantToolsCode' (by applying it's required fields, if any)
mkAssistantToolsCode
  :: E'Type3 -- ^ 'assistantToolsCodeType': The type of tool being defined: `code_interpreter`
  -> AssistantToolsCode
mkAssistantToolsCode assistantToolsCodeType =
  AssistantToolsCode
  { assistantToolsCodeType
  }

-- ** AssistantToolsFunction
-- | AssistantToolsFunction
-- Function tool
-- 
data AssistantToolsFunction = AssistantToolsFunction
  { assistantToolsFunctionType :: !(E'Role) -- ^ /Required/ "type" - The type of tool being defined: &#x60;function&#x60;
  , assistantToolsFunctionFunction :: !(FunctionObject) -- ^ /Required/ "function"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AssistantToolsFunction
instance A.FromJSON AssistantToolsFunction where
  parseJSON = A.withObject "AssistantToolsFunction" $ \o ->
    AssistantToolsFunction
      <$> (o .:  "type")
      <*> (o .:  "function")

-- | ToJSON AssistantToolsFunction
instance A.ToJSON AssistantToolsFunction where
  toJSON AssistantToolsFunction {..} =
   _omitNulls
      [ "type" .= assistantToolsFunctionType
      , "function" .= assistantToolsFunctionFunction
      ]


-- | Construct a value of type 'AssistantToolsFunction' (by applying it's required fields, if any)
mkAssistantToolsFunction
  :: E'Role -- ^ 'assistantToolsFunctionType': The type of tool being defined: `function`
  -> FunctionObject -- ^ 'assistantToolsFunctionFunction' 
  -> AssistantToolsFunction
mkAssistantToolsFunction assistantToolsFunctionType assistantToolsFunctionFunction =
  AssistantToolsFunction
  { assistantToolsFunctionType
  , assistantToolsFunctionFunction
  }

-- ** AssistantToolsRetrieval
-- | AssistantToolsRetrieval
-- Retrieval tool
-- 
data AssistantToolsRetrieval = AssistantToolsRetrieval
  { assistantToolsRetrievalType :: !(E'Type4) -- ^ /Required/ "type" - The type of tool being defined: &#x60;retrieval&#x60;
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AssistantToolsRetrieval
instance A.FromJSON AssistantToolsRetrieval where
  parseJSON = A.withObject "AssistantToolsRetrieval" $ \o ->
    AssistantToolsRetrieval
      <$> (o .:  "type")

-- | ToJSON AssistantToolsRetrieval
instance A.ToJSON AssistantToolsRetrieval where
  toJSON AssistantToolsRetrieval {..} =
   _omitNulls
      [ "type" .= assistantToolsRetrievalType
      ]


-- | Construct a value of type 'AssistantToolsRetrieval' (by applying it's required fields, if any)
mkAssistantToolsRetrieval
  :: E'Type4 -- ^ 'assistantToolsRetrievalType': The type of tool being defined: `retrieval`
  -> AssistantToolsRetrieval
mkAssistantToolsRetrieval assistantToolsRetrievalType =
  AssistantToolsRetrieval
  { assistantToolsRetrievalType
  }

-- ** ChatCompletionFunctionCallOption
-- | ChatCompletionFunctionCallOption
-- Specifying a particular function via `{\"name\": \"my_function\"}` forces the model to call that function. 
data ChatCompletionFunctionCallOption = ChatCompletionFunctionCallOption
  { chatCompletionFunctionCallOptionName :: !(Text) -- ^ /Required/ "name" - The name of the function to call.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ChatCompletionFunctionCallOption
instance A.FromJSON ChatCompletionFunctionCallOption where
  parseJSON = A.withObject "ChatCompletionFunctionCallOption" $ \o ->
    ChatCompletionFunctionCallOption
      <$> (o .:  "name")

-- | ToJSON ChatCompletionFunctionCallOption
instance A.ToJSON ChatCompletionFunctionCallOption where
  toJSON ChatCompletionFunctionCallOption {..} =
   _omitNulls
      [ "name" .= chatCompletionFunctionCallOptionName
      ]


-- | Construct a value of type 'ChatCompletionFunctionCallOption' (by applying it's required fields, if any)
mkChatCompletionFunctionCallOption
  :: Text -- ^ 'chatCompletionFunctionCallOptionName': The name of the function to call.
  -> ChatCompletionFunctionCallOption
mkChatCompletionFunctionCallOption chatCompletionFunctionCallOptionName =
  ChatCompletionFunctionCallOption
  { chatCompletionFunctionCallOptionName
  }

-- ** ChatCompletionFunctions
-- | ChatCompletionFunctions
data ChatCompletionFunctions = ChatCompletionFunctions
  { chatCompletionFunctionsDescription :: !(Maybe Text) -- ^ "description" - A description of what the function does, used by the model to choose when and how to call the function.
  , chatCompletionFunctionsName :: !(Text) -- ^ /Required/ "name" - The name of the function to be called. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
  , chatCompletionFunctionsParameters :: !(Maybe (Map.Map String A.Value)) -- ^ "parameters" - The parameters the functions accepts, described as a JSON Schema object. See the [guide](/docs/guides/text-generation/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format.   Omitting &#x60;parameters&#x60; defines a function with an empty parameter list.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ChatCompletionFunctions
instance A.FromJSON ChatCompletionFunctions where
  parseJSON = A.withObject "ChatCompletionFunctions" $ \o ->
    ChatCompletionFunctions
      <$> (o .:? "description")
      <*> (o .:  "name")
      <*> (o .:? "parameters")

-- | ToJSON ChatCompletionFunctions
instance A.ToJSON ChatCompletionFunctions where
  toJSON ChatCompletionFunctions {..} =
   _omitNulls
      [ "description" .= chatCompletionFunctionsDescription
      , "name" .= chatCompletionFunctionsName
      , "parameters" .= chatCompletionFunctionsParameters
      ]


-- | Construct a value of type 'ChatCompletionFunctions' (by applying it's required fields, if any)
mkChatCompletionFunctions
  :: Text -- ^ 'chatCompletionFunctionsName': The name of the function to be called. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
  -> ChatCompletionFunctions
mkChatCompletionFunctions chatCompletionFunctionsName =
  ChatCompletionFunctions
  { chatCompletionFunctionsDescription = Nothing
  , chatCompletionFunctionsName
  , chatCompletionFunctionsParameters = Nothing
  }

-- ** ChatCompletionMessageToolCall
-- | ChatCompletionMessageToolCall
data ChatCompletionMessageToolCall = ChatCompletionMessageToolCall
  { chatCompletionMessageToolCallId :: !(Text) -- ^ /Required/ "id" - The ID of the tool call.
  , chatCompletionMessageToolCallType :: !(E'Role) -- ^ /Required/ "type" - The type of the tool. Currently, only &#x60;function&#x60; is supported.
  , chatCompletionMessageToolCallFunction :: !(ChatCompletionMessageToolCallFunction) -- ^ /Required/ "function"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ChatCompletionMessageToolCall
instance A.FromJSON ChatCompletionMessageToolCall where
  parseJSON = A.withObject "ChatCompletionMessageToolCall" $ \o ->
    ChatCompletionMessageToolCall
      <$> (o .:  "id")
      <*> (o .:  "type")
      <*> (o .:  "function")

-- | ToJSON ChatCompletionMessageToolCall
instance A.ToJSON ChatCompletionMessageToolCall where
  toJSON ChatCompletionMessageToolCall {..} =
   _omitNulls
      [ "id" .= chatCompletionMessageToolCallId
      , "type" .= chatCompletionMessageToolCallType
      , "function" .= chatCompletionMessageToolCallFunction
      ]


-- | Construct a value of type 'ChatCompletionMessageToolCall' (by applying it's required fields, if any)
mkChatCompletionMessageToolCall
  :: Text -- ^ 'chatCompletionMessageToolCallId': The ID of the tool call.
  -> E'Role -- ^ 'chatCompletionMessageToolCallType': The type of the tool. Currently, only `function` is supported.
  -> ChatCompletionMessageToolCallFunction -- ^ 'chatCompletionMessageToolCallFunction' 
  -> ChatCompletionMessageToolCall
mkChatCompletionMessageToolCall chatCompletionMessageToolCallId chatCompletionMessageToolCallType chatCompletionMessageToolCallFunction =
  ChatCompletionMessageToolCall
  { chatCompletionMessageToolCallId
  , chatCompletionMessageToolCallType
  , chatCompletionMessageToolCallFunction
  }

-- ** ChatCompletionMessageToolCallChunk
-- | ChatCompletionMessageToolCallChunk
data ChatCompletionMessageToolCallChunk = ChatCompletionMessageToolCallChunk
  { chatCompletionMessageToolCallChunkIndex :: !(Int) -- ^ /Required/ "index"
  , chatCompletionMessageToolCallChunkId :: !(Maybe Text) -- ^ "id" - The ID of the tool call.
  , chatCompletionMessageToolCallChunkType :: !(Maybe E'Role) -- ^ "type" - The type of the tool. Currently, only &#x60;function&#x60; is supported.
  , chatCompletionMessageToolCallChunkFunction :: !(Maybe ChatCompletionMessageToolCallChunkFunction) -- ^ "function"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ChatCompletionMessageToolCallChunk
instance A.FromJSON ChatCompletionMessageToolCallChunk where
  parseJSON = A.withObject "ChatCompletionMessageToolCallChunk" $ \o ->
    ChatCompletionMessageToolCallChunk
      <$> (o .:  "index")
      <*> (o .:? "id")
      <*> (o .:? "type")
      <*> (o .:? "function")

-- | ToJSON ChatCompletionMessageToolCallChunk
instance A.ToJSON ChatCompletionMessageToolCallChunk where
  toJSON ChatCompletionMessageToolCallChunk {..} =
   _omitNulls
      [ "index" .= chatCompletionMessageToolCallChunkIndex
      , "id" .= chatCompletionMessageToolCallChunkId
      , "type" .= chatCompletionMessageToolCallChunkType
      , "function" .= chatCompletionMessageToolCallChunkFunction
      ]


-- | Construct a value of type 'ChatCompletionMessageToolCallChunk' (by applying it's required fields, if any)
mkChatCompletionMessageToolCallChunk
  :: Int -- ^ 'chatCompletionMessageToolCallChunkIndex' 
  -> ChatCompletionMessageToolCallChunk
mkChatCompletionMessageToolCallChunk chatCompletionMessageToolCallChunkIndex =
  ChatCompletionMessageToolCallChunk
  { chatCompletionMessageToolCallChunkIndex
  , chatCompletionMessageToolCallChunkId = Nothing
  , chatCompletionMessageToolCallChunkType = Nothing
  , chatCompletionMessageToolCallChunkFunction = Nothing
  }

-- ** ChatCompletionMessageToolCallChunkFunction
-- | ChatCompletionMessageToolCallChunkFunction
data ChatCompletionMessageToolCallChunkFunction = ChatCompletionMessageToolCallChunkFunction
  { chatCompletionMessageToolCallChunkFunctionName :: !(Maybe Text) -- ^ "name" - The name of the function to call.
  , chatCompletionMessageToolCallChunkFunctionArguments :: !(Maybe Text) -- ^ "arguments" - The arguments to call the function with, as generated by the model in JSON format. Note that the model does not always generate valid JSON, and may hallucinate parameters not defined by your function schema. Validate the arguments in your code before calling your function.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ChatCompletionMessageToolCallChunkFunction
instance A.FromJSON ChatCompletionMessageToolCallChunkFunction where
  parseJSON = A.withObject "ChatCompletionMessageToolCallChunkFunction" $ \o ->
    ChatCompletionMessageToolCallChunkFunction
      <$> (o .:? "name")
      <*> (o .:? "arguments")

-- | ToJSON ChatCompletionMessageToolCallChunkFunction
instance A.ToJSON ChatCompletionMessageToolCallChunkFunction where
  toJSON ChatCompletionMessageToolCallChunkFunction {..} =
   _omitNulls
      [ "name" .= chatCompletionMessageToolCallChunkFunctionName
      , "arguments" .= chatCompletionMessageToolCallChunkFunctionArguments
      ]


-- | Construct a value of type 'ChatCompletionMessageToolCallChunkFunction' (by applying it's required fields, if any)
mkChatCompletionMessageToolCallChunkFunction
  :: ChatCompletionMessageToolCallChunkFunction
mkChatCompletionMessageToolCallChunkFunction =
  ChatCompletionMessageToolCallChunkFunction
  { chatCompletionMessageToolCallChunkFunctionName = Nothing
  , chatCompletionMessageToolCallChunkFunctionArguments = Nothing
  }

-- ** ChatCompletionMessageToolCallFunction
-- | ChatCompletionMessageToolCallFunction
-- The function that the model called.
data ChatCompletionMessageToolCallFunction = ChatCompletionMessageToolCallFunction
  { chatCompletionMessageToolCallFunctionName :: !(Text) -- ^ /Required/ "name" - The name of the function to call.
  , chatCompletionMessageToolCallFunctionArguments :: !(Text) -- ^ /Required/ "arguments" - The arguments to call the function with, as generated by the model in JSON format. Note that the model does not always generate valid JSON, and may hallucinate parameters not defined by your function schema. Validate the arguments in your code before calling your function.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ChatCompletionMessageToolCallFunction
instance A.FromJSON ChatCompletionMessageToolCallFunction where
  parseJSON = A.withObject "ChatCompletionMessageToolCallFunction" $ \o ->
    ChatCompletionMessageToolCallFunction
      <$> (o .:  "name")
      <*> (o .:  "arguments")

-- | ToJSON ChatCompletionMessageToolCallFunction
instance A.ToJSON ChatCompletionMessageToolCallFunction where
  toJSON ChatCompletionMessageToolCallFunction {..} =
   _omitNulls
      [ "name" .= chatCompletionMessageToolCallFunctionName
      , "arguments" .= chatCompletionMessageToolCallFunctionArguments
      ]


-- | Construct a value of type 'ChatCompletionMessageToolCallFunction' (by applying it's required fields, if any)
mkChatCompletionMessageToolCallFunction
  :: Text -- ^ 'chatCompletionMessageToolCallFunctionName': The name of the function to call.
  -> Text -- ^ 'chatCompletionMessageToolCallFunctionArguments': The arguments to call the function with, as generated by the model in JSON format. Note that the model does not always generate valid JSON, and may hallucinate parameters not defined by your function schema. Validate the arguments in your code before calling your function.
  -> ChatCompletionMessageToolCallFunction
mkChatCompletionMessageToolCallFunction chatCompletionMessageToolCallFunctionName chatCompletionMessageToolCallFunctionArguments =
  ChatCompletionMessageToolCallFunction
  { chatCompletionMessageToolCallFunctionName
  , chatCompletionMessageToolCallFunctionArguments
  }

-- ** ChatCompletionNamedToolChoice
-- | ChatCompletionNamedToolChoice
-- Specifies a tool the model should use. Use to force the model to call a specific function.
data ChatCompletionNamedToolChoice = ChatCompletionNamedToolChoice
  { chatCompletionNamedToolChoiceType :: !(E'Role) -- ^ /Required/ "type" - The type of the tool. Currently, only &#x60;function&#x60; is supported.
  , chatCompletionNamedToolChoiceFunction :: !(ChatCompletionNamedToolChoiceFunction) -- ^ /Required/ "function"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ChatCompletionNamedToolChoice
instance A.FromJSON ChatCompletionNamedToolChoice where
  parseJSON = A.withObject "ChatCompletionNamedToolChoice" $ \o ->
    ChatCompletionNamedToolChoice
      <$> (o .:  "type")
      <*> (o .:  "function")

-- | ToJSON ChatCompletionNamedToolChoice
instance A.ToJSON ChatCompletionNamedToolChoice where
  toJSON ChatCompletionNamedToolChoice {..} =
   _omitNulls
      [ "type" .= chatCompletionNamedToolChoiceType
      , "function" .= chatCompletionNamedToolChoiceFunction
      ]


-- | Construct a value of type 'ChatCompletionNamedToolChoice' (by applying it's required fields, if any)
mkChatCompletionNamedToolChoice
  :: E'Role -- ^ 'chatCompletionNamedToolChoiceType': The type of the tool. Currently, only `function` is supported.
  -> ChatCompletionNamedToolChoiceFunction -- ^ 'chatCompletionNamedToolChoiceFunction' 
  -> ChatCompletionNamedToolChoice
mkChatCompletionNamedToolChoice chatCompletionNamedToolChoiceType chatCompletionNamedToolChoiceFunction =
  ChatCompletionNamedToolChoice
  { chatCompletionNamedToolChoiceType
  , chatCompletionNamedToolChoiceFunction
  }

-- ** ChatCompletionNamedToolChoiceFunction
-- | ChatCompletionNamedToolChoiceFunction
data ChatCompletionNamedToolChoiceFunction = ChatCompletionNamedToolChoiceFunction
  { chatCompletionNamedToolChoiceFunctionName :: !(Text) -- ^ /Required/ "name" - The name of the function to call.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ChatCompletionNamedToolChoiceFunction
instance A.FromJSON ChatCompletionNamedToolChoiceFunction where
  parseJSON = A.withObject "ChatCompletionNamedToolChoiceFunction" $ \o ->
    ChatCompletionNamedToolChoiceFunction
      <$> (o .:  "name")

-- | ToJSON ChatCompletionNamedToolChoiceFunction
instance A.ToJSON ChatCompletionNamedToolChoiceFunction where
  toJSON ChatCompletionNamedToolChoiceFunction {..} =
   _omitNulls
      [ "name" .= chatCompletionNamedToolChoiceFunctionName
      ]


-- | Construct a value of type 'ChatCompletionNamedToolChoiceFunction' (by applying it's required fields, if any)
mkChatCompletionNamedToolChoiceFunction
  :: Text -- ^ 'chatCompletionNamedToolChoiceFunctionName': The name of the function to call.
  -> ChatCompletionNamedToolChoiceFunction
mkChatCompletionNamedToolChoiceFunction chatCompletionNamedToolChoiceFunctionName =
  ChatCompletionNamedToolChoiceFunction
  { chatCompletionNamedToolChoiceFunctionName
  }

-- ** ChatCompletionRequestAssistantMessage
-- | ChatCompletionRequestAssistantMessage
-- Assistant message
-- 
data ChatCompletionRequestAssistantMessage = ChatCompletionRequestAssistantMessage
  { chatCompletionRequestAssistantMessageContent :: !(Maybe Text) -- ^ "content" - The contents of the assistant message. Required unless &#x60;tool_calls&#x60; or &#x60;function_call&#x60; is specified. 
  , chatCompletionRequestAssistantMessageRole :: !(E'Role4) -- ^ /Required/ "role" - The role of the messages author, in this case &#x60;assistant&#x60;.
  , chatCompletionRequestAssistantMessageName :: !(Maybe Text) -- ^ "name" - An optional name for the participant. Provides the model information to differentiate between participants of the same role.
  , chatCompletionRequestAssistantMessageToolCalls :: !(Maybe [ChatCompletionMessageToolCall]) -- ^ "tool_calls" - The tool calls generated by the model, such as function calls.
  , chatCompletionRequestAssistantMessageFunctionCall :: !(Maybe ChatCompletionRequestAssistantMessageFunctionCall) -- ^ "function_call"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ChatCompletionRequestAssistantMessage
instance A.FromJSON ChatCompletionRequestAssistantMessage where
  parseJSON = A.withObject "ChatCompletionRequestAssistantMessage" $ \o ->
    ChatCompletionRequestAssistantMessage
      <$> (o .:? "content")
      <*> (o .:  "role")
      <*> (o .:? "name")
      <*> (o .:? "tool_calls")
      <*> (o .:? "function_call")

-- | ToJSON ChatCompletionRequestAssistantMessage
instance A.ToJSON ChatCompletionRequestAssistantMessage where
  toJSON ChatCompletionRequestAssistantMessage {..} =
   _omitNulls
      [ "content" .= chatCompletionRequestAssistantMessageContent
      , "role" .= chatCompletionRequestAssistantMessageRole
      , "name" .= chatCompletionRequestAssistantMessageName
      , "tool_calls" .= chatCompletionRequestAssistantMessageToolCalls
      , "function_call" .= chatCompletionRequestAssistantMessageFunctionCall
      ]


-- | Construct a value of type 'ChatCompletionRequestAssistantMessage' (by applying it's required fields, if any)
mkChatCompletionRequestAssistantMessage
  :: E'Role4 -- ^ 'chatCompletionRequestAssistantMessageRole': The role of the messages author, in this case `assistant`.
  -> ChatCompletionRequestAssistantMessage
mkChatCompletionRequestAssistantMessage chatCompletionRequestAssistantMessageRole =
  ChatCompletionRequestAssistantMessage
  { chatCompletionRequestAssistantMessageContent = Nothing
  , chatCompletionRequestAssistantMessageRole
  , chatCompletionRequestAssistantMessageName = Nothing
  , chatCompletionRequestAssistantMessageToolCalls = Nothing
  , chatCompletionRequestAssistantMessageFunctionCall = Nothing
  }

-- ** ChatCompletionRequestAssistantMessageFunctionCall
-- | ChatCompletionRequestAssistantMessageFunctionCall
-- Deprecated and replaced by `tool_calls`. The name and arguments of a function that should be called, as generated by the model.
data ChatCompletionRequestAssistantMessageFunctionCall = ChatCompletionRequestAssistantMessageFunctionCall
  { chatCompletionRequestAssistantMessageFunctionCallArguments :: !(Text) -- ^ /Required/ "arguments" - The arguments to call the function with, as generated by the model in JSON format. Note that the model does not always generate valid JSON, and may hallucinate parameters not defined by your function schema. Validate the arguments in your code before calling your function.
  , chatCompletionRequestAssistantMessageFunctionCallName :: !(Text) -- ^ /Required/ "name" - The name of the function to call.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ChatCompletionRequestAssistantMessageFunctionCall
instance A.FromJSON ChatCompletionRequestAssistantMessageFunctionCall where
  parseJSON = A.withObject "ChatCompletionRequestAssistantMessageFunctionCall" $ \o ->
    ChatCompletionRequestAssistantMessageFunctionCall
      <$> (o .:  "arguments")
      <*> (o .:  "name")

-- | ToJSON ChatCompletionRequestAssistantMessageFunctionCall
instance A.ToJSON ChatCompletionRequestAssistantMessageFunctionCall where
  toJSON ChatCompletionRequestAssistantMessageFunctionCall {..} =
   _omitNulls
      [ "arguments" .= chatCompletionRequestAssistantMessageFunctionCallArguments
      , "name" .= chatCompletionRequestAssistantMessageFunctionCallName
      ]


-- | Construct a value of type 'ChatCompletionRequestAssistantMessageFunctionCall' (by applying it's required fields, if any)
mkChatCompletionRequestAssistantMessageFunctionCall
  :: Text -- ^ 'chatCompletionRequestAssistantMessageFunctionCallArguments': The arguments to call the function with, as generated by the model in JSON format. Note that the model does not always generate valid JSON, and may hallucinate parameters not defined by your function schema. Validate the arguments in your code before calling your function.
  -> Text -- ^ 'chatCompletionRequestAssistantMessageFunctionCallName': The name of the function to call.
  -> ChatCompletionRequestAssistantMessageFunctionCall
mkChatCompletionRequestAssistantMessageFunctionCall chatCompletionRequestAssistantMessageFunctionCallArguments chatCompletionRequestAssistantMessageFunctionCallName =
  ChatCompletionRequestAssistantMessageFunctionCall
  { chatCompletionRequestAssistantMessageFunctionCallArguments
  , chatCompletionRequestAssistantMessageFunctionCallName
  }

-- ** ChatCompletionRequestFunctionMessage
-- | ChatCompletionRequestFunctionMessage
-- Function message
-- 
data ChatCompletionRequestFunctionMessage = ChatCompletionRequestFunctionMessage
  { chatCompletionRequestFunctionMessageRole :: !(E'Role) -- ^ /Required/ "role" - The role of the messages author, in this case &#x60;function&#x60;.
  , chatCompletionRequestFunctionMessageContent :: !(Text) -- ^ /Required/ "content" - The contents of the function message.
  , chatCompletionRequestFunctionMessageName :: !(Text) -- ^ /Required/ "name" - The name of the function to call.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ChatCompletionRequestFunctionMessage
instance A.FromJSON ChatCompletionRequestFunctionMessage where
  parseJSON = A.withObject "ChatCompletionRequestFunctionMessage" $ \o ->
    ChatCompletionRequestFunctionMessage
      <$> (o .:  "role")
      <*> (o .:  "content")
      <*> (o .:  "name")

-- | ToJSON ChatCompletionRequestFunctionMessage
instance A.ToJSON ChatCompletionRequestFunctionMessage where
  toJSON ChatCompletionRequestFunctionMessage {..} =
   _omitNulls
      [ "role" .= chatCompletionRequestFunctionMessageRole
      , "content" .= chatCompletionRequestFunctionMessageContent
      , "name" .= chatCompletionRequestFunctionMessageName
      ]


-- | Construct a value of type 'ChatCompletionRequestFunctionMessage' (by applying it's required fields, if any)
mkChatCompletionRequestFunctionMessage
  :: E'Role -- ^ 'chatCompletionRequestFunctionMessageRole': The role of the messages author, in this case `function`.
  -> Text -- ^ 'chatCompletionRequestFunctionMessageContent': The contents of the function message.
  -> Text -- ^ 'chatCompletionRequestFunctionMessageName': The name of the function to call.
  -> ChatCompletionRequestFunctionMessage
mkChatCompletionRequestFunctionMessage chatCompletionRequestFunctionMessageRole chatCompletionRequestFunctionMessageContent chatCompletionRequestFunctionMessageName =
  ChatCompletionRequestFunctionMessage
  { chatCompletionRequestFunctionMessageRole
  , chatCompletionRequestFunctionMessageContent
  , chatCompletionRequestFunctionMessageName
  }

-- ** ChatCompletionRequestMessage
-- | ChatCompletionRequestMessage
data ChatCompletionRequestMessage = ChatCompletionRequestMessage
  { chatCompletionRequestMessageContent :: !(Text) -- ^ /Required/ "content" - The contents of the function message.
  , chatCompletionRequestMessageRole :: !(E'Role) -- ^ /Required/ "role" - The role of the messages author, in this case &#x60;function&#x60;.
  , chatCompletionRequestMessageName :: !(Text) -- ^ /Required/ "name" - The name of the function to call.
  , chatCompletionRequestMessageToolCalls :: !(Maybe [ChatCompletionMessageToolCall]) -- ^ "tool_calls" - The tool calls generated by the model, such as function calls.
  , chatCompletionRequestMessageFunctionCall :: !(Maybe ChatCompletionRequestAssistantMessageFunctionCall) -- ^ "function_call"
  , chatCompletionRequestMessageToolCallId :: !(Text) -- ^ /Required/ "tool_call_id" - Tool call that this message is responding to.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ChatCompletionRequestMessage
instance A.FromJSON ChatCompletionRequestMessage where
  parseJSON = A.withObject "ChatCompletionRequestMessage" $ \o ->
    ChatCompletionRequestMessage
      <$> (o .:  "content")
      <*> (o .:  "role")
      <*> (o .:  "name")
      <*> (o .:? "tool_calls")
      <*> (o .:? "function_call")
      <*> (o .:  "tool_call_id")

-- | ToJSON ChatCompletionRequestMessage
instance A.ToJSON ChatCompletionRequestMessage where
  toJSON ChatCompletionRequestMessage {..} =
   _omitNulls
      [ "content" .= chatCompletionRequestMessageContent
      , "role" .= chatCompletionRequestMessageRole
      , "name" .= chatCompletionRequestMessageName
      , "tool_calls" .= chatCompletionRequestMessageToolCalls
      , "function_call" .= chatCompletionRequestMessageFunctionCall
      , "tool_call_id" .= chatCompletionRequestMessageToolCallId
      ]


-- | Construct a value of type 'ChatCompletionRequestMessage' (by applying it's required fields, if any)
mkChatCompletionRequestMessage
  :: Text -- ^ 'chatCompletionRequestMessageContent': The contents of the function message.
  -> E'Role -- ^ 'chatCompletionRequestMessageRole': The role of the messages author, in this case `function`.
  -> Text -- ^ 'chatCompletionRequestMessageName': The name of the function to call.
  -> Text -- ^ 'chatCompletionRequestMessageToolCallId': Tool call that this message is responding to.
  -> ChatCompletionRequestMessage
mkChatCompletionRequestMessage chatCompletionRequestMessageContent chatCompletionRequestMessageRole chatCompletionRequestMessageName chatCompletionRequestMessageToolCallId =
  ChatCompletionRequestMessage
  { chatCompletionRequestMessageContent
  , chatCompletionRequestMessageRole
  , chatCompletionRequestMessageName
  , chatCompletionRequestMessageToolCalls = Nothing
  , chatCompletionRequestMessageFunctionCall = Nothing
  , chatCompletionRequestMessageToolCallId
  }

-- ** ChatCompletionRequestMessageContentPart
-- | ChatCompletionRequestMessageContentPart
data ChatCompletionRequestMessageContentPart = ChatCompletionRequestMessageContentPart
  { chatCompletionRequestMessageContentPartType :: !(E'Type) -- ^ /Required/ "type" - The type of the content part.
  , chatCompletionRequestMessageContentPartText :: !(Text) -- ^ /Required/ "text" - The text content.
  , chatCompletionRequestMessageContentPartImageUrl :: !(ChatCompletionRequestMessageContentPartImageImageUrl) -- ^ /Required/ "image_url"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ChatCompletionRequestMessageContentPart
instance A.FromJSON ChatCompletionRequestMessageContentPart where
  parseJSON = A.withObject "ChatCompletionRequestMessageContentPart" $ \o ->
    ChatCompletionRequestMessageContentPart
      <$> (o .:  "type")
      <*> (o .:  "text")
      <*> (o .:  "image_url")

-- | ToJSON ChatCompletionRequestMessageContentPart
instance A.ToJSON ChatCompletionRequestMessageContentPart where
  toJSON ChatCompletionRequestMessageContentPart {..} =
   _omitNulls
      [ "type" .= chatCompletionRequestMessageContentPartType
      , "text" .= chatCompletionRequestMessageContentPartText
      , "image_url" .= chatCompletionRequestMessageContentPartImageUrl
      ]


-- | Construct a value of type 'ChatCompletionRequestMessageContentPart' (by applying it's required fields, if any)
mkChatCompletionRequestMessageContentPart
  :: E'Type -- ^ 'chatCompletionRequestMessageContentPartType': The type of the content part.
  -> Text -- ^ 'chatCompletionRequestMessageContentPartText': The text content.
  -> ChatCompletionRequestMessageContentPartImageImageUrl -- ^ 'chatCompletionRequestMessageContentPartImageUrl' 
  -> ChatCompletionRequestMessageContentPart
mkChatCompletionRequestMessageContentPart chatCompletionRequestMessageContentPartType chatCompletionRequestMessageContentPartText chatCompletionRequestMessageContentPartImageUrl =
  ChatCompletionRequestMessageContentPart
  { chatCompletionRequestMessageContentPartType
  , chatCompletionRequestMessageContentPartText
  , chatCompletionRequestMessageContentPartImageUrl
  }

-- ** ChatCompletionRequestMessageContentPartImage
-- | ChatCompletionRequestMessageContentPartImage
-- Image content part
-- 
data ChatCompletionRequestMessageContentPartImage = ChatCompletionRequestMessageContentPartImage
  { chatCompletionRequestMessageContentPartImageType :: !(E'Type) -- ^ /Required/ "type" - The type of the content part.
  , chatCompletionRequestMessageContentPartImageImageUrl :: !(ChatCompletionRequestMessageContentPartImageImageUrl) -- ^ /Required/ "image_url"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ChatCompletionRequestMessageContentPartImage
instance A.FromJSON ChatCompletionRequestMessageContentPartImage where
  parseJSON = A.withObject "ChatCompletionRequestMessageContentPartImage" $ \o ->
    ChatCompletionRequestMessageContentPartImage
      <$> (o .:  "type")
      <*> (o .:  "image_url")

-- | ToJSON ChatCompletionRequestMessageContentPartImage
instance A.ToJSON ChatCompletionRequestMessageContentPartImage where
  toJSON ChatCompletionRequestMessageContentPartImage {..} =
   _omitNulls
      [ "type" .= chatCompletionRequestMessageContentPartImageType
      , "image_url" .= chatCompletionRequestMessageContentPartImageImageUrl
      ]


-- | Construct a value of type 'ChatCompletionRequestMessageContentPartImage' (by applying it's required fields, if any)
mkChatCompletionRequestMessageContentPartImage
  :: E'Type -- ^ 'chatCompletionRequestMessageContentPartImageType': The type of the content part.
  -> ChatCompletionRequestMessageContentPartImageImageUrl -- ^ 'chatCompletionRequestMessageContentPartImageImageUrl' 
  -> ChatCompletionRequestMessageContentPartImage
mkChatCompletionRequestMessageContentPartImage chatCompletionRequestMessageContentPartImageType chatCompletionRequestMessageContentPartImageImageUrl =
  ChatCompletionRequestMessageContentPartImage
  { chatCompletionRequestMessageContentPartImageType
  , chatCompletionRequestMessageContentPartImageImageUrl
  }

-- ** ChatCompletionRequestMessageContentPartImageImageUrl
-- | ChatCompletionRequestMessageContentPartImageImageUrl
data ChatCompletionRequestMessageContentPartImageImageUrl = ChatCompletionRequestMessageContentPartImageImageUrl
  { chatCompletionRequestMessageContentPartImageImageUrlUrl :: !(Text) -- ^ /Required/ "url" - Either a URL of the image or the base64 encoded image data.
  , chatCompletionRequestMessageContentPartImageImageUrlDetail :: !(Maybe E'Detail) -- ^ "detail" - Specifies the detail level of the image. Learn more in the [Vision guide](/docs/guides/vision/low-or-high-fidelity-image-understanding).
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ChatCompletionRequestMessageContentPartImageImageUrl
instance A.FromJSON ChatCompletionRequestMessageContentPartImageImageUrl where
  parseJSON = A.withObject "ChatCompletionRequestMessageContentPartImageImageUrl" $ \o ->
    ChatCompletionRequestMessageContentPartImageImageUrl
      <$> (o .:  "url")
      <*> (o .:? "detail")

-- | ToJSON ChatCompletionRequestMessageContentPartImageImageUrl
instance A.ToJSON ChatCompletionRequestMessageContentPartImageImageUrl where
  toJSON ChatCompletionRequestMessageContentPartImageImageUrl {..} =
   _omitNulls
      [ "url" .= chatCompletionRequestMessageContentPartImageImageUrlUrl
      , "detail" .= chatCompletionRequestMessageContentPartImageImageUrlDetail
      ]


-- | Construct a value of type 'ChatCompletionRequestMessageContentPartImageImageUrl' (by applying it's required fields, if any)
mkChatCompletionRequestMessageContentPartImageImageUrl
  :: Text -- ^ 'chatCompletionRequestMessageContentPartImageImageUrlUrl': Either a URL of the image or the base64 encoded image data.
  -> ChatCompletionRequestMessageContentPartImageImageUrl
mkChatCompletionRequestMessageContentPartImageImageUrl chatCompletionRequestMessageContentPartImageImageUrlUrl =
  ChatCompletionRequestMessageContentPartImageImageUrl
  { chatCompletionRequestMessageContentPartImageImageUrlUrl
  , chatCompletionRequestMessageContentPartImageImageUrlDetail = Nothing
  }

-- ** ChatCompletionRequestMessageContentPartText
-- | ChatCompletionRequestMessageContentPartText
-- Text content part
-- 
data ChatCompletionRequestMessageContentPartText = ChatCompletionRequestMessageContentPartText
  { chatCompletionRequestMessageContentPartTextType :: !(E'Type2) -- ^ /Required/ "type" - The type of the content part.
  , chatCompletionRequestMessageContentPartTextText :: !(Text) -- ^ /Required/ "text" - The text content.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ChatCompletionRequestMessageContentPartText
instance A.FromJSON ChatCompletionRequestMessageContentPartText where
  parseJSON = A.withObject "ChatCompletionRequestMessageContentPartText" $ \o ->
    ChatCompletionRequestMessageContentPartText
      <$> (o .:  "type")
      <*> (o .:  "text")

-- | ToJSON ChatCompletionRequestMessageContentPartText
instance A.ToJSON ChatCompletionRequestMessageContentPartText where
  toJSON ChatCompletionRequestMessageContentPartText {..} =
   _omitNulls
      [ "type" .= chatCompletionRequestMessageContentPartTextType
      , "text" .= chatCompletionRequestMessageContentPartTextText
      ]


-- | Construct a value of type 'ChatCompletionRequestMessageContentPartText' (by applying it's required fields, if any)
mkChatCompletionRequestMessageContentPartText
  :: E'Type2 -- ^ 'chatCompletionRequestMessageContentPartTextType': The type of the content part.
  -> Text -- ^ 'chatCompletionRequestMessageContentPartTextText': The text content.
  -> ChatCompletionRequestMessageContentPartText
mkChatCompletionRequestMessageContentPartText chatCompletionRequestMessageContentPartTextType chatCompletionRequestMessageContentPartTextText =
  ChatCompletionRequestMessageContentPartText
  { chatCompletionRequestMessageContentPartTextType
  , chatCompletionRequestMessageContentPartTextText
  }

-- ** ChatCompletionRequestSystemMessage
-- | ChatCompletionRequestSystemMessage
-- System message
-- 
data ChatCompletionRequestSystemMessage = ChatCompletionRequestSystemMessage
  { chatCompletionRequestSystemMessageContent :: !(Text) -- ^ /Required/ "content" - The contents of the system message.
  , chatCompletionRequestSystemMessageRole :: !(E'Role2) -- ^ /Required/ "role" - The role of the messages author, in this case &#x60;system&#x60;.
  , chatCompletionRequestSystemMessageName :: !(Maybe Text) -- ^ "name" - An optional name for the participant. Provides the model information to differentiate between participants of the same role.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ChatCompletionRequestSystemMessage
instance A.FromJSON ChatCompletionRequestSystemMessage where
  parseJSON = A.withObject "ChatCompletionRequestSystemMessage" $ \o ->
    ChatCompletionRequestSystemMessage
      <$> (o .:  "content")
      <*> (o .:  "role")
      <*> (o .:? "name")

-- | ToJSON ChatCompletionRequestSystemMessage
instance A.ToJSON ChatCompletionRequestSystemMessage where
  toJSON ChatCompletionRequestSystemMessage {..} =
   _omitNulls
      [ "content" .= chatCompletionRequestSystemMessageContent
      , "role" .= chatCompletionRequestSystemMessageRole
      , "name" .= chatCompletionRequestSystemMessageName
      ]


-- | Construct a value of type 'ChatCompletionRequestSystemMessage' (by applying it's required fields, if any)
mkChatCompletionRequestSystemMessage
  :: Text -- ^ 'chatCompletionRequestSystemMessageContent': The contents of the system message.
  -> E'Role2 -- ^ 'chatCompletionRequestSystemMessageRole': The role of the messages author, in this case `system`.
  -> ChatCompletionRequestSystemMessage
mkChatCompletionRequestSystemMessage chatCompletionRequestSystemMessageContent chatCompletionRequestSystemMessageRole =
  ChatCompletionRequestSystemMessage
  { chatCompletionRequestSystemMessageContent
  , chatCompletionRequestSystemMessageRole
  , chatCompletionRequestSystemMessageName = Nothing
  }

-- ** ChatCompletionRequestToolMessage
-- | ChatCompletionRequestToolMessage
-- Tool message
-- 
data ChatCompletionRequestToolMessage = ChatCompletionRequestToolMessage
  { chatCompletionRequestToolMessageRole :: !(E'Role5) -- ^ /Required/ "role" - The role of the messages author, in this case &#x60;tool&#x60;.
  , chatCompletionRequestToolMessageContent :: !(Text) -- ^ /Required/ "content" - The contents of the tool message.
  , chatCompletionRequestToolMessageToolCallId :: !(Text) -- ^ /Required/ "tool_call_id" - Tool call that this message is responding to.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ChatCompletionRequestToolMessage
instance A.FromJSON ChatCompletionRequestToolMessage where
  parseJSON = A.withObject "ChatCompletionRequestToolMessage" $ \o ->
    ChatCompletionRequestToolMessage
      <$> (o .:  "role")
      <*> (o .:  "content")
      <*> (o .:  "tool_call_id")

-- | ToJSON ChatCompletionRequestToolMessage
instance A.ToJSON ChatCompletionRequestToolMessage where
  toJSON ChatCompletionRequestToolMessage {..} =
   _omitNulls
      [ "role" .= chatCompletionRequestToolMessageRole
      , "content" .= chatCompletionRequestToolMessageContent
      , "tool_call_id" .= chatCompletionRequestToolMessageToolCallId
      ]


-- | Construct a value of type 'ChatCompletionRequestToolMessage' (by applying it's required fields, if any)
mkChatCompletionRequestToolMessage
  :: E'Role5 -- ^ 'chatCompletionRequestToolMessageRole': The role of the messages author, in this case `tool`.
  -> Text -- ^ 'chatCompletionRequestToolMessageContent': The contents of the tool message.
  -> Text -- ^ 'chatCompletionRequestToolMessageToolCallId': Tool call that this message is responding to.
  -> ChatCompletionRequestToolMessage
mkChatCompletionRequestToolMessage chatCompletionRequestToolMessageRole chatCompletionRequestToolMessageContent chatCompletionRequestToolMessageToolCallId =
  ChatCompletionRequestToolMessage
  { chatCompletionRequestToolMessageRole
  , chatCompletionRequestToolMessageContent
  , chatCompletionRequestToolMessageToolCallId
  }

-- ** ChatCompletionRequestUserMessage
-- | ChatCompletionRequestUserMessage
-- User message
-- 
data ChatCompletionRequestUserMessage = ChatCompletionRequestUserMessage
  { chatCompletionRequestUserMessageContent :: !(ChatCompletionRequestUserMessageContent) -- ^ /Required/ "content"
  , chatCompletionRequestUserMessageRole :: !(E'Role3) -- ^ /Required/ "role" - The role of the messages author, in this case &#x60;user&#x60;.
  , chatCompletionRequestUserMessageName :: !(Maybe Text) -- ^ "name" - An optional name for the participant. Provides the model information to differentiate between participants of the same role.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ChatCompletionRequestUserMessage
instance A.FromJSON ChatCompletionRequestUserMessage where
  parseJSON = A.withObject "ChatCompletionRequestUserMessage" $ \o ->
    ChatCompletionRequestUserMessage
      <$> (o .:  "content")
      <*> (o .:  "role")
      <*> (o .:? "name")

-- | ToJSON ChatCompletionRequestUserMessage
instance A.ToJSON ChatCompletionRequestUserMessage where
  toJSON ChatCompletionRequestUserMessage {..} =
   _omitNulls
      [ "content" .= chatCompletionRequestUserMessageContent
      , "role" .= chatCompletionRequestUserMessageRole
      , "name" .= chatCompletionRequestUserMessageName
      ]


-- | Construct a value of type 'ChatCompletionRequestUserMessage' (by applying it's required fields, if any)
mkChatCompletionRequestUserMessage
  :: ChatCompletionRequestUserMessageContent -- ^ 'chatCompletionRequestUserMessageContent' 
  -> E'Role3 -- ^ 'chatCompletionRequestUserMessageRole': The role of the messages author, in this case `user`.
  -> ChatCompletionRequestUserMessage
mkChatCompletionRequestUserMessage chatCompletionRequestUserMessageContent chatCompletionRequestUserMessageRole =
  ChatCompletionRequestUserMessage
  { chatCompletionRequestUserMessageContent
  , chatCompletionRequestUserMessageRole
  , chatCompletionRequestUserMessageName = Nothing
  }

-- ** ChatCompletionRequestUserMessageContent
-- | ChatCompletionRequestUserMessageContent
-- The contents of the user message. 
data ChatCompletionRequestUserMessageContent = ChatCompletionRequestUserMessageContent
  { 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ChatCompletionRequestUserMessageContent
instance A.FromJSON ChatCompletionRequestUserMessageContent where
  parseJSON = A.withObject "ChatCompletionRequestUserMessageContent" $ \o ->
    pure ChatCompletionRequestUserMessageContent
      

-- | ToJSON ChatCompletionRequestUserMessageContent
instance A.ToJSON ChatCompletionRequestUserMessageContent where
  toJSON ChatCompletionRequestUserMessageContent  =
   _omitNulls
      [ 
      ]


-- | Construct a value of type 'ChatCompletionRequestUserMessageContent' (by applying it's required fields, if any)
mkChatCompletionRequestUserMessageContent
  :: ChatCompletionRequestUserMessageContent
mkChatCompletionRequestUserMessageContent =
  ChatCompletionRequestUserMessageContent
  { 
  }

-- ** ChatCompletionResponseMessage
-- | ChatCompletionResponseMessage
-- A chat completion message generated by the model.
data ChatCompletionResponseMessage = ChatCompletionResponseMessage
  { chatCompletionResponseMessageContent :: !(Text) -- ^ /Required/ "content" - The contents of the message.
  , chatCompletionResponseMessageToolCalls :: !(Maybe [ChatCompletionMessageToolCall]) -- ^ "tool_calls" - The tool calls generated by the model, such as function calls.
  , chatCompletionResponseMessageRole :: !(E'Role4) -- ^ /Required/ "role" - The role of the author of this message.
  , chatCompletionResponseMessageFunctionCall :: !(Maybe ChatCompletionRequestAssistantMessageFunctionCall) -- ^ "function_call"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ChatCompletionResponseMessage
instance A.FromJSON ChatCompletionResponseMessage where
  parseJSON = A.withObject "ChatCompletionResponseMessage" $ \o ->
    ChatCompletionResponseMessage
      <$> (o .:  "content")
      <*> (o .:? "tool_calls")
      <*> (o .:  "role")
      <*> (o .:? "function_call")

-- | ToJSON ChatCompletionResponseMessage
instance A.ToJSON ChatCompletionResponseMessage where
  toJSON ChatCompletionResponseMessage {..} =
   _omitNulls
      [ "content" .= chatCompletionResponseMessageContent
      , "tool_calls" .= chatCompletionResponseMessageToolCalls
      , "role" .= chatCompletionResponseMessageRole
      , "function_call" .= chatCompletionResponseMessageFunctionCall
      ]


-- | Construct a value of type 'ChatCompletionResponseMessage' (by applying it's required fields, if any)
mkChatCompletionResponseMessage
  :: Text -- ^ 'chatCompletionResponseMessageContent': The contents of the message.
  -> E'Role4 -- ^ 'chatCompletionResponseMessageRole': The role of the author of this message.
  -> ChatCompletionResponseMessage
mkChatCompletionResponseMessage chatCompletionResponseMessageContent chatCompletionResponseMessageRole =
  ChatCompletionResponseMessage
  { chatCompletionResponseMessageContent
  , chatCompletionResponseMessageToolCalls = Nothing
  , chatCompletionResponseMessageRole
  , chatCompletionResponseMessageFunctionCall = Nothing
  }

-- ** ChatCompletionStreamResponseDelta
-- | ChatCompletionStreamResponseDelta
-- A chat completion delta generated by streamed model responses.
data ChatCompletionStreamResponseDelta = ChatCompletionStreamResponseDelta
  { chatCompletionStreamResponseDeltaContent :: !(Maybe Text) -- ^ "content" - The contents of the chunk message.
  , chatCompletionStreamResponseDeltaFunctionCall :: !(Maybe ChatCompletionStreamResponseDeltaFunctionCall) -- ^ "function_call"
  , chatCompletionStreamResponseDeltaToolCalls :: !(Maybe [ChatCompletionMessageToolCallChunk]) -- ^ "tool_calls"
  , chatCompletionStreamResponseDeltaRole :: !(Maybe E'Role6) -- ^ "role" - The role of the author of this message.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ChatCompletionStreamResponseDelta
instance A.FromJSON ChatCompletionStreamResponseDelta where
  parseJSON = A.withObject "ChatCompletionStreamResponseDelta" $ \o ->
    ChatCompletionStreamResponseDelta
      <$> (o .:? "content")
      <*> (o .:? "function_call")
      <*> (o .:? "tool_calls")
      <*> (o .:? "role")

-- | ToJSON ChatCompletionStreamResponseDelta
instance A.ToJSON ChatCompletionStreamResponseDelta where
  toJSON ChatCompletionStreamResponseDelta {..} =
   _omitNulls
      [ "content" .= chatCompletionStreamResponseDeltaContent
      , "function_call" .= chatCompletionStreamResponseDeltaFunctionCall
      , "tool_calls" .= chatCompletionStreamResponseDeltaToolCalls
      , "role" .= chatCompletionStreamResponseDeltaRole
      ]


-- | Construct a value of type 'ChatCompletionStreamResponseDelta' (by applying it's required fields, if any)
mkChatCompletionStreamResponseDelta
  :: ChatCompletionStreamResponseDelta
mkChatCompletionStreamResponseDelta =
  ChatCompletionStreamResponseDelta
  { chatCompletionStreamResponseDeltaContent = Nothing
  , chatCompletionStreamResponseDeltaFunctionCall = Nothing
  , chatCompletionStreamResponseDeltaToolCalls = Nothing
  , chatCompletionStreamResponseDeltaRole = Nothing
  }

-- ** ChatCompletionStreamResponseDeltaFunctionCall
-- | ChatCompletionStreamResponseDeltaFunctionCall
-- Deprecated and replaced by `tool_calls`. The name and arguments of a function that should be called, as generated by the model.
data ChatCompletionStreamResponseDeltaFunctionCall = ChatCompletionStreamResponseDeltaFunctionCall
  { chatCompletionStreamResponseDeltaFunctionCallArguments :: !(Maybe Text) -- ^ "arguments" - The arguments to call the function with, as generated by the model in JSON format. Note that the model does not always generate valid JSON, and may hallucinate parameters not defined by your function schema. Validate the arguments in your code before calling your function.
  , chatCompletionStreamResponseDeltaFunctionCallName :: !(Maybe Text) -- ^ "name" - The name of the function to call.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ChatCompletionStreamResponseDeltaFunctionCall
instance A.FromJSON ChatCompletionStreamResponseDeltaFunctionCall where
  parseJSON = A.withObject "ChatCompletionStreamResponseDeltaFunctionCall" $ \o ->
    ChatCompletionStreamResponseDeltaFunctionCall
      <$> (o .:? "arguments")
      <*> (o .:? "name")

-- | ToJSON ChatCompletionStreamResponseDeltaFunctionCall
instance A.ToJSON ChatCompletionStreamResponseDeltaFunctionCall where
  toJSON ChatCompletionStreamResponseDeltaFunctionCall {..} =
   _omitNulls
      [ "arguments" .= chatCompletionStreamResponseDeltaFunctionCallArguments
      , "name" .= chatCompletionStreamResponseDeltaFunctionCallName
      ]


-- | Construct a value of type 'ChatCompletionStreamResponseDeltaFunctionCall' (by applying it's required fields, if any)
mkChatCompletionStreamResponseDeltaFunctionCall
  :: ChatCompletionStreamResponseDeltaFunctionCall
mkChatCompletionStreamResponseDeltaFunctionCall =
  ChatCompletionStreamResponseDeltaFunctionCall
  { chatCompletionStreamResponseDeltaFunctionCallArguments = Nothing
  , chatCompletionStreamResponseDeltaFunctionCallName = Nothing
  }

-- ** ChatCompletionTokenLogprob
-- | ChatCompletionTokenLogprob
data ChatCompletionTokenLogprob = ChatCompletionTokenLogprob
  { chatCompletionTokenLogprobToken :: !(Text) -- ^ /Required/ "token" - The token.
  , chatCompletionTokenLogprobLogprob :: !(Double) -- ^ /Required/ "logprob" - The log probability of this token, if it is within the top 20 most likely tokens. Otherwise, the value &#x60;-9999.0&#x60; is used to signify that the token is very unlikely.
  , chatCompletionTokenLogprobBytes :: !([Int]) -- ^ /Required/ "bytes" - A list of integers representing the UTF-8 bytes representation of the token. Useful in instances where characters are represented by multiple tokens and their byte representations must be combined to generate the correct text representation. Can be &#x60;null&#x60; if there is no bytes representation for the token.
  , chatCompletionTokenLogprobTopLogprobs :: !([ChatCompletionTokenLogprobTopLogprobsInner]) -- ^ /Required/ "top_logprobs" - List of the most likely tokens and their log probability, at this token position. In rare cases, there may be fewer than the number of requested &#x60;top_logprobs&#x60; returned.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ChatCompletionTokenLogprob
instance A.FromJSON ChatCompletionTokenLogprob where
  parseJSON = A.withObject "ChatCompletionTokenLogprob" $ \o ->
    ChatCompletionTokenLogprob
      <$> (o .:  "token")
      <*> (o .:  "logprob")
      <*> (o .:  "bytes")
      <*> (o .:  "top_logprobs")

-- | ToJSON ChatCompletionTokenLogprob
instance A.ToJSON ChatCompletionTokenLogprob where
  toJSON ChatCompletionTokenLogprob {..} =
   _omitNulls
      [ "token" .= chatCompletionTokenLogprobToken
      , "logprob" .= chatCompletionTokenLogprobLogprob
      , "bytes" .= chatCompletionTokenLogprobBytes
      , "top_logprobs" .= chatCompletionTokenLogprobTopLogprobs
      ]


-- | Construct a value of type 'ChatCompletionTokenLogprob' (by applying it's required fields, if any)
mkChatCompletionTokenLogprob
  :: Text -- ^ 'chatCompletionTokenLogprobToken': The token.
  -> Double -- ^ 'chatCompletionTokenLogprobLogprob': The log probability of this token, if it is within the top 20 most likely tokens. Otherwise, the value `-9999.0` is used to signify that the token is very unlikely.
  -> [Int] -- ^ 'chatCompletionTokenLogprobBytes': A list of integers representing the UTF-8 bytes representation of the token. Useful in instances where characters are represented by multiple tokens and their byte representations must be combined to generate the correct text representation. Can be `null` if there is no bytes representation for the token.
  -> [ChatCompletionTokenLogprobTopLogprobsInner] -- ^ 'chatCompletionTokenLogprobTopLogprobs': List of the most likely tokens and their log probability, at this token position. In rare cases, there may be fewer than the number of requested `top_logprobs` returned.
  -> ChatCompletionTokenLogprob
mkChatCompletionTokenLogprob chatCompletionTokenLogprobToken chatCompletionTokenLogprobLogprob chatCompletionTokenLogprobBytes chatCompletionTokenLogprobTopLogprobs =
  ChatCompletionTokenLogprob
  { chatCompletionTokenLogprobToken
  , chatCompletionTokenLogprobLogprob
  , chatCompletionTokenLogprobBytes
  , chatCompletionTokenLogprobTopLogprobs
  }

-- ** ChatCompletionTokenLogprobTopLogprobsInner
-- | ChatCompletionTokenLogprobTopLogprobsInner
data ChatCompletionTokenLogprobTopLogprobsInner = ChatCompletionTokenLogprobTopLogprobsInner
  { chatCompletionTokenLogprobTopLogprobsInnerToken :: !(Text) -- ^ /Required/ "token" - The token.
  , chatCompletionTokenLogprobTopLogprobsInnerLogprob :: !(Double) -- ^ /Required/ "logprob" - The log probability of this token, if it is within the top 20 most likely tokens. Otherwise, the value &#x60;-9999.0&#x60; is used to signify that the token is very unlikely.
  , chatCompletionTokenLogprobTopLogprobsInnerBytes :: !([Int]) -- ^ /Required/ "bytes" - A list of integers representing the UTF-8 bytes representation of the token. Useful in instances where characters are represented by multiple tokens and their byte representations must be combined to generate the correct text representation. Can be &#x60;null&#x60; if there is no bytes representation for the token.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ChatCompletionTokenLogprobTopLogprobsInner
instance A.FromJSON ChatCompletionTokenLogprobTopLogprobsInner where
  parseJSON = A.withObject "ChatCompletionTokenLogprobTopLogprobsInner" $ \o ->
    ChatCompletionTokenLogprobTopLogprobsInner
      <$> (o .:  "token")
      <*> (o .:  "logprob")
      <*> (o .:  "bytes")

-- | ToJSON ChatCompletionTokenLogprobTopLogprobsInner
instance A.ToJSON ChatCompletionTokenLogprobTopLogprobsInner where
  toJSON ChatCompletionTokenLogprobTopLogprobsInner {..} =
   _omitNulls
      [ "token" .= chatCompletionTokenLogprobTopLogprobsInnerToken
      , "logprob" .= chatCompletionTokenLogprobTopLogprobsInnerLogprob
      , "bytes" .= chatCompletionTokenLogprobTopLogprobsInnerBytes
      ]


-- | Construct a value of type 'ChatCompletionTokenLogprobTopLogprobsInner' (by applying it's required fields, if any)
mkChatCompletionTokenLogprobTopLogprobsInner
  :: Text -- ^ 'chatCompletionTokenLogprobTopLogprobsInnerToken': The token.
  -> Double -- ^ 'chatCompletionTokenLogprobTopLogprobsInnerLogprob': The log probability of this token, if it is within the top 20 most likely tokens. Otherwise, the value `-9999.0` is used to signify that the token is very unlikely.
  -> [Int] -- ^ 'chatCompletionTokenLogprobTopLogprobsInnerBytes': A list of integers representing the UTF-8 bytes representation of the token. Useful in instances where characters are represented by multiple tokens and their byte representations must be combined to generate the correct text representation. Can be `null` if there is no bytes representation for the token.
  -> ChatCompletionTokenLogprobTopLogprobsInner
mkChatCompletionTokenLogprobTopLogprobsInner chatCompletionTokenLogprobTopLogprobsInnerToken chatCompletionTokenLogprobTopLogprobsInnerLogprob chatCompletionTokenLogprobTopLogprobsInnerBytes =
  ChatCompletionTokenLogprobTopLogprobsInner
  { chatCompletionTokenLogprobTopLogprobsInnerToken
  , chatCompletionTokenLogprobTopLogprobsInnerLogprob
  , chatCompletionTokenLogprobTopLogprobsInnerBytes
  }

-- ** ChatCompletionTool
-- | ChatCompletionTool
data ChatCompletionTool = ChatCompletionTool
  { chatCompletionToolType :: !(E'Role) -- ^ /Required/ "type" - The type of the tool. Currently, only &#x60;function&#x60; is supported.
  , chatCompletionToolFunction :: !(FunctionObject) -- ^ /Required/ "function"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ChatCompletionTool
instance A.FromJSON ChatCompletionTool where
  parseJSON = A.withObject "ChatCompletionTool" $ \o ->
    ChatCompletionTool
      <$> (o .:  "type")
      <*> (o .:  "function")

-- | ToJSON ChatCompletionTool
instance A.ToJSON ChatCompletionTool where
  toJSON ChatCompletionTool {..} =
   _omitNulls
      [ "type" .= chatCompletionToolType
      , "function" .= chatCompletionToolFunction
      ]


-- | Construct a value of type 'ChatCompletionTool' (by applying it's required fields, if any)
mkChatCompletionTool
  :: E'Role -- ^ 'chatCompletionToolType': The type of the tool. Currently, only `function` is supported.
  -> FunctionObject -- ^ 'chatCompletionToolFunction' 
  -> ChatCompletionTool
mkChatCompletionTool chatCompletionToolType chatCompletionToolFunction =
  ChatCompletionTool
  { chatCompletionToolType
  , chatCompletionToolFunction
  }

-- ** ChatCompletionToolChoiceOption
-- | ChatCompletionToolChoiceOption
-- Controls which (if any) function is called by the model. `none` means the model will not call a function and instead generates a message. `auto` means the model can pick between generating a message or calling a function. Specifying a particular function via `{\"type\": \"function\", \"function\": {\"name\": \"my_function\"}}` forces the model to call that function.  `none` is the default when no functions are present. `auto` is the default if functions are present. 
data ChatCompletionToolChoiceOption = ChatCompletionToolChoiceOption
  { chatCompletionToolChoiceOptionType :: !(E'Role) -- ^ /Required/ "type" - The type of the tool. Currently, only &#x60;function&#x60; is supported.
  , chatCompletionToolChoiceOptionFunction :: !(ChatCompletionNamedToolChoiceFunction) -- ^ /Required/ "function"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ChatCompletionToolChoiceOption
instance A.FromJSON ChatCompletionToolChoiceOption where
  parseJSON = A.withObject "ChatCompletionToolChoiceOption" $ \o ->
    ChatCompletionToolChoiceOption
      <$> (o .:  "type")
      <*> (o .:  "function")

-- | ToJSON ChatCompletionToolChoiceOption
instance A.ToJSON ChatCompletionToolChoiceOption where
  toJSON ChatCompletionToolChoiceOption {..} =
   _omitNulls
      [ "type" .= chatCompletionToolChoiceOptionType
      , "function" .= chatCompletionToolChoiceOptionFunction
      ]


-- | Construct a value of type 'ChatCompletionToolChoiceOption' (by applying it's required fields, if any)
mkChatCompletionToolChoiceOption
  :: E'Role -- ^ 'chatCompletionToolChoiceOptionType': The type of the tool. Currently, only `function` is supported.
  -> ChatCompletionNamedToolChoiceFunction -- ^ 'chatCompletionToolChoiceOptionFunction' 
  -> ChatCompletionToolChoiceOption
mkChatCompletionToolChoiceOption chatCompletionToolChoiceOptionType chatCompletionToolChoiceOptionFunction =
  ChatCompletionToolChoiceOption
  { chatCompletionToolChoiceOptionType
  , chatCompletionToolChoiceOptionFunction
  }

-- ** CompletionUsage
-- | CompletionUsage
-- Usage statistics for the completion request.
data CompletionUsage = CompletionUsage
  { completionUsageCompletionTokens :: !(Int) -- ^ /Required/ "completion_tokens" - Number of tokens in the generated completion.
  , completionUsagePromptTokens :: !(Int) -- ^ /Required/ "prompt_tokens" - Number of tokens in the prompt.
  , completionUsageTotalTokens :: !(Int) -- ^ /Required/ "total_tokens" - Total number of tokens used in the request (prompt + completion).
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CompletionUsage
instance A.FromJSON CompletionUsage where
  parseJSON = A.withObject "CompletionUsage" $ \o ->
    CompletionUsage
      <$> (o .:  "completion_tokens")
      <*> (o .:  "prompt_tokens")
      <*> (o .:  "total_tokens")

-- | ToJSON CompletionUsage
instance A.ToJSON CompletionUsage where
  toJSON CompletionUsage {..} =
   _omitNulls
      [ "completion_tokens" .= completionUsageCompletionTokens
      , "prompt_tokens" .= completionUsagePromptTokens
      , "total_tokens" .= completionUsageTotalTokens
      ]


-- | Construct a value of type 'CompletionUsage' (by applying it's required fields, if any)
mkCompletionUsage
  :: Int -- ^ 'completionUsageCompletionTokens': Number of tokens in the generated completion.
  -> Int -- ^ 'completionUsagePromptTokens': Number of tokens in the prompt.
  -> Int -- ^ 'completionUsageTotalTokens': Total number of tokens used in the request (prompt + completion).
  -> CompletionUsage
mkCompletionUsage completionUsageCompletionTokens completionUsagePromptTokens completionUsageTotalTokens =
  CompletionUsage
  { completionUsageCompletionTokens
  , completionUsagePromptTokens
  , completionUsageTotalTokens
  }

-- ** CreateAssistantFileRequest
-- | CreateAssistantFileRequest
data CreateAssistantFileRequest = CreateAssistantFileRequest
  { createAssistantFileRequestFileId :: !(Text) -- ^ /Required/ "file_id" - A [File](/docs/api-reference/files) ID (with &#x60;purpose&#x3D;\&quot;assistants\&quot;&#x60;) that the assistant should use. Useful for tools like &#x60;retrieval&#x60; and &#x60;code_interpreter&#x60; that can access files.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateAssistantFileRequest
instance A.FromJSON CreateAssistantFileRequest where
  parseJSON = A.withObject "CreateAssistantFileRequest" $ \o ->
    CreateAssistantFileRequest
      <$> (o .:  "file_id")

-- | ToJSON CreateAssistantFileRequest
instance A.ToJSON CreateAssistantFileRequest where
  toJSON CreateAssistantFileRequest {..} =
   _omitNulls
      [ "file_id" .= createAssistantFileRequestFileId
      ]


-- | Construct a value of type 'CreateAssistantFileRequest' (by applying it's required fields, if any)
mkCreateAssistantFileRequest
  :: Text -- ^ 'createAssistantFileRequestFileId': A [File](/docs/api-reference/files) ID (with `purpose=\"assistants\"`) that the assistant should use. Useful for tools like `retrieval` and `code_interpreter` that can access files.
  -> CreateAssistantFileRequest
mkCreateAssistantFileRequest createAssistantFileRequestFileId =
  CreateAssistantFileRequest
  { createAssistantFileRequestFileId
  }

-- ** CreateAssistantRequest
-- | CreateAssistantRequest
data CreateAssistantRequest = CreateAssistantRequest
  { createAssistantRequestModel :: !(CreateAssistantRequestModel) -- ^ /Required/ "model"
  , createAssistantRequestName :: !(Maybe Text) -- ^ "name" - The name of the assistant. The maximum length is 256 characters. 
  , createAssistantRequestDescription :: !(Maybe Text) -- ^ "description" - The description of the assistant. The maximum length is 512 characters. 
  , createAssistantRequestInstructions :: !(Maybe Text) -- ^ "instructions" - The system instructions that the assistant uses. The maximum length is 32768 characters. 
  , createAssistantRequestTools :: !(Maybe [AssistantObjectToolsInner]) -- ^ "tools" - A list of tool enabled on the assistant. There can be a maximum of 128 tools per assistant. Tools can be of types &#x60;code_interpreter&#x60;, &#x60;retrieval&#x60;, or &#x60;function&#x60;. 
  , createAssistantRequestFileIds :: !(Maybe [Text]) -- ^ "file_ids" - A list of [file](/docs/api-reference/files) IDs attached to this assistant. There can be a maximum of 20 files attached to the assistant. Files are ordered by their creation date in ascending order. 
  , createAssistantRequestMetadata :: !(Maybe A.Value) -- ^ "metadata" - Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateAssistantRequest
instance A.FromJSON CreateAssistantRequest where
  parseJSON = A.withObject "CreateAssistantRequest" $ \o ->
    CreateAssistantRequest
      <$> (o .:  "model")
      <*> (o .:? "name")
      <*> (o .:? "description")
      <*> (o .:? "instructions")
      <*> (o .:? "tools")
      <*> (o .:? "file_ids")
      <*> (o .:? "metadata")

-- | ToJSON CreateAssistantRequest
instance A.ToJSON CreateAssistantRequest where
  toJSON CreateAssistantRequest {..} =
   _omitNulls
      [ "model" .= createAssistantRequestModel
      , "name" .= createAssistantRequestName
      , "description" .= createAssistantRequestDescription
      , "instructions" .= createAssistantRequestInstructions
      , "tools" .= createAssistantRequestTools
      , "file_ids" .= createAssistantRequestFileIds
      , "metadata" .= createAssistantRequestMetadata
      ]


-- | Construct a value of type 'CreateAssistantRequest' (by applying it's required fields, if any)
mkCreateAssistantRequest
  :: CreateAssistantRequestModel -- ^ 'createAssistantRequestModel' 
  -> CreateAssistantRequest
mkCreateAssistantRequest createAssistantRequestModel =
  CreateAssistantRequest
  { createAssistantRequestModel
  , createAssistantRequestName = Nothing
  , createAssistantRequestDescription = Nothing
  , createAssistantRequestInstructions = Nothing
  , createAssistantRequestTools = Nothing
  , createAssistantRequestFileIds = Nothing
  , createAssistantRequestMetadata = Nothing
  }

-- ** CreateAssistantRequestModel
-- | CreateAssistantRequestModel
-- ID of the model to use. You can use the [List models](/docs/api-reference/models/list) API to see all of your available models, or see our [Model overview](/docs/models/overview) for descriptions of them. 
data CreateAssistantRequestModel = CreateAssistantRequestModel
  { 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateAssistantRequestModel
instance A.FromJSON CreateAssistantRequestModel where
  parseJSON = A.withObject "CreateAssistantRequestModel" $ \o ->
    pure CreateAssistantRequestModel
      

-- | ToJSON CreateAssistantRequestModel
instance A.ToJSON CreateAssistantRequestModel where
  toJSON CreateAssistantRequestModel  =
   _omitNulls
      [ 
      ]


-- | Construct a value of type 'CreateAssistantRequestModel' (by applying it's required fields, if any)
mkCreateAssistantRequestModel
  :: CreateAssistantRequestModel
mkCreateAssistantRequestModel =
  CreateAssistantRequestModel
  { 
  }

-- ** CreateChatCompletionFunctionResponse
-- | CreateChatCompletionFunctionResponse
-- Represents a chat completion response returned by model, based on the provided input.
data CreateChatCompletionFunctionResponse = CreateChatCompletionFunctionResponse
  { createChatCompletionFunctionResponseId :: !(Text) -- ^ /Required/ "id" - A unique identifier for the chat completion.
  , createChatCompletionFunctionResponseChoices :: !([CreateChatCompletionFunctionResponseChoicesInner]) -- ^ /Required/ "choices" - A list of chat completion choices. Can be more than one if &#x60;n&#x60; is greater than 1.
  , createChatCompletionFunctionResponseCreated :: !(Int) -- ^ /Required/ "created" - The Unix timestamp (in seconds) of when the chat completion was created.
  , createChatCompletionFunctionResponseModel :: !(Text) -- ^ /Required/ "model" - The model used for the chat completion.
  , createChatCompletionFunctionResponseSystemFingerprint :: !(Maybe Text) -- ^ "system_fingerprint" - This fingerprint represents the backend configuration that the model runs with.  Can be used in conjunction with the &#x60;seed&#x60; request parameter to understand when backend changes have been made that might impact determinism. 
  , createChatCompletionFunctionResponseObject :: !(E'Object3) -- ^ /Required/ "object" - The object type, which is always &#x60;chat.completion&#x60;.
  , createChatCompletionFunctionResponseUsage :: !(Maybe CompletionUsage) -- ^ "usage"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateChatCompletionFunctionResponse
instance A.FromJSON CreateChatCompletionFunctionResponse where
  parseJSON = A.withObject "CreateChatCompletionFunctionResponse" $ \o ->
    CreateChatCompletionFunctionResponse
      <$> (o .:  "id")
      <*> (o .:  "choices")
      <*> (o .:  "created")
      <*> (o .:  "model")
      <*> (o .:? "system_fingerprint")
      <*> (o .:  "object")
      <*> (o .:? "usage")

-- | ToJSON CreateChatCompletionFunctionResponse
instance A.ToJSON CreateChatCompletionFunctionResponse where
  toJSON CreateChatCompletionFunctionResponse {..} =
   _omitNulls
      [ "id" .= createChatCompletionFunctionResponseId
      , "choices" .= createChatCompletionFunctionResponseChoices
      , "created" .= createChatCompletionFunctionResponseCreated
      , "model" .= createChatCompletionFunctionResponseModel
      , "system_fingerprint" .= createChatCompletionFunctionResponseSystemFingerprint
      , "object" .= createChatCompletionFunctionResponseObject
      , "usage" .= createChatCompletionFunctionResponseUsage
      ]


-- | Construct a value of type 'CreateChatCompletionFunctionResponse' (by applying it's required fields, if any)
mkCreateChatCompletionFunctionResponse
  :: Text -- ^ 'createChatCompletionFunctionResponseId': A unique identifier for the chat completion.
  -> [CreateChatCompletionFunctionResponseChoicesInner] -- ^ 'createChatCompletionFunctionResponseChoices': A list of chat completion choices. Can be more than one if `n` is greater than 1.
  -> Int -- ^ 'createChatCompletionFunctionResponseCreated': The Unix timestamp (in seconds) of when the chat completion was created.
  -> Text -- ^ 'createChatCompletionFunctionResponseModel': The model used for the chat completion.
  -> E'Object3 -- ^ 'createChatCompletionFunctionResponseObject': The object type, which is always `chat.completion`.
  -> CreateChatCompletionFunctionResponse
mkCreateChatCompletionFunctionResponse createChatCompletionFunctionResponseId createChatCompletionFunctionResponseChoices createChatCompletionFunctionResponseCreated createChatCompletionFunctionResponseModel createChatCompletionFunctionResponseObject =
  CreateChatCompletionFunctionResponse
  { createChatCompletionFunctionResponseId
  , createChatCompletionFunctionResponseChoices
  , createChatCompletionFunctionResponseCreated
  , createChatCompletionFunctionResponseModel
  , createChatCompletionFunctionResponseSystemFingerprint = Nothing
  , createChatCompletionFunctionResponseObject
  , createChatCompletionFunctionResponseUsage = Nothing
  }

-- ** CreateChatCompletionFunctionResponseChoicesInner
-- | CreateChatCompletionFunctionResponseChoicesInner
data CreateChatCompletionFunctionResponseChoicesInner = CreateChatCompletionFunctionResponseChoicesInner
  { createChatCompletionFunctionResponseChoicesInnerFinishReason :: !(E'FinishReason3) -- ^ /Required/ "finish_reason" - The reason the model stopped generating tokens. This will be &#x60;stop&#x60; if the model hit a natural stop point or a provided stop sequence, &#x60;length&#x60; if the maximum number of tokens specified in the request was reached, &#x60;content_filter&#x60; if content was omitted due to a flag from our content filters, or &#x60;function_call&#x60; if the model called a function. 
  , createChatCompletionFunctionResponseChoicesInnerIndex :: !(Int) -- ^ /Required/ "index" - The index of the choice in the list of choices.
  , createChatCompletionFunctionResponseChoicesInnerMessage :: !(ChatCompletionResponseMessage) -- ^ /Required/ "message"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateChatCompletionFunctionResponseChoicesInner
instance A.FromJSON CreateChatCompletionFunctionResponseChoicesInner where
  parseJSON = A.withObject "CreateChatCompletionFunctionResponseChoicesInner" $ \o ->
    CreateChatCompletionFunctionResponseChoicesInner
      <$> (o .:  "finish_reason")
      <*> (o .:  "index")
      <*> (o .:  "message")

-- | ToJSON CreateChatCompletionFunctionResponseChoicesInner
instance A.ToJSON CreateChatCompletionFunctionResponseChoicesInner where
  toJSON CreateChatCompletionFunctionResponseChoicesInner {..} =
   _omitNulls
      [ "finish_reason" .= createChatCompletionFunctionResponseChoicesInnerFinishReason
      , "index" .= createChatCompletionFunctionResponseChoicesInnerIndex
      , "message" .= createChatCompletionFunctionResponseChoicesInnerMessage
      ]


-- | Construct a value of type 'CreateChatCompletionFunctionResponseChoicesInner' (by applying it's required fields, if any)
mkCreateChatCompletionFunctionResponseChoicesInner
  :: E'FinishReason3 -- ^ 'createChatCompletionFunctionResponseChoicesInnerFinishReason': The reason the model stopped generating tokens. This will be `stop` if the model hit a natural stop point or a provided stop sequence, `length` if the maximum number of tokens specified in the request was reached, `content_filter` if content was omitted due to a flag from our content filters, or `function_call` if the model called a function. 
  -> Int -- ^ 'createChatCompletionFunctionResponseChoicesInnerIndex': The index of the choice in the list of choices.
  -> ChatCompletionResponseMessage -- ^ 'createChatCompletionFunctionResponseChoicesInnerMessage' 
  -> CreateChatCompletionFunctionResponseChoicesInner
mkCreateChatCompletionFunctionResponseChoicesInner createChatCompletionFunctionResponseChoicesInnerFinishReason createChatCompletionFunctionResponseChoicesInnerIndex createChatCompletionFunctionResponseChoicesInnerMessage =
  CreateChatCompletionFunctionResponseChoicesInner
  { createChatCompletionFunctionResponseChoicesInnerFinishReason
  , createChatCompletionFunctionResponseChoicesInnerIndex
  , createChatCompletionFunctionResponseChoicesInnerMessage
  }

-- ** CreateChatCompletionRequest
-- | CreateChatCompletionRequest
data CreateChatCompletionRequest = CreateChatCompletionRequest
  { createChatCompletionRequestMessages :: !([ChatCompletionRequestMessage]) -- ^ /Required/ "messages" - A list of messages comprising the conversation so far. [Example Python code](https://cookbook.openai.com/examples/how_to_format_inputs_to_chatgpt_models).
  , createChatCompletionRequestModel :: !(CreateChatCompletionRequestModel) -- ^ /Required/ "model"
  , createChatCompletionRequestFrequencyPenalty :: !(Maybe Double) -- ^ "frequency_penalty" - Number between -2.0 and 2.0. Positive values penalize new tokens based on their existing frequency in the text so far, decreasing the model&#39;s likelihood to repeat the same line verbatim.  [See more information about frequency and presence penalties.](/docs/guides/text-generation/parameter-details) 
  , createChatCompletionRequestLogitBias :: !(Maybe (Map.Map String Int)) -- ^ "logit_bias" - Modify the likelihood of specified tokens appearing in the completion.  Accepts a JSON object that maps tokens (specified by their token ID in the tokenizer) to an associated bias value from -100 to 100. Mathematically, the bias is added to the logits generated by the model prior to sampling. The exact effect will vary per model, but values between -1 and 1 should decrease or increase likelihood of selection; values like -100 or 100 should result in a ban or exclusive selection of the relevant token. 
  , createChatCompletionRequestLogprobs :: !(Maybe Bool) -- ^ "logprobs" - Whether to return log probabilities of the output tokens or not. If true, returns the log probabilities of each output token returned in the &#x60;content&#x60; of &#x60;message&#x60;. This option is currently not available on the &#x60;gpt-4-vision-preview&#x60; model.
  , createChatCompletionRequestTopLogprobs :: !(Maybe Int) -- ^ "top_logprobs" - An integer between 0 and 20 specifying the number of most likely tokens to return at each token position, each with an associated log probability. &#x60;logprobs&#x60; must be set to &#x60;true&#x60; if this parameter is used.
  , createChatCompletionRequestMaxTokens :: !(Maybe Int) -- ^ "max_tokens" - The maximum number of [tokens](/tokenizer) that can be generated in the chat completion.  The total length of input tokens and generated tokens is limited by the model&#39;s context length. [Example Python code](https://cookbook.openai.com/examples/how_to_count_tokens_with_tiktoken) for counting tokens. 
  , createChatCompletionRequestN :: !(Maybe Int) -- ^ "n" - How many chat completion choices to generate for each input message. Note that you will be charged based on the number of generated tokens across all of the choices. Keep &#x60;n&#x60; as &#x60;1&#x60; to minimize costs.
  , createChatCompletionRequestPresencePenalty :: !(Maybe Double) -- ^ "presence_penalty" - Number between -2.0 and 2.0. Positive values penalize new tokens based on whether they appear in the text so far, increasing the model&#39;s likelihood to talk about new topics.  [See more information about frequency and presence penalties.](/docs/guides/text-generation/parameter-details) 
  , createChatCompletionRequestResponseFormat :: !(Maybe CreateChatCompletionRequestResponseFormat) -- ^ "response_format"
  , createChatCompletionRequestSeed :: !(Maybe Int) -- ^ "seed" - This feature is in Beta. If specified, our system will make a best effort to sample deterministically, such that repeated requests with the same &#x60;seed&#x60; and parameters should return the same result. Determinism is not guaranteed, and you should refer to the &#x60;system_fingerprint&#x60; response parameter to monitor changes in the backend. 
  , createChatCompletionRequestStop :: !(Maybe CreateChatCompletionRequestStop) -- ^ "stop"
  , createChatCompletionRequestStream :: !(Maybe Bool) -- ^ "stream" - If set, partial message deltas will be sent, like in ChatGPT. Tokens will be sent as data-only [server-sent events](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events#Event_stream_format) as they become available, with the stream terminated by a &#x60;data: [DONE]&#x60; message. [Example Python code](https://cookbook.openai.com/examples/how_to_stream_completions). 
  , createChatCompletionRequestTemperature :: !(Maybe Double) -- ^ "temperature" - What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.  We generally recommend altering this or &#x60;top_p&#x60; but not both. 
  , createChatCompletionRequestTopP :: !(Maybe Double) -- ^ "top_p" - An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass. So 0.1 means only the tokens comprising the top 10% probability mass are considered.  We generally recommend altering this or &#x60;temperature&#x60; but not both. 
  , createChatCompletionRequestTools :: !(Maybe [ChatCompletionTool]) -- ^ "tools" - A list of tools the model may call. Currently, only functions are supported as a tool. Use this to provide a list of functions the model may generate JSON inputs for. 
  , createChatCompletionRequestToolChoice :: !(Maybe ChatCompletionToolChoiceOption) -- ^ "tool_choice"
  , createChatCompletionRequestUser :: !(Maybe Text) -- ^ "user" - A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse. [Learn more](/docs/guides/safety-best-practices/end-user-ids). 
  , createChatCompletionRequestFunctionCall :: !(Maybe CreateChatCompletionRequestFunctionCall) -- ^ "function_call"
  , createChatCompletionRequestFunctions :: !(Maybe [ChatCompletionFunctions]) -- ^ "functions" - Deprecated in favor of &#x60;tools&#x60;.  A list of functions the model may generate JSON inputs for. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateChatCompletionRequest
instance A.FromJSON CreateChatCompletionRequest where
  parseJSON = A.withObject "CreateChatCompletionRequest" $ \o ->
    CreateChatCompletionRequest
      <$> (o .:  "messages")
      <*> (o .:  "model")
      <*> (o .:? "frequency_penalty")
      <*> (o .:? "logit_bias")
      <*> (o .:? "logprobs")
      <*> (o .:? "top_logprobs")
      <*> (o .:? "max_tokens")
      <*> (o .:? "n")
      <*> (o .:? "presence_penalty")
      <*> (o .:? "response_format")
      <*> (o .:? "seed")
      <*> (o .:? "stop")
      <*> (o .:? "stream")
      <*> (o .:? "temperature")
      <*> (o .:? "top_p")
      <*> (o .:? "tools")
      <*> (o .:? "tool_choice")
      <*> (o .:? "user")
      <*> (o .:? "function_call")
      <*> (o .:? "functions")

-- | ToJSON CreateChatCompletionRequest
instance A.ToJSON CreateChatCompletionRequest where
  toJSON CreateChatCompletionRequest {..} =
   _omitNulls
      [ "messages" .= createChatCompletionRequestMessages
      , "model" .= createChatCompletionRequestModel
      , "frequency_penalty" .= createChatCompletionRequestFrequencyPenalty
      , "logit_bias" .= createChatCompletionRequestLogitBias
      , "logprobs" .= createChatCompletionRequestLogprobs
      , "top_logprobs" .= createChatCompletionRequestTopLogprobs
      , "max_tokens" .= createChatCompletionRequestMaxTokens
      , "n" .= createChatCompletionRequestN
      , "presence_penalty" .= createChatCompletionRequestPresencePenalty
      , "response_format" .= createChatCompletionRequestResponseFormat
      , "seed" .= createChatCompletionRequestSeed
      , "stop" .= createChatCompletionRequestStop
      , "stream" .= createChatCompletionRequestStream
      , "temperature" .= createChatCompletionRequestTemperature
      , "top_p" .= createChatCompletionRequestTopP
      , "tools" .= createChatCompletionRequestTools
      , "tool_choice" .= createChatCompletionRequestToolChoice
      , "user" .= createChatCompletionRequestUser
      , "function_call" .= createChatCompletionRequestFunctionCall
      , "functions" .= createChatCompletionRequestFunctions
      ]


-- | Construct a value of type 'CreateChatCompletionRequest' (by applying it's required fields, if any)
mkCreateChatCompletionRequest
  :: [ChatCompletionRequestMessage] -- ^ 'createChatCompletionRequestMessages': A list of messages comprising the conversation so far. [Example Python code](https://cookbook.openai.com/examples/how_to_format_inputs_to_chatgpt_models).
  -> CreateChatCompletionRequestModel -- ^ 'createChatCompletionRequestModel' 
  -> CreateChatCompletionRequest
mkCreateChatCompletionRequest createChatCompletionRequestMessages createChatCompletionRequestModel =
  CreateChatCompletionRequest
  { createChatCompletionRequestMessages
  , createChatCompletionRequestModel
  , createChatCompletionRequestFrequencyPenalty = Nothing
  , createChatCompletionRequestLogitBias = Nothing
  , createChatCompletionRequestLogprobs = Nothing
  , createChatCompletionRequestTopLogprobs = Nothing
  , createChatCompletionRequestMaxTokens = Nothing
  , createChatCompletionRequestN = Nothing
  , createChatCompletionRequestPresencePenalty = Nothing
  , createChatCompletionRequestResponseFormat = Nothing
  , createChatCompletionRequestSeed = Nothing
  , createChatCompletionRequestStop = Nothing
  , createChatCompletionRequestStream = Nothing
  , createChatCompletionRequestTemperature = Nothing
  , createChatCompletionRequestTopP = Nothing
  , createChatCompletionRequestTools = Nothing
  , createChatCompletionRequestToolChoice = Nothing
  , createChatCompletionRequestUser = Nothing
  , createChatCompletionRequestFunctionCall = Nothing
  , createChatCompletionRequestFunctions = Nothing
  }

-- ** CreateChatCompletionRequestFunctionCall
-- | CreateChatCompletionRequestFunctionCall
-- Deprecated in favor of `tool_choice`.  Controls which (if any) function is called by the model. `none` means the model will not call a function and instead generates a message. `auto` means the model can pick between generating a message or calling a function. Specifying a particular function via `{\"name\": \"my_function\"}` forces the model to call that function.  `none` is the default when no functions are present. `auto` is the default if functions are present. 
data CreateChatCompletionRequestFunctionCall = CreateChatCompletionRequestFunctionCall
  { createChatCompletionRequestFunctionCallName :: !(Text) -- ^ /Required/ "name" - The name of the function to call.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateChatCompletionRequestFunctionCall
instance A.FromJSON CreateChatCompletionRequestFunctionCall where
  parseJSON = A.withObject "CreateChatCompletionRequestFunctionCall" $ \o ->
    CreateChatCompletionRequestFunctionCall
      <$> (o .:  "name")

-- | ToJSON CreateChatCompletionRequestFunctionCall
instance A.ToJSON CreateChatCompletionRequestFunctionCall where
  toJSON CreateChatCompletionRequestFunctionCall {..} =
   _omitNulls
      [ "name" .= createChatCompletionRequestFunctionCallName
      ]


-- | Construct a value of type 'CreateChatCompletionRequestFunctionCall' (by applying it's required fields, if any)
mkCreateChatCompletionRequestFunctionCall
  :: Text -- ^ 'createChatCompletionRequestFunctionCallName': The name of the function to call.
  -> CreateChatCompletionRequestFunctionCall
mkCreateChatCompletionRequestFunctionCall createChatCompletionRequestFunctionCallName =
  CreateChatCompletionRequestFunctionCall
  { createChatCompletionRequestFunctionCallName
  }

-- ** CreateChatCompletionRequestModel
-- | CreateChatCompletionRequestModel
-- ID of the model to use. See the [model endpoint compatibility](/docs/models/model-endpoint-compatibility) table for details on which models work with the Chat API.
data CreateChatCompletionRequestModel = CreateChatCompletionRequestModel
  { 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateChatCompletionRequestModel
instance A.FromJSON CreateChatCompletionRequestModel where
  parseJSON = A.withObject "CreateChatCompletionRequestModel" $ \o ->
    pure CreateChatCompletionRequestModel
      

-- | ToJSON CreateChatCompletionRequestModel
instance A.ToJSON CreateChatCompletionRequestModel where
  toJSON CreateChatCompletionRequestModel  =
   _omitNulls
      [ 
      ]


-- | Construct a value of type 'CreateChatCompletionRequestModel' (by applying it's required fields, if any)
mkCreateChatCompletionRequestModel
  :: CreateChatCompletionRequestModel
mkCreateChatCompletionRequestModel =
  CreateChatCompletionRequestModel
  { 
  }

-- ** CreateChatCompletionRequestResponseFormat
-- | CreateChatCompletionRequestResponseFormat
-- An object specifying the format that the model must output. Compatible with [GPT-4 Turbo](/docs/models/gpt-4-and-gpt-4-turbo) and all GPT-3.5 Turbo models newer than `gpt-3.5-turbo-1106`.  Setting to `{ \"type\": \"json_object\" }` enables JSON mode, which guarantees the message the model generates is valid JSON.  **Important:** when using JSON mode, you **must** also instruct the model to produce JSON yourself via a system or user message. Without this, the model may generate an unending stream of whitespace until the generation reaches the token limit, resulting in a long-running and seemingly \"stuck\" request. Also note that the message content may be partially cut off if `finish_reason=\"length\"`, which indicates the generation exceeded `max_tokens` or the conversation exceeded the max context length. 
data CreateChatCompletionRequestResponseFormat = CreateChatCompletionRequestResponseFormat
  { createChatCompletionRequestResponseFormatType :: !(Maybe E'Type13) -- ^ "type" - Must be one of &#x60;text&#x60; or &#x60;json_object&#x60;.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateChatCompletionRequestResponseFormat
instance A.FromJSON CreateChatCompletionRequestResponseFormat where
  parseJSON = A.withObject "CreateChatCompletionRequestResponseFormat" $ \o ->
    CreateChatCompletionRequestResponseFormat
      <$> (o .:? "type")

-- | ToJSON CreateChatCompletionRequestResponseFormat
instance A.ToJSON CreateChatCompletionRequestResponseFormat where
  toJSON CreateChatCompletionRequestResponseFormat {..} =
   _omitNulls
      [ "type" .= createChatCompletionRequestResponseFormatType
      ]


-- | Construct a value of type 'CreateChatCompletionRequestResponseFormat' (by applying it's required fields, if any)
mkCreateChatCompletionRequestResponseFormat
  :: CreateChatCompletionRequestResponseFormat
mkCreateChatCompletionRequestResponseFormat =
  CreateChatCompletionRequestResponseFormat
  { createChatCompletionRequestResponseFormatType = Nothing
  }

-- ** CreateChatCompletionRequestStop
-- | CreateChatCompletionRequestStop
-- Up to 4 sequences where the API will stop generating further tokens. 
data CreateChatCompletionRequestStop = CreateChatCompletionRequestStop
  { 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateChatCompletionRequestStop
instance A.FromJSON CreateChatCompletionRequestStop where
  parseJSON = A.withObject "CreateChatCompletionRequestStop" $ \o ->
    pure CreateChatCompletionRequestStop
      

-- | ToJSON CreateChatCompletionRequestStop
instance A.ToJSON CreateChatCompletionRequestStop where
  toJSON CreateChatCompletionRequestStop  =
   _omitNulls
      [ 
      ]


-- | Construct a value of type 'CreateChatCompletionRequestStop' (by applying it's required fields, if any)
mkCreateChatCompletionRequestStop
  :: CreateChatCompletionRequestStop
mkCreateChatCompletionRequestStop =
  CreateChatCompletionRequestStop
  { 
  }

-- ** CreateChatCompletionResponse
-- | CreateChatCompletionResponse
-- Represents a chat completion response returned by model, based on the provided input.
data CreateChatCompletionResponse = CreateChatCompletionResponse
  { createChatCompletionResponseId :: !(Text) -- ^ /Required/ "id" - A unique identifier for the chat completion.
  , createChatCompletionResponseChoices :: !([CreateChatCompletionResponseChoicesInner]) -- ^ /Required/ "choices" - A list of chat completion choices. Can be more than one if &#x60;n&#x60; is greater than 1.
  , createChatCompletionResponseCreated :: !(Int) -- ^ /Required/ "created" - The Unix timestamp (in seconds) of when the chat completion was created.
  , createChatCompletionResponseModel :: !(Text) -- ^ /Required/ "model" - The model used for the chat completion.
  , createChatCompletionResponseSystemFingerprint :: !(Maybe Text) -- ^ "system_fingerprint" - This fingerprint represents the backend configuration that the model runs with.  Can be used in conjunction with the &#x60;seed&#x60; request parameter to understand when backend changes have been made that might impact determinism. 
  , createChatCompletionResponseObject :: !(E'Object3) -- ^ /Required/ "object" - The object type, which is always &#x60;chat.completion&#x60;.
  , createChatCompletionResponseUsage :: !(Maybe CompletionUsage) -- ^ "usage"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateChatCompletionResponse
instance A.FromJSON CreateChatCompletionResponse where
  parseJSON = A.withObject "CreateChatCompletionResponse" $ \o ->
    CreateChatCompletionResponse
      <$> (o .:  "id")
      <*> (o .:  "choices")
      <*> (o .:  "created")
      <*> (o .:  "model")
      <*> (o .:? "system_fingerprint")
      <*> (o .:  "object")
      <*> (o .:? "usage")

-- | ToJSON CreateChatCompletionResponse
instance A.ToJSON CreateChatCompletionResponse where
  toJSON CreateChatCompletionResponse {..} =
   _omitNulls
      [ "id" .= createChatCompletionResponseId
      , "choices" .= createChatCompletionResponseChoices
      , "created" .= createChatCompletionResponseCreated
      , "model" .= createChatCompletionResponseModel
      , "system_fingerprint" .= createChatCompletionResponseSystemFingerprint
      , "object" .= createChatCompletionResponseObject
      , "usage" .= createChatCompletionResponseUsage
      ]


-- | Construct a value of type 'CreateChatCompletionResponse' (by applying it's required fields, if any)
mkCreateChatCompletionResponse
  :: Text -- ^ 'createChatCompletionResponseId': A unique identifier for the chat completion.
  -> [CreateChatCompletionResponseChoicesInner] -- ^ 'createChatCompletionResponseChoices': A list of chat completion choices. Can be more than one if `n` is greater than 1.
  -> Int -- ^ 'createChatCompletionResponseCreated': The Unix timestamp (in seconds) of when the chat completion was created.
  -> Text -- ^ 'createChatCompletionResponseModel': The model used for the chat completion.
  -> E'Object3 -- ^ 'createChatCompletionResponseObject': The object type, which is always `chat.completion`.
  -> CreateChatCompletionResponse
mkCreateChatCompletionResponse createChatCompletionResponseId createChatCompletionResponseChoices createChatCompletionResponseCreated createChatCompletionResponseModel createChatCompletionResponseObject =
  CreateChatCompletionResponse
  { createChatCompletionResponseId
  , createChatCompletionResponseChoices
  , createChatCompletionResponseCreated
  , createChatCompletionResponseModel
  , createChatCompletionResponseSystemFingerprint = Nothing
  , createChatCompletionResponseObject
  , createChatCompletionResponseUsage = Nothing
  }

-- ** CreateChatCompletionResponseChoicesInner
-- | CreateChatCompletionResponseChoicesInner
data CreateChatCompletionResponseChoicesInner = CreateChatCompletionResponseChoicesInner
  { createChatCompletionResponseChoicesInnerFinishReason :: !(E'FinishReason2) -- ^ /Required/ "finish_reason" - The reason the model stopped generating tokens. This will be &#x60;stop&#x60; if the model hit a natural stop point or a provided stop sequence, &#x60;length&#x60; if the maximum number of tokens specified in the request was reached, &#x60;content_filter&#x60; if content was omitted due to a flag from our content filters, &#x60;tool_calls&#x60; if the model called a tool, or &#x60;function_call&#x60; (deprecated) if the model called a function. 
  , createChatCompletionResponseChoicesInnerIndex :: !(Int) -- ^ /Required/ "index" - The index of the choice in the list of choices.
  , createChatCompletionResponseChoicesInnerMessage :: !(ChatCompletionResponseMessage) -- ^ /Required/ "message"
  , createChatCompletionResponseChoicesInnerLogprobs :: !(CreateChatCompletionResponseChoicesInnerLogprobs) -- ^ /Required/ "logprobs"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateChatCompletionResponseChoicesInner
instance A.FromJSON CreateChatCompletionResponseChoicesInner where
  parseJSON = A.withObject "CreateChatCompletionResponseChoicesInner" $ \o ->
    CreateChatCompletionResponseChoicesInner
      <$> (o .:  "finish_reason")
      <*> (o .:  "index")
      <*> (o .:  "message")
      <*> (o .:  "logprobs")

-- | ToJSON CreateChatCompletionResponseChoicesInner
instance A.ToJSON CreateChatCompletionResponseChoicesInner where
  toJSON CreateChatCompletionResponseChoicesInner {..} =
   _omitNulls
      [ "finish_reason" .= createChatCompletionResponseChoicesInnerFinishReason
      , "index" .= createChatCompletionResponseChoicesInnerIndex
      , "message" .= createChatCompletionResponseChoicesInnerMessage
      , "logprobs" .= createChatCompletionResponseChoicesInnerLogprobs
      ]


-- | Construct a value of type 'CreateChatCompletionResponseChoicesInner' (by applying it's required fields, if any)
mkCreateChatCompletionResponseChoicesInner
  :: E'FinishReason2 -- ^ 'createChatCompletionResponseChoicesInnerFinishReason': The reason the model stopped generating tokens. This will be `stop` if the model hit a natural stop point or a provided stop sequence, `length` if the maximum number of tokens specified in the request was reached, `content_filter` if content was omitted due to a flag from our content filters, `tool_calls` if the model called a tool, or `function_call` (deprecated) if the model called a function. 
  -> Int -- ^ 'createChatCompletionResponseChoicesInnerIndex': The index of the choice in the list of choices.
  -> ChatCompletionResponseMessage -- ^ 'createChatCompletionResponseChoicesInnerMessage' 
  -> CreateChatCompletionResponseChoicesInnerLogprobs -- ^ 'createChatCompletionResponseChoicesInnerLogprobs' 
  -> CreateChatCompletionResponseChoicesInner
mkCreateChatCompletionResponseChoicesInner createChatCompletionResponseChoicesInnerFinishReason createChatCompletionResponseChoicesInnerIndex createChatCompletionResponseChoicesInnerMessage createChatCompletionResponseChoicesInnerLogprobs =
  CreateChatCompletionResponseChoicesInner
  { createChatCompletionResponseChoicesInnerFinishReason
  , createChatCompletionResponseChoicesInnerIndex
  , createChatCompletionResponseChoicesInnerMessage
  , createChatCompletionResponseChoicesInnerLogprobs
  }

-- ** CreateChatCompletionResponseChoicesInnerLogprobs
-- | CreateChatCompletionResponseChoicesInnerLogprobs
-- Log probability information for the choice.
data CreateChatCompletionResponseChoicesInnerLogprobs = CreateChatCompletionResponseChoicesInnerLogprobs
  { createChatCompletionResponseChoicesInnerLogprobsContent :: !([ChatCompletionTokenLogprob]) -- ^ /Required/ "content" - A list of message content tokens with log probability information.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateChatCompletionResponseChoicesInnerLogprobs
instance A.FromJSON CreateChatCompletionResponseChoicesInnerLogprobs where
  parseJSON = A.withObject "CreateChatCompletionResponseChoicesInnerLogprobs" $ \o ->
    CreateChatCompletionResponseChoicesInnerLogprobs
      <$> (o .:  "content")

-- | ToJSON CreateChatCompletionResponseChoicesInnerLogprobs
instance A.ToJSON CreateChatCompletionResponseChoicesInnerLogprobs where
  toJSON CreateChatCompletionResponseChoicesInnerLogprobs {..} =
   _omitNulls
      [ "content" .= createChatCompletionResponseChoicesInnerLogprobsContent
      ]


-- | Construct a value of type 'CreateChatCompletionResponseChoicesInnerLogprobs' (by applying it's required fields, if any)
mkCreateChatCompletionResponseChoicesInnerLogprobs
  :: [ChatCompletionTokenLogprob] -- ^ 'createChatCompletionResponseChoicesInnerLogprobsContent': A list of message content tokens with log probability information.
  -> CreateChatCompletionResponseChoicesInnerLogprobs
mkCreateChatCompletionResponseChoicesInnerLogprobs createChatCompletionResponseChoicesInnerLogprobsContent =
  CreateChatCompletionResponseChoicesInnerLogprobs
  { createChatCompletionResponseChoicesInnerLogprobsContent
  }

-- ** CreateChatCompletionStreamResponse
-- | CreateChatCompletionStreamResponse
-- Represents a streamed chunk of a chat completion response returned by model, based on the provided input.
data CreateChatCompletionStreamResponse = CreateChatCompletionStreamResponse
  { createChatCompletionStreamResponseId :: !(Text) -- ^ /Required/ "id" - A unique identifier for the chat completion. Each chunk has the same ID.
  , createChatCompletionStreamResponseChoices :: !([CreateChatCompletionStreamResponseChoicesInner]) -- ^ /Required/ "choices" - A list of chat completion choices. Can be more than one if &#x60;n&#x60; is greater than 1.
  , createChatCompletionStreamResponseCreated :: !(Int) -- ^ /Required/ "created" - The Unix timestamp (in seconds) of when the chat completion was created. Each chunk has the same timestamp.
  , createChatCompletionStreamResponseModel :: !(Text) -- ^ /Required/ "model" - The model to generate the completion.
  , createChatCompletionStreamResponseSystemFingerprint :: !(Maybe Text) -- ^ "system_fingerprint" - This fingerprint represents the backend configuration that the model runs with. Can be used in conjunction with the &#x60;seed&#x60; request parameter to understand when backend changes have been made that might impact determinism. 
  , createChatCompletionStreamResponseObject :: !(E'Object4) -- ^ /Required/ "object" - The object type, which is always &#x60;chat.completion.chunk&#x60;.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateChatCompletionStreamResponse
instance A.FromJSON CreateChatCompletionStreamResponse where
  parseJSON = A.withObject "CreateChatCompletionStreamResponse" $ \o ->
    CreateChatCompletionStreamResponse
      <$> (o .:  "id")
      <*> (o .:  "choices")
      <*> (o .:  "created")
      <*> (o .:  "model")
      <*> (o .:? "system_fingerprint")
      <*> (o .:  "object")

-- | ToJSON CreateChatCompletionStreamResponse
instance A.ToJSON CreateChatCompletionStreamResponse where
  toJSON CreateChatCompletionStreamResponse {..} =
   _omitNulls
      [ "id" .= createChatCompletionStreamResponseId
      , "choices" .= createChatCompletionStreamResponseChoices
      , "created" .= createChatCompletionStreamResponseCreated
      , "model" .= createChatCompletionStreamResponseModel
      , "system_fingerprint" .= createChatCompletionStreamResponseSystemFingerprint
      , "object" .= createChatCompletionStreamResponseObject
      ]


-- | Construct a value of type 'CreateChatCompletionStreamResponse' (by applying it's required fields, if any)
mkCreateChatCompletionStreamResponse
  :: Text -- ^ 'createChatCompletionStreamResponseId': A unique identifier for the chat completion. Each chunk has the same ID.
  -> [CreateChatCompletionStreamResponseChoicesInner] -- ^ 'createChatCompletionStreamResponseChoices': A list of chat completion choices. Can be more than one if `n` is greater than 1.
  -> Int -- ^ 'createChatCompletionStreamResponseCreated': The Unix timestamp (in seconds) of when the chat completion was created. Each chunk has the same timestamp.
  -> Text -- ^ 'createChatCompletionStreamResponseModel': The model to generate the completion.
  -> E'Object4 -- ^ 'createChatCompletionStreamResponseObject': The object type, which is always `chat.completion.chunk`.
  -> CreateChatCompletionStreamResponse
mkCreateChatCompletionStreamResponse createChatCompletionStreamResponseId createChatCompletionStreamResponseChoices createChatCompletionStreamResponseCreated createChatCompletionStreamResponseModel createChatCompletionStreamResponseObject =
  CreateChatCompletionStreamResponse
  { createChatCompletionStreamResponseId
  , createChatCompletionStreamResponseChoices
  , createChatCompletionStreamResponseCreated
  , createChatCompletionStreamResponseModel
  , createChatCompletionStreamResponseSystemFingerprint = Nothing
  , createChatCompletionStreamResponseObject
  }

-- ** CreateChatCompletionStreamResponseChoicesInner
-- | CreateChatCompletionStreamResponseChoicesInner
data CreateChatCompletionStreamResponseChoicesInner = CreateChatCompletionStreamResponseChoicesInner
  { createChatCompletionStreamResponseChoicesInnerDelta :: !(ChatCompletionStreamResponseDelta) -- ^ /Required/ "delta"
  , createChatCompletionStreamResponseChoicesInnerLogprobs :: !(Maybe CreateChatCompletionResponseChoicesInnerLogprobs) -- ^ "logprobs"
  , createChatCompletionStreamResponseChoicesInnerFinishReason :: !(E'FinishReason2) -- ^ /Required/ "finish_reason" - The reason the model stopped generating tokens. This will be &#x60;stop&#x60; if the model hit a natural stop point or a provided stop sequence, &#x60;length&#x60; if the maximum number of tokens specified in the request was reached, &#x60;content_filter&#x60; if content was omitted due to a flag from our content filters, &#x60;tool_calls&#x60; if the model called a tool, or &#x60;function_call&#x60; (deprecated) if the model called a function. 
  , createChatCompletionStreamResponseChoicesInnerIndex :: !(Int) -- ^ /Required/ "index" - The index of the choice in the list of choices.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateChatCompletionStreamResponseChoicesInner
instance A.FromJSON CreateChatCompletionStreamResponseChoicesInner where
  parseJSON = A.withObject "CreateChatCompletionStreamResponseChoicesInner" $ \o ->
    CreateChatCompletionStreamResponseChoicesInner
      <$> (o .:  "delta")
      <*> (o .:? "logprobs")
      <*> (o .:  "finish_reason")
      <*> (o .:  "index")

-- | ToJSON CreateChatCompletionStreamResponseChoicesInner
instance A.ToJSON CreateChatCompletionStreamResponseChoicesInner where
  toJSON CreateChatCompletionStreamResponseChoicesInner {..} =
   _omitNulls
      [ "delta" .= createChatCompletionStreamResponseChoicesInnerDelta
      , "logprobs" .= createChatCompletionStreamResponseChoicesInnerLogprobs
      , "finish_reason" .= createChatCompletionStreamResponseChoicesInnerFinishReason
      , "index" .= createChatCompletionStreamResponseChoicesInnerIndex
      ]


-- | Construct a value of type 'CreateChatCompletionStreamResponseChoicesInner' (by applying it's required fields, if any)
mkCreateChatCompletionStreamResponseChoicesInner
  :: ChatCompletionStreamResponseDelta -- ^ 'createChatCompletionStreamResponseChoicesInnerDelta' 
  -> E'FinishReason2 -- ^ 'createChatCompletionStreamResponseChoicesInnerFinishReason': The reason the model stopped generating tokens. This will be `stop` if the model hit a natural stop point or a provided stop sequence, `length` if the maximum number of tokens specified in the request was reached, `content_filter` if content was omitted due to a flag from our content filters, `tool_calls` if the model called a tool, or `function_call` (deprecated) if the model called a function. 
  -> Int -- ^ 'createChatCompletionStreamResponseChoicesInnerIndex': The index of the choice in the list of choices.
  -> CreateChatCompletionStreamResponseChoicesInner
mkCreateChatCompletionStreamResponseChoicesInner createChatCompletionStreamResponseChoicesInnerDelta createChatCompletionStreamResponseChoicesInnerFinishReason createChatCompletionStreamResponseChoicesInnerIndex =
  CreateChatCompletionStreamResponseChoicesInner
  { createChatCompletionStreamResponseChoicesInnerDelta
  , createChatCompletionStreamResponseChoicesInnerLogprobs = Nothing
  , createChatCompletionStreamResponseChoicesInnerFinishReason
  , createChatCompletionStreamResponseChoicesInnerIndex
  }

-- ** CreateCompletionRequest
-- | CreateCompletionRequest
data CreateCompletionRequest = CreateCompletionRequest
  { createCompletionRequestModel :: !(CreateCompletionRequestModel) -- ^ /Required/ "model"
  , createCompletionRequestPrompt :: !(CreateCompletionRequestPrompt) -- ^ /Required/ "prompt"
  , createCompletionRequestBestOf :: !(Maybe Int) -- ^ "best_of" - Generates &#x60;best_of&#x60; completions server-side and returns the \&quot;best\&quot; (the one with the highest log probability per token). Results cannot be streamed.  When used with &#x60;n&#x60;, &#x60;best_of&#x60; controls the number of candidate completions and &#x60;n&#x60; specifies how many to return  &#x60;best_of&#x60; must be greater than &#x60;n&#x60;.  **Note:** Because this parameter generates many completions, it can quickly consume your token quota. Use carefully and ensure that you have reasonable settings for &#x60;max_tokens&#x60; and &#x60;stop&#x60;. 
  , createCompletionRequestEcho :: !(Maybe Bool) -- ^ "echo" - Echo back the prompt in addition to the completion 
  , createCompletionRequestFrequencyPenalty :: !(Maybe Double) -- ^ "frequency_penalty" - Number between -2.0 and 2.0. Positive values penalize new tokens based on their existing frequency in the text so far, decreasing the model&#39;s likelihood to repeat the same line verbatim.  [See more information about frequency and presence penalties.](/docs/guides/text-generation/parameter-details) 
  , createCompletionRequestLogitBias :: !(Maybe (Map.Map String Int)) -- ^ "logit_bias" - Modify the likelihood of specified tokens appearing in the completion.  Accepts a JSON object that maps tokens (specified by their token ID in the GPT tokenizer) to an associated bias value from -100 to 100. You can use this [tokenizer tool](/tokenizer?view&#x3D;bpe) to convert text to token IDs. Mathematically, the bias is added to the logits generated by the model prior to sampling. The exact effect will vary per model, but values between -1 and 1 should decrease or increase likelihood of selection; values like -100 or 100 should result in a ban or exclusive selection of the relevant token.  As an example, you can pass &#x60;{\&quot;50256\&quot;: -100}&#x60; to prevent the &lt;|endoftext|&gt; token from being generated. 
  , createCompletionRequestLogprobs :: !(Maybe Int) -- ^ "logprobs" - Include the log probabilities on the &#x60;logprobs&#x60; most likely output tokens, as well the chosen tokens. For example, if &#x60;logprobs&#x60; is 5, the API will return a list of the 5 most likely tokens. The API will always return the &#x60;logprob&#x60; of the sampled token, so there may be up to &#x60;logprobs+1&#x60; elements in the response.  The maximum value for &#x60;logprobs&#x60; is 5. 
  , createCompletionRequestMaxTokens :: !(Maybe Int) -- ^ "max_tokens" - The maximum number of [tokens](/tokenizer) that can be generated in the completion.  The token count of your prompt plus &#x60;max_tokens&#x60; cannot exceed the model&#39;s context length. [Example Python code](https://cookbook.openai.com/examples/how_to_count_tokens_with_tiktoken) for counting tokens. 
  , createCompletionRequestN :: !(Maybe Int) -- ^ "n" - How many completions to generate for each prompt.  **Note:** Because this parameter generates many completions, it can quickly consume your token quota. Use carefully and ensure that you have reasonable settings for &#x60;max_tokens&#x60; and &#x60;stop&#x60;. 
  , createCompletionRequestPresencePenalty :: !(Maybe Double) -- ^ "presence_penalty" - Number between -2.0 and 2.0. Positive values penalize new tokens based on whether they appear in the text so far, increasing the model&#39;s likelihood to talk about new topics.  [See more information about frequency and presence penalties.](/docs/guides/text-generation/parameter-details) 
  , createCompletionRequestSeed :: !(Maybe Int) -- ^ "seed" - If specified, our system will make a best effort to sample deterministically, such that repeated requests with the same &#x60;seed&#x60; and parameters should return the same result.  Determinism is not guaranteed, and you should refer to the &#x60;system_fingerprint&#x60; response parameter to monitor changes in the backend. 
  , createCompletionRequestStop :: !(Maybe CreateCompletionRequestStop) -- ^ "stop"
  , createCompletionRequestStream :: !(Maybe Bool) -- ^ "stream" - Whether to stream back partial progress. If set, tokens will be sent as data-only [server-sent events](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events#Event_stream_format) as they become available, with the stream terminated by a &#x60;data: [DONE]&#x60; message. [Example Python code](https://cookbook.openai.com/examples/how_to_stream_completions). 
  , createCompletionRequestSuffix :: !(Maybe Text) -- ^ "suffix" - The suffix that comes after a completion of inserted text.
  , createCompletionRequestTemperature :: !(Maybe Double) -- ^ "temperature" - What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.  We generally recommend altering this or &#x60;top_p&#x60; but not both. 
  , createCompletionRequestTopP :: !(Maybe Double) -- ^ "top_p" - An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass. So 0.1 means only the tokens comprising the top 10% probability mass are considered.  We generally recommend altering this or &#x60;temperature&#x60; but not both. 
  , createCompletionRequestUser :: !(Maybe Text) -- ^ "user" - A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse. [Learn more](/docs/guides/safety-best-practices/end-user-ids). 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateCompletionRequest
instance A.FromJSON CreateCompletionRequest where
  parseJSON = A.withObject "CreateCompletionRequest" $ \o ->
    CreateCompletionRequest
      <$> (o .:  "model")
      <*> (o .:  "prompt")
      <*> (o .:? "best_of")
      <*> (o .:? "echo")
      <*> (o .:? "frequency_penalty")
      <*> (o .:? "logit_bias")
      <*> (o .:? "logprobs")
      <*> (o .:? "max_tokens")
      <*> (o .:? "n")
      <*> (o .:? "presence_penalty")
      <*> (o .:? "seed")
      <*> (o .:? "stop")
      <*> (o .:? "stream")
      <*> (o .:? "suffix")
      <*> (o .:? "temperature")
      <*> (o .:? "top_p")
      <*> (o .:? "user")

-- | ToJSON CreateCompletionRequest
instance A.ToJSON CreateCompletionRequest where
  toJSON CreateCompletionRequest {..} =
   _omitNulls
      [ "model" .= createCompletionRequestModel
      , "prompt" .= createCompletionRequestPrompt
      , "best_of" .= createCompletionRequestBestOf
      , "echo" .= createCompletionRequestEcho
      , "frequency_penalty" .= createCompletionRequestFrequencyPenalty
      , "logit_bias" .= createCompletionRequestLogitBias
      , "logprobs" .= createCompletionRequestLogprobs
      , "max_tokens" .= createCompletionRequestMaxTokens
      , "n" .= createCompletionRequestN
      , "presence_penalty" .= createCompletionRequestPresencePenalty
      , "seed" .= createCompletionRequestSeed
      , "stop" .= createCompletionRequestStop
      , "stream" .= createCompletionRequestStream
      , "suffix" .= createCompletionRequestSuffix
      , "temperature" .= createCompletionRequestTemperature
      , "top_p" .= createCompletionRequestTopP
      , "user" .= createCompletionRequestUser
      ]


-- | Construct a value of type 'CreateCompletionRequest' (by applying it's required fields, if any)
mkCreateCompletionRequest
  :: CreateCompletionRequestModel -- ^ 'createCompletionRequestModel' 
  -> CreateCompletionRequestPrompt -- ^ 'createCompletionRequestPrompt' 
  -> CreateCompletionRequest
mkCreateCompletionRequest createCompletionRequestModel createCompletionRequestPrompt =
  CreateCompletionRequest
  { createCompletionRequestModel
  , createCompletionRequestPrompt
  , createCompletionRequestBestOf = Nothing
  , createCompletionRequestEcho = Nothing
  , createCompletionRequestFrequencyPenalty = Nothing
  , createCompletionRequestLogitBias = Nothing
  , createCompletionRequestLogprobs = Nothing
  , createCompletionRequestMaxTokens = Nothing
  , createCompletionRequestN = Nothing
  , createCompletionRequestPresencePenalty = Nothing
  , createCompletionRequestSeed = Nothing
  , createCompletionRequestStop = Nothing
  , createCompletionRequestStream = Nothing
  , createCompletionRequestSuffix = Nothing
  , createCompletionRequestTemperature = Nothing
  , createCompletionRequestTopP = Nothing
  , createCompletionRequestUser = Nothing
  }

-- ** CreateCompletionRequestModel
-- | CreateCompletionRequestModel
-- ID of the model to use. You can use the [List models](/docs/api-reference/models/list) API to see all of your available models, or see our [Model overview](/docs/models/overview) for descriptions of them. 
data CreateCompletionRequestModel = CreateCompletionRequestModel
  { 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateCompletionRequestModel
instance A.FromJSON CreateCompletionRequestModel where
  parseJSON = A.withObject "CreateCompletionRequestModel" $ \o ->
    pure CreateCompletionRequestModel
      

-- | ToJSON CreateCompletionRequestModel
instance A.ToJSON CreateCompletionRequestModel where
  toJSON CreateCompletionRequestModel  =
   _omitNulls
      [ 
      ]


-- | Construct a value of type 'CreateCompletionRequestModel' (by applying it's required fields, if any)
mkCreateCompletionRequestModel
  :: CreateCompletionRequestModel
mkCreateCompletionRequestModel =
  CreateCompletionRequestModel
  { 
  }

-- ** CreateCompletionRequestPrompt
-- | CreateCompletionRequestPrompt
-- The prompt(s) to generate completions for, encoded as a string, array of strings, array of tokens, or array of token arrays.  Note that <|endoftext|> is the document separator that the model sees during training, so if a prompt is not specified the model will generate as if from the beginning of a new document. 
data CreateCompletionRequestPrompt = CreateCompletionRequestPrompt
  { 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateCompletionRequestPrompt
instance A.FromJSON CreateCompletionRequestPrompt where
  parseJSON = A.withObject "CreateCompletionRequestPrompt" $ \o ->
    pure CreateCompletionRequestPrompt
      

-- | ToJSON CreateCompletionRequestPrompt
instance A.ToJSON CreateCompletionRequestPrompt where
  toJSON CreateCompletionRequestPrompt  =
   _omitNulls
      [ 
      ]


-- | Construct a value of type 'CreateCompletionRequestPrompt' (by applying it's required fields, if any)
mkCreateCompletionRequestPrompt
  :: CreateCompletionRequestPrompt
mkCreateCompletionRequestPrompt =
  CreateCompletionRequestPrompt
  { 
  }

-- ** CreateCompletionRequestStop
-- | CreateCompletionRequestStop
-- Up to 4 sequences where the API will stop generating further tokens. The returned text will not contain the stop sequence. 
data CreateCompletionRequestStop = CreateCompletionRequestStop
  { 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateCompletionRequestStop
instance A.FromJSON CreateCompletionRequestStop where
  parseJSON = A.withObject "CreateCompletionRequestStop" $ \o ->
    pure CreateCompletionRequestStop
      

-- | ToJSON CreateCompletionRequestStop
instance A.ToJSON CreateCompletionRequestStop where
  toJSON CreateCompletionRequestStop  =
   _omitNulls
      [ 
      ]


-- | Construct a value of type 'CreateCompletionRequestStop' (by applying it's required fields, if any)
mkCreateCompletionRequestStop
  :: CreateCompletionRequestStop
mkCreateCompletionRequestStop =
  CreateCompletionRequestStop
  { 
  }

-- ** CreateCompletionResponse
-- | CreateCompletionResponse
-- Represents a completion response from the API. Note: both the streamed and non-streamed response objects share the same shape (unlike the chat endpoint). 
data CreateCompletionResponse = CreateCompletionResponse
  { createCompletionResponseId :: !(Text) -- ^ /Required/ "id" - A unique identifier for the completion.
  , createCompletionResponseChoices :: !([CreateCompletionResponseChoicesInner]) -- ^ /Required/ "choices" - The list of completion choices the model generated for the input prompt.
  , createCompletionResponseCreated :: !(Int) -- ^ /Required/ "created" - The Unix timestamp (in seconds) of when the completion was created.
  , createCompletionResponseModel :: !(Text) -- ^ /Required/ "model" - The model used for completion.
  , createCompletionResponseSystemFingerprint :: !(Maybe Text) -- ^ "system_fingerprint" - This fingerprint represents the backend configuration that the model runs with.  Can be used in conjunction with the &#x60;seed&#x60; request parameter to understand when backend changes have been made that might impact determinism. 
  , createCompletionResponseObject :: !(E'Object2) -- ^ /Required/ "object" - The object type, which is always \&quot;text_completion\&quot;
  , createCompletionResponseUsage :: !(Maybe CompletionUsage) -- ^ "usage"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateCompletionResponse
instance A.FromJSON CreateCompletionResponse where
  parseJSON = A.withObject "CreateCompletionResponse" $ \o ->
    CreateCompletionResponse
      <$> (o .:  "id")
      <*> (o .:  "choices")
      <*> (o .:  "created")
      <*> (o .:  "model")
      <*> (o .:? "system_fingerprint")
      <*> (o .:  "object")
      <*> (o .:? "usage")

-- | ToJSON CreateCompletionResponse
instance A.ToJSON CreateCompletionResponse where
  toJSON CreateCompletionResponse {..} =
   _omitNulls
      [ "id" .= createCompletionResponseId
      , "choices" .= createCompletionResponseChoices
      , "created" .= createCompletionResponseCreated
      , "model" .= createCompletionResponseModel
      , "system_fingerprint" .= createCompletionResponseSystemFingerprint
      , "object" .= createCompletionResponseObject
      , "usage" .= createCompletionResponseUsage
      ]


-- | Construct a value of type 'CreateCompletionResponse' (by applying it's required fields, if any)
mkCreateCompletionResponse
  :: Text -- ^ 'createCompletionResponseId': A unique identifier for the completion.
  -> [CreateCompletionResponseChoicesInner] -- ^ 'createCompletionResponseChoices': The list of completion choices the model generated for the input prompt.
  -> Int -- ^ 'createCompletionResponseCreated': The Unix timestamp (in seconds) of when the completion was created.
  -> Text -- ^ 'createCompletionResponseModel': The model used for completion.
  -> E'Object2 -- ^ 'createCompletionResponseObject': The object type, which is always \"text_completion\"
  -> CreateCompletionResponse
mkCreateCompletionResponse createCompletionResponseId createCompletionResponseChoices createCompletionResponseCreated createCompletionResponseModel createCompletionResponseObject =
  CreateCompletionResponse
  { createCompletionResponseId
  , createCompletionResponseChoices
  , createCompletionResponseCreated
  , createCompletionResponseModel
  , createCompletionResponseSystemFingerprint = Nothing
  , createCompletionResponseObject
  , createCompletionResponseUsage = Nothing
  }

-- ** CreateCompletionResponseChoicesInner
-- | CreateCompletionResponseChoicesInner
data CreateCompletionResponseChoicesInner = CreateCompletionResponseChoicesInner
  { createCompletionResponseChoicesInnerFinishReason :: !(E'FinishReason) -- ^ /Required/ "finish_reason" - The reason the model stopped generating tokens. This will be &#x60;stop&#x60; if the model hit a natural stop point or a provided stop sequence, &#x60;length&#x60; if the maximum number of tokens specified in the request was reached, or &#x60;content_filter&#x60; if content was omitted due to a flag from our content filters. 
  , createCompletionResponseChoicesInnerIndex :: !(Int) -- ^ /Required/ "index"
  , createCompletionResponseChoicesInnerLogprobs :: !(CreateCompletionResponseChoicesInnerLogprobs) -- ^ /Required/ "logprobs"
  , createCompletionResponseChoicesInnerText :: !(Text) -- ^ /Required/ "text"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateCompletionResponseChoicesInner
instance A.FromJSON CreateCompletionResponseChoicesInner where
  parseJSON = A.withObject "CreateCompletionResponseChoicesInner" $ \o ->
    CreateCompletionResponseChoicesInner
      <$> (o .:  "finish_reason")
      <*> (o .:  "index")
      <*> (o .:  "logprobs")
      <*> (o .:  "text")

-- | ToJSON CreateCompletionResponseChoicesInner
instance A.ToJSON CreateCompletionResponseChoicesInner where
  toJSON CreateCompletionResponseChoicesInner {..} =
   _omitNulls
      [ "finish_reason" .= createCompletionResponseChoicesInnerFinishReason
      , "index" .= createCompletionResponseChoicesInnerIndex
      , "logprobs" .= createCompletionResponseChoicesInnerLogprobs
      , "text" .= createCompletionResponseChoicesInnerText
      ]


-- | Construct a value of type 'CreateCompletionResponseChoicesInner' (by applying it's required fields, if any)
mkCreateCompletionResponseChoicesInner
  :: E'FinishReason -- ^ 'createCompletionResponseChoicesInnerFinishReason': The reason the model stopped generating tokens. This will be `stop` if the model hit a natural stop point or a provided stop sequence, `length` if the maximum number of tokens specified in the request was reached, or `content_filter` if content was omitted due to a flag from our content filters. 
  -> Int -- ^ 'createCompletionResponseChoicesInnerIndex' 
  -> CreateCompletionResponseChoicesInnerLogprobs -- ^ 'createCompletionResponseChoicesInnerLogprobs' 
  -> Text -- ^ 'createCompletionResponseChoicesInnerText' 
  -> CreateCompletionResponseChoicesInner
mkCreateCompletionResponseChoicesInner createCompletionResponseChoicesInnerFinishReason createCompletionResponseChoicesInnerIndex createCompletionResponseChoicesInnerLogprobs createCompletionResponseChoicesInnerText =
  CreateCompletionResponseChoicesInner
  { createCompletionResponseChoicesInnerFinishReason
  , createCompletionResponseChoicesInnerIndex
  , createCompletionResponseChoicesInnerLogprobs
  , createCompletionResponseChoicesInnerText
  }

-- ** CreateCompletionResponseChoicesInnerLogprobs
-- | CreateCompletionResponseChoicesInnerLogprobs
data CreateCompletionResponseChoicesInnerLogprobs = CreateCompletionResponseChoicesInnerLogprobs
  { createCompletionResponseChoicesInnerLogprobsTextOffset :: !(Maybe [Int]) -- ^ "text_offset"
  , createCompletionResponseChoicesInnerLogprobsTokenLogprobs :: !(Maybe [Double]) -- ^ "token_logprobs"
  , createCompletionResponseChoicesInnerLogprobsTokens :: !(Maybe [Text]) -- ^ "tokens"
  , createCompletionResponseChoicesInnerLogprobsTopLogprobs :: !(Maybe [(Map.Map String Double)]) -- ^ "top_logprobs"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateCompletionResponseChoicesInnerLogprobs
instance A.FromJSON CreateCompletionResponseChoicesInnerLogprobs where
  parseJSON = A.withObject "CreateCompletionResponseChoicesInnerLogprobs" $ \o ->
    CreateCompletionResponseChoicesInnerLogprobs
      <$> (o .:? "text_offset")
      <*> (o .:? "token_logprobs")
      <*> (o .:? "tokens")
      <*> (o .:? "top_logprobs")

-- | ToJSON CreateCompletionResponseChoicesInnerLogprobs
instance A.ToJSON CreateCompletionResponseChoicesInnerLogprobs where
  toJSON CreateCompletionResponseChoicesInnerLogprobs {..} =
   _omitNulls
      [ "text_offset" .= createCompletionResponseChoicesInnerLogprobsTextOffset
      , "token_logprobs" .= createCompletionResponseChoicesInnerLogprobsTokenLogprobs
      , "tokens" .= createCompletionResponseChoicesInnerLogprobsTokens
      , "top_logprobs" .= createCompletionResponseChoicesInnerLogprobsTopLogprobs
      ]


-- | Construct a value of type 'CreateCompletionResponseChoicesInnerLogprobs' (by applying it's required fields, if any)
mkCreateCompletionResponseChoicesInnerLogprobs
  :: CreateCompletionResponseChoicesInnerLogprobs
mkCreateCompletionResponseChoicesInnerLogprobs =
  CreateCompletionResponseChoicesInnerLogprobs
  { createCompletionResponseChoicesInnerLogprobsTextOffset = Nothing
  , createCompletionResponseChoicesInnerLogprobsTokenLogprobs = Nothing
  , createCompletionResponseChoicesInnerLogprobsTokens = Nothing
  , createCompletionResponseChoicesInnerLogprobsTopLogprobs = Nothing
  }

-- ** CreateEmbeddingRequest
-- | CreateEmbeddingRequest
data CreateEmbeddingRequest = CreateEmbeddingRequest
  { createEmbeddingRequestInput :: !(CreateEmbeddingRequestInput) -- ^ /Required/ "input"
  , createEmbeddingRequestModel :: !(CreateEmbeddingRequestModel) -- ^ /Required/ "model"
  , createEmbeddingRequestEncodingFormat :: !(Maybe E'EncodingFormat) -- ^ "encoding_format" - The format to return the embeddings in. Can be either &#x60;float&#x60; or [&#x60;base64&#x60;](https://pypi.org/project/pybase64/).
  , createEmbeddingRequestDimensions :: !(Maybe Int) -- ^ "dimensions" - The number of dimensions the resulting output embeddings should have. Only supported in &#x60;text-embedding-3&#x60; and later models. 
  , createEmbeddingRequestUser :: !(Maybe Text) -- ^ "user" - A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse. [Learn more](/docs/guides/safety-best-practices/end-user-ids). 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateEmbeddingRequest
instance A.FromJSON CreateEmbeddingRequest where
  parseJSON = A.withObject "CreateEmbeddingRequest" $ \o ->
    CreateEmbeddingRequest
      <$> (o .:  "input")
      <*> (o .:  "model")
      <*> (o .:? "encoding_format")
      <*> (o .:? "dimensions")
      <*> (o .:? "user")

-- | ToJSON CreateEmbeddingRequest
instance A.ToJSON CreateEmbeddingRequest where
  toJSON CreateEmbeddingRequest {..} =
   _omitNulls
      [ "input" .= createEmbeddingRequestInput
      , "model" .= createEmbeddingRequestModel
      , "encoding_format" .= createEmbeddingRequestEncodingFormat
      , "dimensions" .= createEmbeddingRequestDimensions
      , "user" .= createEmbeddingRequestUser
      ]


-- | Construct a value of type 'CreateEmbeddingRequest' (by applying it's required fields, if any)
mkCreateEmbeddingRequest
  :: CreateEmbeddingRequestInput -- ^ 'createEmbeddingRequestInput' 
  -> CreateEmbeddingRequestModel -- ^ 'createEmbeddingRequestModel' 
  -> CreateEmbeddingRequest
mkCreateEmbeddingRequest createEmbeddingRequestInput createEmbeddingRequestModel =
  CreateEmbeddingRequest
  { createEmbeddingRequestInput
  , createEmbeddingRequestModel
  , createEmbeddingRequestEncodingFormat = Nothing
  , createEmbeddingRequestDimensions = Nothing
  , createEmbeddingRequestUser = Nothing
  }

-- ** CreateEmbeddingRequestInput
-- | CreateEmbeddingRequestInput
-- Input text to embed, encoded as a string or array of tokens. To embed multiple inputs in a single request, pass an array of strings or array of token arrays. The input must not exceed the max input tokens for the model (8192 tokens for `text-embedding-ada-002`), cannot be an empty string, and any array must be 2048 dimensions or less. [Example Python code](https://cookbook.openai.com/examples/how_to_count_tokens_with_tiktoken) for counting tokens. 
data CreateEmbeddingRequestInput = CreateEmbeddingRequestInput
  { 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateEmbeddingRequestInput
instance A.FromJSON CreateEmbeddingRequestInput where
  parseJSON = A.withObject "CreateEmbeddingRequestInput" $ \o ->
    pure CreateEmbeddingRequestInput
      

-- | ToJSON CreateEmbeddingRequestInput
instance A.ToJSON CreateEmbeddingRequestInput where
  toJSON CreateEmbeddingRequestInput  =
   _omitNulls
      [ 
      ]


-- | Construct a value of type 'CreateEmbeddingRequestInput' (by applying it's required fields, if any)
mkCreateEmbeddingRequestInput
  :: CreateEmbeddingRequestInput
mkCreateEmbeddingRequestInput =
  CreateEmbeddingRequestInput
  { 
  }

-- ** CreateEmbeddingRequestModel
-- | CreateEmbeddingRequestModel
-- ID of the model to use. You can use the [List models](/docs/api-reference/models/list) API to see all of your available models, or see our [Model overview](/docs/models/overview) for descriptions of them. 
data CreateEmbeddingRequestModel = CreateEmbeddingRequestModel
  { 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateEmbeddingRequestModel
instance A.FromJSON CreateEmbeddingRequestModel where
  parseJSON = A.withObject "CreateEmbeddingRequestModel" $ \o ->
    pure CreateEmbeddingRequestModel
      

-- | ToJSON CreateEmbeddingRequestModel
instance A.ToJSON CreateEmbeddingRequestModel where
  toJSON CreateEmbeddingRequestModel  =
   _omitNulls
      [ 
      ]


-- | Construct a value of type 'CreateEmbeddingRequestModel' (by applying it's required fields, if any)
mkCreateEmbeddingRequestModel
  :: CreateEmbeddingRequestModel
mkCreateEmbeddingRequestModel =
  CreateEmbeddingRequestModel
  { 
  }

-- ** CreateEmbeddingResponse
-- | CreateEmbeddingResponse
data CreateEmbeddingResponse = CreateEmbeddingResponse
  { createEmbeddingResponseData :: !([Embedding]) -- ^ /Required/ "data" - The list of embeddings generated by the model.
  , createEmbeddingResponseModel :: !(Text) -- ^ /Required/ "model" - The name of the model used to generate the embedding.
  , createEmbeddingResponseObject :: !(E'Object) -- ^ /Required/ "object" - The object type, which is always \&quot;list\&quot;.
  , createEmbeddingResponseUsage :: !(CreateEmbeddingResponseUsage) -- ^ /Required/ "usage"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateEmbeddingResponse
instance A.FromJSON CreateEmbeddingResponse where
  parseJSON = A.withObject "CreateEmbeddingResponse" $ \o ->
    CreateEmbeddingResponse
      <$> (o .:  "data")
      <*> (o .:  "model")
      <*> (o .:  "object")
      <*> (o .:  "usage")

-- | ToJSON CreateEmbeddingResponse
instance A.ToJSON CreateEmbeddingResponse where
  toJSON CreateEmbeddingResponse {..} =
   _omitNulls
      [ "data" .= createEmbeddingResponseData
      , "model" .= createEmbeddingResponseModel
      , "object" .= createEmbeddingResponseObject
      , "usage" .= createEmbeddingResponseUsage
      ]


-- | Construct a value of type 'CreateEmbeddingResponse' (by applying it's required fields, if any)
mkCreateEmbeddingResponse
  :: [Embedding] -- ^ 'createEmbeddingResponseData': The list of embeddings generated by the model.
  -> Text -- ^ 'createEmbeddingResponseModel': The name of the model used to generate the embedding.
  -> E'Object -- ^ 'createEmbeddingResponseObject': The object type, which is always \"list\".
  -> CreateEmbeddingResponseUsage -- ^ 'createEmbeddingResponseUsage' 
  -> CreateEmbeddingResponse
mkCreateEmbeddingResponse createEmbeddingResponseData createEmbeddingResponseModel createEmbeddingResponseObject createEmbeddingResponseUsage =
  CreateEmbeddingResponse
  { createEmbeddingResponseData
  , createEmbeddingResponseModel
  , createEmbeddingResponseObject
  , createEmbeddingResponseUsage
  }

-- ** CreateEmbeddingResponseUsage
-- | CreateEmbeddingResponseUsage
-- The usage information for the request.
data CreateEmbeddingResponseUsage = CreateEmbeddingResponseUsage
  { createEmbeddingResponseUsagePromptTokens :: !(Int) -- ^ /Required/ "prompt_tokens" - The number of tokens used by the prompt.
  , createEmbeddingResponseUsageTotalTokens :: !(Int) -- ^ /Required/ "total_tokens" - The total number of tokens used by the request.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateEmbeddingResponseUsage
instance A.FromJSON CreateEmbeddingResponseUsage where
  parseJSON = A.withObject "CreateEmbeddingResponseUsage" $ \o ->
    CreateEmbeddingResponseUsage
      <$> (o .:  "prompt_tokens")
      <*> (o .:  "total_tokens")

-- | ToJSON CreateEmbeddingResponseUsage
instance A.ToJSON CreateEmbeddingResponseUsage where
  toJSON CreateEmbeddingResponseUsage {..} =
   _omitNulls
      [ "prompt_tokens" .= createEmbeddingResponseUsagePromptTokens
      , "total_tokens" .= createEmbeddingResponseUsageTotalTokens
      ]


-- | Construct a value of type 'CreateEmbeddingResponseUsage' (by applying it's required fields, if any)
mkCreateEmbeddingResponseUsage
  :: Int -- ^ 'createEmbeddingResponseUsagePromptTokens': The number of tokens used by the prompt.
  -> Int -- ^ 'createEmbeddingResponseUsageTotalTokens': The total number of tokens used by the request.
  -> CreateEmbeddingResponseUsage
mkCreateEmbeddingResponseUsage createEmbeddingResponseUsagePromptTokens createEmbeddingResponseUsageTotalTokens =
  CreateEmbeddingResponseUsage
  { createEmbeddingResponseUsagePromptTokens
  , createEmbeddingResponseUsageTotalTokens
  }

-- ** CreateFineTuningJobRequest
-- | CreateFineTuningJobRequest
data CreateFineTuningJobRequest = CreateFineTuningJobRequest
  { createFineTuningJobRequestModel :: !(CreateFineTuningJobRequestModel) -- ^ /Required/ "model"
  , createFineTuningJobRequestTrainingFile :: !(Text) -- ^ /Required/ "training_file" - The ID of an uploaded file that contains training data.  See [upload file](/docs/api-reference/files/upload) for how to upload a file.  Your dataset must be formatted as a JSONL file. Additionally, you must upload your file with the purpose &#x60;fine-tune&#x60;.  See the [fine-tuning guide](/docs/guides/fine-tuning) for more details. 
  , createFineTuningJobRequestHyperparameters :: !(Maybe CreateFineTuningJobRequestHyperparameters) -- ^ "hyperparameters"
  , createFineTuningJobRequestSuffix :: !(Maybe Text) -- ^ "suffix" - A string of up to 18 characters that will be added to your fine-tuned model name.  For example, a &#x60;suffix&#x60; of \&quot;custom-model-name\&quot; would produce a model name like &#x60;ft:gpt-3.5-turbo:openai:custom-model-name:7p4lURel&#x60;. 
  , createFineTuningJobRequestValidationFile :: !(Maybe Text) -- ^ "validation_file" - The ID of an uploaded file that contains validation data.  If you provide this file, the data is used to generate validation metrics periodically during fine-tuning. These metrics can be viewed in the fine-tuning results file. The same data should not be present in both train and validation files.  Your dataset must be formatted as a JSONL file. You must upload your file with the purpose &#x60;fine-tune&#x60;.  See the [fine-tuning guide](/docs/guides/fine-tuning) for more details. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateFineTuningJobRequest
instance A.FromJSON CreateFineTuningJobRequest where
  parseJSON = A.withObject "CreateFineTuningJobRequest" $ \o ->
    CreateFineTuningJobRequest
      <$> (o .:  "model")
      <*> (o .:  "training_file")
      <*> (o .:? "hyperparameters")
      <*> (o .:? "suffix")
      <*> (o .:? "validation_file")

-- | ToJSON CreateFineTuningJobRequest
instance A.ToJSON CreateFineTuningJobRequest where
  toJSON CreateFineTuningJobRequest {..} =
   _omitNulls
      [ "model" .= createFineTuningJobRequestModel
      , "training_file" .= createFineTuningJobRequestTrainingFile
      , "hyperparameters" .= createFineTuningJobRequestHyperparameters
      , "suffix" .= createFineTuningJobRequestSuffix
      , "validation_file" .= createFineTuningJobRequestValidationFile
      ]


-- | Construct a value of type 'CreateFineTuningJobRequest' (by applying it's required fields, if any)
mkCreateFineTuningJobRequest
  :: CreateFineTuningJobRequestModel -- ^ 'createFineTuningJobRequestModel' 
  -> Text -- ^ 'createFineTuningJobRequestTrainingFile': The ID of an uploaded file that contains training data.  See [upload file](/docs/api-reference/files/upload) for how to upload a file.  Your dataset must be formatted as a JSONL file. Additionally, you must upload your file with the purpose `fine-tune`.  See the [fine-tuning guide](/docs/guides/fine-tuning) for more details. 
  -> CreateFineTuningJobRequest
mkCreateFineTuningJobRequest createFineTuningJobRequestModel createFineTuningJobRequestTrainingFile =
  CreateFineTuningJobRequest
  { createFineTuningJobRequestModel
  , createFineTuningJobRequestTrainingFile
  , createFineTuningJobRequestHyperparameters = Nothing
  , createFineTuningJobRequestSuffix = Nothing
  , createFineTuningJobRequestValidationFile = Nothing
  }

-- ** CreateFineTuningJobRequestHyperparameters
-- | CreateFineTuningJobRequestHyperparameters
-- The hyperparameters used for the fine-tuning job.
data CreateFineTuningJobRequestHyperparameters = CreateFineTuningJobRequestHyperparameters
  { createFineTuningJobRequestHyperparametersBatchSize :: !(Maybe CreateFineTuningJobRequestHyperparametersBatchSize) -- ^ "batch_size"
  , createFineTuningJobRequestHyperparametersLearningRateMultiplier :: !(Maybe CreateFineTuningJobRequestHyperparametersLearningRateMultiplier) -- ^ "learning_rate_multiplier"
  , createFineTuningJobRequestHyperparametersNEpochs :: !(Maybe CreateFineTuningJobRequestHyperparametersNEpochs) -- ^ "n_epochs"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateFineTuningJobRequestHyperparameters
instance A.FromJSON CreateFineTuningJobRequestHyperparameters where
  parseJSON = A.withObject "CreateFineTuningJobRequestHyperparameters" $ \o ->
    CreateFineTuningJobRequestHyperparameters
      <$> (o .:? "batch_size")
      <*> (o .:? "learning_rate_multiplier")
      <*> (o .:? "n_epochs")

-- | ToJSON CreateFineTuningJobRequestHyperparameters
instance A.ToJSON CreateFineTuningJobRequestHyperparameters where
  toJSON CreateFineTuningJobRequestHyperparameters {..} =
   _omitNulls
      [ "batch_size" .= createFineTuningJobRequestHyperparametersBatchSize
      , "learning_rate_multiplier" .= createFineTuningJobRequestHyperparametersLearningRateMultiplier
      , "n_epochs" .= createFineTuningJobRequestHyperparametersNEpochs
      ]


-- | Construct a value of type 'CreateFineTuningJobRequestHyperparameters' (by applying it's required fields, if any)
mkCreateFineTuningJobRequestHyperparameters
  :: CreateFineTuningJobRequestHyperparameters
mkCreateFineTuningJobRequestHyperparameters =
  CreateFineTuningJobRequestHyperparameters
  { createFineTuningJobRequestHyperparametersBatchSize = Nothing
  , createFineTuningJobRequestHyperparametersLearningRateMultiplier = Nothing
  , createFineTuningJobRequestHyperparametersNEpochs = Nothing
  }

-- ** CreateFineTuningJobRequestHyperparametersBatchSize
-- | CreateFineTuningJobRequestHyperparametersBatchSize
-- Number of examples in each batch. A larger batch size means that model parameters are updated less frequently, but with lower variance. 
data CreateFineTuningJobRequestHyperparametersBatchSize = CreateFineTuningJobRequestHyperparametersBatchSize
  { 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateFineTuningJobRequestHyperparametersBatchSize
instance A.FromJSON CreateFineTuningJobRequestHyperparametersBatchSize where
  parseJSON = A.withObject "CreateFineTuningJobRequestHyperparametersBatchSize" $ \o ->
    pure CreateFineTuningJobRequestHyperparametersBatchSize
      

-- | ToJSON CreateFineTuningJobRequestHyperparametersBatchSize
instance A.ToJSON CreateFineTuningJobRequestHyperparametersBatchSize where
  toJSON CreateFineTuningJobRequestHyperparametersBatchSize  =
   _omitNulls
      [ 
      ]


-- | Construct a value of type 'CreateFineTuningJobRequestHyperparametersBatchSize' (by applying it's required fields, if any)
mkCreateFineTuningJobRequestHyperparametersBatchSize
  :: CreateFineTuningJobRequestHyperparametersBatchSize
mkCreateFineTuningJobRequestHyperparametersBatchSize =
  CreateFineTuningJobRequestHyperparametersBatchSize
  { 
  }

-- ** CreateFineTuningJobRequestHyperparametersLearningRateMultiplier
-- | CreateFineTuningJobRequestHyperparametersLearningRateMultiplier
-- Scaling factor for the learning rate. A smaller learning rate may be useful to avoid overfitting. 
data CreateFineTuningJobRequestHyperparametersLearningRateMultiplier = CreateFineTuningJobRequestHyperparametersLearningRateMultiplier
  { 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateFineTuningJobRequestHyperparametersLearningRateMultiplier
instance A.FromJSON CreateFineTuningJobRequestHyperparametersLearningRateMultiplier where
  parseJSON = A.withObject "CreateFineTuningJobRequestHyperparametersLearningRateMultiplier" $ \o ->
    pure CreateFineTuningJobRequestHyperparametersLearningRateMultiplier
      

-- | ToJSON CreateFineTuningJobRequestHyperparametersLearningRateMultiplier
instance A.ToJSON CreateFineTuningJobRequestHyperparametersLearningRateMultiplier where
  toJSON CreateFineTuningJobRequestHyperparametersLearningRateMultiplier  =
   _omitNulls
      [ 
      ]


-- | Construct a value of type 'CreateFineTuningJobRequestHyperparametersLearningRateMultiplier' (by applying it's required fields, if any)
mkCreateFineTuningJobRequestHyperparametersLearningRateMultiplier
  :: CreateFineTuningJobRequestHyperparametersLearningRateMultiplier
mkCreateFineTuningJobRequestHyperparametersLearningRateMultiplier =
  CreateFineTuningJobRequestHyperparametersLearningRateMultiplier
  { 
  }

-- ** CreateFineTuningJobRequestHyperparametersNEpochs
-- | CreateFineTuningJobRequestHyperparametersNEpochs
-- The number of epochs to train the model for. An epoch refers to one full cycle through the training dataset. 
data CreateFineTuningJobRequestHyperparametersNEpochs = CreateFineTuningJobRequestHyperparametersNEpochs
  { 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateFineTuningJobRequestHyperparametersNEpochs
instance A.FromJSON CreateFineTuningJobRequestHyperparametersNEpochs where
  parseJSON = A.withObject "CreateFineTuningJobRequestHyperparametersNEpochs" $ \o ->
    pure CreateFineTuningJobRequestHyperparametersNEpochs
      

-- | ToJSON CreateFineTuningJobRequestHyperparametersNEpochs
instance A.ToJSON CreateFineTuningJobRequestHyperparametersNEpochs where
  toJSON CreateFineTuningJobRequestHyperparametersNEpochs  =
   _omitNulls
      [ 
      ]


-- | Construct a value of type 'CreateFineTuningJobRequestHyperparametersNEpochs' (by applying it's required fields, if any)
mkCreateFineTuningJobRequestHyperparametersNEpochs
  :: CreateFineTuningJobRequestHyperparametersNEpochs
mkCreateFineTuningJobRequestHyperparametersNEpochs =
  CreateFineTuningJobRequestHyperparametersNEpochs
  { 
  }

-- ** CreateFineTuningJobRequestModel
-- | CreateFineTuningJobRequestModel
-- The name of the model to fine-tune. You can select one of the [supported models](/docs/guides/fine-tuning/what-models-can-be-fine-tuned). 
data CreateFineTuningJobRequestModel = CreateFineTuningJobRequestModel
  { 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateFineTuningJobRequestModel
instance A.FromJSON CreateFineTuningJobRequestModel where
  parseJSON = A.withObject "CreateFineTuningJobRequestModel" $ \o ->
    pure CreateFineTuningJobRequestModel
      

-- | ToJSON CreateFineTuningJobRequestModel
instance A.ToJSON CreateFineTuningJobRequestModel where
  toJSON CreateFineTuningJobRequestModel  =
   _omitNulls
      [ 
      ]


-- | Construct a value of type 'CreateFineTuningJobRequestModel' (by applying it's required fields, if any)
mkCreateFineTuningJobRequestModel
  :: CreateFineTuningJobRequestModel
mkCreateFineTuningJobRequestModel =
  CreateFineTuningJobRequestModel
  { 
  }

-- ** CreateImageRequest
-- | CreateImageRequest
data CreateImageRequest = CreateImageRequest
  { createImageRequestPrompt :: !(Text) -- ^ /Required/ "prompt" - A text description of the desired image(s). The maximum length is 1000 characters for &#x60;dall-e-2&#x60; and 4000 characters for &#x60;dall-e-3&#x60;.
  , createImageRequestModel :: !(Maybe CreateImageRequestModel) -- ^ "model"
  , createImageRequestN :: !(Maybe Int) -- ^ "n" - The number of images to generate. Must be between 1 and 10. For &#x60;dall-e-3&#x60;, only &#x60;n&#x3D;1&#x60; is supported.
  , createImageRequestQuality :: !(Maybe E'Quality) -- ^ "quality" - The quality of the image that will be generated. &#x60;hd&#x60; creates images with finer details and greater consistency across the image. This param is only supported for &#x60;dall-e-3&#x60;.
  , createImageRequestResponseFormat :: !(Maybe E'ResponseFormat) -- ^ "response_format" - The format in which the generated images are returned. Must be one of &#x60;url&#x60; or &#x60;b64_json&#x60;. URLs are only valid for 60 minutes after the image has been generated.
  , createImageRequestSize :: !(Maybe E'Size) -- ^ "size" - The size of the generated images. Must be one of &#x60;256x256&#x60;, &#x60;512x512&#x60;, or &#x60;1024x1024&#x60; for &#x60;dall-e-2&#x60;. Must be one of &#x60;1024x1024&#x60;, &#x60;1792x1024&#x60;, or &#x60;1024x1792&#x60; for &#x60;dall-e-3&#x60; models.
  , createImageRequestStyle :: !(Maybe E'Style) -- ^ "style" - The style of the generated images. Must be one of &#x60;vivid&#x60; or &#x60;natural&#x60;. Vivid causes the model to lean towards generating hyper-real and dramatic images. Natural causes the model to produce more natural, less hyper-real looking images. This param is only supported for &#x60;dall-e-3&#x60;.
  , createImageRequestUser :: !(Maybe Text) -- ^ "user" - A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse. [Learn more](/docs/guides/safety-best-practices/end-user-ids). 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateImageRequest
instance A.FromJSON CreateImageRequest where
  parseJSON = A.withObject "CreateImageRequest" $ \o ->
    CreateImageRequest
      <$> (o .:  "prompt")
      <*> (o .:? "model")
      <*> (o .:? "n")
      <*> (o .:? "quality")
      <*> (o .:? "response_format")
      <*> (o .:? "size")
      <*> (o .:? "style")
      <*> (o .:? "user")

-- | ToJSON CreateImageRequest
instance A.ToJSON CreateImageRequest where
  toJSON CreateImageRequest {..} =
   _omitNulls
      [ "prompt" .= createImageRequestPrompt
      , "model" .= createImageRequestModel
      , "n" .= createImageRequestN
      , "quality" .= createImageRequestQuality
      , "response_format" .= createImageRequestResponseFormat
      , "size" .= createImageRequestSize
      , "style" .= createImageRequestStyle
      , "user" .= createImageRequestUser
      ]


-- | Construct a value of type 'CreateImageRequest' (by applying it's required fields, if any)
mkCreateImageRequest
  :: Text -- ^ 'createImageRequestPrompt': A text description of the desired image(s). The maximum length is 1000 characters for `dall-e-2` and 4000 characters for `dall-e-3`.
  -> CreateImageRequest
mkCreateImageRequest createImageRequestPrompt =
  CreateImageRequest
  { createImageRequestPrompt
  , createImageRequestModel = Nothing
  , createImageRequestN = Nothing
  , createImageRequestQuality = Nothing
  , createImageRequestResponseFormat = Nothing
  , createImageRequestSize = Nothing
  , createImageRequestStyle = Nothing
  , createImageRequestUser = Nothing
  }

-- ** CreateImageRequestModel
-- | CreateImageRequestModel
-- The model to use for image generation.
data CreateImageRequestModel = CreateImageRequestModel
  { 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateImageRequestModel
instance A.FromJSON CreateImageRequestModel where
  parseJSON = A.withObject "CreateImageRequestModel" $ \o ->
    pure CreateImageRequestModel
      

-- | ToJSON CreateImageRequestModel
instance A.ToJSON CreateImageRequestModel where
  toJSON CreateImageRequestModel  =
   _omitNulls
      [ 
      ]


-- | Construct a value of type 'CreateImageRequestModel' (by applying it's required fields, if any)
mkCreateImageRequestModel
  :: CreateImageRequestModel
mkCreateImageRequestModel =
  CreateImageRequestModel
  { 
  }

-- ** CreateMessageRequest
-- | CreateMessageRequest
data CreateMessageRequest = CreateMessageRequest
  { createMessageRequestRole :: !(E'Role3) -- ^ /Required/ "role" - The role of the entity that is creating the message. Currently only &#x60;user&#x60; is supported.
  , createMessageRequestContent :: !(Text) -- ^ /Required/ "content" - The content of the message.
  , createMessageRequestFileIds :: !(Maybe [Text]) -- ^ "file_ids" - A list of [File](/docs/api-reference/files) IDs that the message should use. There can be a maximum of 10 files attached to a message. Useful for tools like &#x60;retrieval&#x60; and &#x60;code_interpreter&#x60; that can access and use files.
  , createMessageRequestMetadata :: !(Maybe A.Value) -- ^ "metadata" - Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateMessageRequest
instance A.FromJSON CreateMessageRequest where
  parseJSON = A.withObject "CreateMessageRequest" $ \o ->
    CreateMessageRequest
      <$> (o .:  "role")
      <*> (o .:  "content")
      <*> (o .:? "file_ids")
      <*> (o .:? "metadata")

-- | ToJSON CreateMessageRequest
instance A.ToJSON CreateMessageRequest where
  toJSON CreateMessageRequest {..} =
   _omitNulls
      [ "role" .= createMessageRequestRole
      , "content" .= createMessageRequestContent
      , "file_ids" .= createMessageRequestFileIds
      , "metadata" .= createMessageRequestMetadata
      ]


-- | Construct a value of type 'CreateMessageRequest' (by applying it's required fields, if any)
mkCreateMessageRequest
  :: E'Role3 -- ^ 'createMessageRequestRole': The role of the entity that is creating the message. Currently only `user` is supported.
  -> Text -- ^ 'createMessageRequestContent': The content of the message.
  -> CreateMessageRequest
mkCreateMessageRequest createMessageRequestRole createMessageRequestContent =
  CreateMessageRequest
  { createMessageRequestRole
  , createMessageRequestContent
  , createMessageRequestFileIds = Nothing
  , createMessageRequestMetadata = Nothing
  }

-- ** CreateModerationRequest
-- | CreateModerationRequest
data CreateModerationRequest = CreateModerationRequest
  { createModerationRequestInput :: !(CreateModerationRequestInput) -- ^ /Required/ "input"
  , createModerationRequestModel :: !(Maybe CreateModerationRequestModel) -- ^ "model"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateModerationRequest
instance A.FromJSON CreateModerationRequest where
  parseJSON = A.withObject "CreateModerationRequest" $ \o ->
    CreateModerationRequest
      <$> (o .:  "input")
      <*> (o .:? "model")

-- | ToJSON CreateModerationRequest
instance A.ToJSON CreateModerationRequest where
  toJSON CreateModerationRequest {..} =
   _omitNulls
      [ "input" .= createModerationRequestInput
      , "model" .= createModerationRequestModel
      ]


-- | Construct a value of type 'CreateModerationRequest' (by applying it's required fields, if any)
mkCreateModerationRequest
  :: CreateModerationRequestInput -- ^ 'createModerationRequestInput' 
  -> CreateModerationRequest
mkCreateModerationRequest createModerationRequestInput =
  CreateModerationRequest
  { createModerationRequestInput
  , createModerationRequestModel = Nothing
  }

-- ** CreateModerationRequestInput
-- | CreateModerationRequestInput
-- The input text to classify
data CreateModerationRequestInput = CreateModerationRequestInput
  { 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateModerationRequestInput
instance A.FromJSON CreateModerationRequestInput where
  parseJSON = A.withObject "CreateModerationRequestInput" $ \o ->
    pure CreateModerationRequestInput
      

-- | ToJSON CreateModerationRequestInput
instance A.ToJSON CreateModerationRequestInput where
  toJSON CreateModerationRequestInput  =
   _omitNulls
      [ 
      ]


-- | Construct a value of type 'CreateModerationRequestInput' (by applying it's required fields, if any)
mkCreateModerationRequestInput
  :: CreateModerationRequestInput
mkCreateModerationRequestInput =
  CreateModerationRequestInput
  { 
  }

-- ** CreateModerationRequestModel
-- | CreateModerationRequestModel
-- Two content moderations models are available: `text-moderation-stable` and `text-moderation-latest`.  The default is `text-moderation-latest` which will be automatically upgraded over time. This ensures you are always using our most accurate model. If you use `text-moderation-stable`, we will provide advanced notice before updating the model. Accuracy of `text-moderation-stable` may be slightly lower than for `text-moderation-latest`. 
data CreateModerationRequestModel = CreateModerationRequestModel
  { 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateModerationRequestModel
instance A.FromJSON CreateModerationRequestModel where
  parseJSON = A.withObject "CreateModerationRequestModel" $ \o ->
    pure CreateModerationRequestModel
      

-- | ToJSON CreateModerationRequestModel
instance A.ToJSON CreateModerationRequestModel where
  toJSON CreateModerationRequestModel  =
   _omitNulls
      [ 
      ]


-- | Construct a value of type 'CreateModerationRequestModel' (by applying it's required fields, if any)
mkCreateModerationRequestModel
  :: CreateModerationRequestModel
mkCreateModerationRequestModel =
  CreateModerationRequestModel
  { 
  }

-- ** CreateModerationResponse
-- | CreateModerationResponse
-- Represents if a given text input is potentially harmful.
data CreateModerationResponse = CreateModerationResponse
  { createModerationResponseId :: !(Text) -- ^ /Required/ "id" - The unique identifier for the moderation request.
  , createModerationResponseModel :: !(Text) -- ^ /Required/ "model" - The model used to generate the moderation results.
  , createModerationResponseResults :: !([CreateModerationResponseResultsInner]) -- ^ /Required/ "results" - A list of moderation objects.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateModerationResponse
instance A.FromJSON CreateModerationResponse where
  parseJSON = A.withObject "CreateModerationResponse" $ \o ->
    CreateModerationResponse
      <$> (o .:  "id")
      <*> (o .:  "model")
      <*> (o .:  "results")

-- | ToJSON CreateModerationResponse
instance A.ToJSON CreateModerationResponse where
  toJSON CreateModerationResponse {..} =
   _omitNulls
      [ "id" .= createModerationResponseId
      , "model" .= createModerationResponseModel
      , "results" .= createModerationResponseResults
      ]


-- | Construct a value of type 'CreateModerationResponse' (by applying it's required fields, if any)
mkCreateModerationResponse
  :: Text -- ^ 'createModerationResponseId': The unique identifier for the moderation request.
  -> Text -- ^ 'createModerationResponseModel': The model used to generate the moderation results.
  -> [CreateModerationResponseResultsInner] -- ^ 'createModerationResponseResults': A list of moderation objects.
  -> CreateModerationResponse
mkCreateModerationResponse createModerationResponseId createModerationResponseModel createModerationResponseResults =
  CreateModerationResponse
  { createModerationResponseId
  , createModerationResponseModel
  , createModerationResponseResults
  }

-- ** CreateModerationResponseResultsInner
-- | CreateModerationResponseResultsInner
data CreateModerationResponseResultsInner = CreateModerationResponseResultsInner
  { createModerationResponseResultsInnerFlagged :: !(Bool) -- ^ /Required/ "flagged" - Whether any of the below categories are flagged.
  , createModerationResponseResultsInnerCategories :: !(CreateModerationResponseResultsInnerCategories) -- ^ /Required/ "categories"
  , createModerationResponseResultsInnerCategoryScores :: !(CreateModerationResponseResultsInnerCategoryScores) -- ^ /Required/ "category_scores"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateModerationResponseResultsInner
instance A.FromJSON CreateModerationResponseResultsInner where
  parseJSON = A.withObject "CreateModerationResponseResultsInner" $ \o ->
    CreateModerationResponseResultsInner
      <$> (o .:  "flagged")
      <*> (o .:  "categories")
      <*> (o .:  "category_scores")

-- | ToJSON CreateModerationResponseResultsInner
instance A.ToJSON CreateModerationResponseResultsInner where
  toJSON CreateModerationResponseResultsInner {..} =
   _omitNulls
      [ "flagged" .= createModerationResponseResultsInnerFlagged
      , "categories" .= createModerationResponseResultsInnerCategories
      , "category_scores" .= createModerationResponseResultsInnerCategoryScores
      ]


-- | Construct a value of type 'CreateModerationResponseResultsInner' (by applying it's required fields, if any)
mkCreateModerationResponseResultsInner
  :: Bool -- ^ 'createModerationResponseResultsInnerFlagged': Whether any of the below categories are flagged.
  -> CreateModerationResponseResultsInnerCategories -- ^ 'createModerationResponseResultsInnerCategories' 
  -> CreateModerationResponseResultsInnerCategoryScores -- ^ 'createModerationResponseResultsInnerCategoryScores' 
  -> CreateModerationResponseResultsInner
mkCreateModerationResponseResultsInner createModerationResponseResultsInnerFlagged createModerationResponseResultsInnerCategories createModerationResponseResultsInnerCategoryScores =
  CreateModerationResponseResultsInner
  { createModerationResponseResultsInnerFlagged
  , createModerationResponseResultsInnerCategories
  , createModerationResponseResultsInnerCategoryScores
  }

-- ** CreateModerationResponseResultsInnerCategories
-- | CreateModerationResponseResultsInnerCategories
-- A list of the categories, and whether they are flagged or not.
data CreateModerationResponseResultsInnerCategories = CreateModerationResponseResultsInnerCategories
  { createModerationResponseResultsInnerCategoriesHate :: !(Bool) -- ^ /Required/ "hate" - Content that expresses, incites, or promotes hate based on race, gender, ethnicity, religion, nationality, sexual orientation, disability status, or caste. Hateful content aimed at non-protected groups (e.g., chess players) is harassment.
  , createModerationResponseResultsInnerCategoriesHateThreatening :: !(Bool) -- ^ /Required/ "hate/threatening" - Hateful content that also includes violence or serious harm towards the targeted group based on race, gender, ethnicity, religion, nationality, sexual orientation, disability status, or caste.
  , createModerationResponseResultsInnerCategoriesHarassment :: !(Bool) -- ^ /Required/ "harassment" - Content that expresses, incites, or promotes harassing language towards any target.
  , createModerationResponseResultsInnerCategoriesHarassmentThreatening :: !(Bool) -- ^ /Required/ "harassment/threatening" - Harassment content that also includes violence or serious harm towards any target.
  , createModerationResponseResultsInnerCategoriesSelfHarm :: !(Bool) -- ^ /Required/ "self-harm" - Content that promotes, encourages, or depicts acts of self-harm, such as suicide, cutting, and eating disorders.
  , createModerationResponseResultsInnerCategoriesSelfHarmIntent :: !(Bool) -- ^ /Required/ "self-harm/intent" - Content where the speaker expresses that they are engaging or intend to engage in acts of self-harm, such as suicide, cutting, and eating disorders.
  , createModerationResponseResultsInnerCategoriesSelfHarmInstructions :: !(Bool) -- ^ /Required/ "self-harm/instructions" - Content that encourages performing acts of self-harm, such as suicide, cutting, and eating disorders, or that gives instructions or advice on how to commit such acts.
  , createModerationResponseResultsInnerCategoriesSexual :: !(Bool) -- ^ /Required/ "sexual" - Content meant to arouse sexual excitement, such as the description of sexual activity, or that promotes sexual services (excluding sex education and wellness).
  , createModerationResponseResultsInnerCategoriesSexualMinors :: !(Bool) -- ^ /Required/ "sexual/minors" - Sexual content that includes an individual who is under 18 years old.
  , createModerationResponseResultsInnerCategoriesViolence :: !(Bool) -- ^ /Required/ "violence" - Content that depicts death, violence, or physical injury.
  , createModerationResponseResultsInnerCategoriesViolenceGraphic :: !(Bool) -- ^ /Required/ "violence/graphic" - Content that depicts death, violence, or physical injury in graphic detail.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateModerationResponseResultsInnerCategories
instance A.FromJSON CreateModerationResponseResultsInnerCategories where
  parseJSON = A.withObject "CreateModerationResponseResultsInnerCategories" $ \o ->
    CreateModerationResponseResultsInnerCategories
      <$> (o .:  "hate")
      <*> (o .:  "hate/threatening")
      <*> (o .:  "harassment")
      <*> (o .:  "harassment/threatening")
      <*> (o .:  "self-harm")
      <*> (o .:  "self-harm/intent")
      <*> (o .:  "self-harm/instructions")
      <*> (o .:  "sexual")
      <*> (o .:  "sexual/minors")
      <*> (o .:  "violence")
      <*> (o .:  "violence/graphic")

-- | ToJSON CreateModerationResponseResultsInnerCategories
instance A.ToJSON CreateModerationResponseResultsInnerCategories where
  toJSON CreateModerationResponseResultsInnerCategories {..} =
   _omitNulls
      [ "hate" .= createModerationResponseResultsInnerCategoriesHate
      , "hate/threatening" .= createModerationResponseResultsInnerCategoriesHateThreatening
      , "harassment" .= createModerationResponseResultsInnerCategoriesHarassment
      , "harassment/threatening" .= createModerationResponseResultsInnerCategoriesHarassmentThreatening
      , "self-harm" .= createModerationResponseResultsInnerCategoriesSelfHarm
      , "self-harm/intent" .= createModerationResponseResultsInnerCategoriesSelfHarmIntent
      , "self-harm/instructions" .= createModerationResponseResultsInnerCategoriesSelfHarmInstructions
      , "sexual" .= createModerationResponseResultsInnerCategoriesSexual
      , "sexual/minors" .= createModerationResponseResultsInnerCategoriesSexualMinors
      , "violence" .= createModerationResponseResultsInnerCategoriesViolence
      , "violence/graphic" .= createModerationResponseResultsInnerCategoriesViolenceGraphic
      ]


-- | Construct a value of type 'CreateModerationResponseResultsInnerCategories' (by applying it's required fields, if any)
mkCreateModerationResponseResultsInnerCategories
  :: Bool -- ^ 'createModerationResponseResultsInnerCategoriesHate': Content that expresses, incites, or promotes hate based on race, gender, ethnicity, religion, nationality, sexual orientation, disability status, or caste. Hateful content aimed at non-protected groups (e.g., chess players) is harassment.
  -> Bool -- ^ 'createModerationResponseResultsInnerCategoriesHateThreatening': Hateful content that also includes violence or serious harm towards the targeted group based on race, gender, ethnicity, religion, nationality, sexual orientation, disability status, or caste.
  -> Bool -- ^ 'createModerationResponseResultsInnerCategoriesHarassment': Content that expresses, incites, or promotes harassing language towards any target.
  -> Bool -- ^ 'createModerationResponseResultsInnerCategoriesHarassmentThreatening': Harassment content that also includes violence or serious harm towards any target.
  -> Bool -- ^ 'createModerationResponseResultsInnerCategoriesSelfHarm': Content that promotes, encourages, or depicts acts of self-harm, such as suicide, cutting, and eating disorders.
  -> Bool -- ^ 'createModerationResponseResultsInnerCategoriesSelfHarmIntent': Content where the speaker expresses that they are engaging or intend to engage in acts of self-harm, such as suicide, cutting, and eating disorders.
  -> Bool -- ^ 'createModerationResponseResultsInnerCategoriesSelfHarmInstructions': Content that encourages performing acts of self-harm, such as suicide, cutting, and eating disorders, or that gives instructions or advice on how to commit such acts.
  -> Bool -- ^ 'createModerationResponseResultsInnerCategoriesSexual': Content meant to arouse sexual excitement, such as the description of sexual activity, or that promotes sexual services (excluding sex education and wellness).
  -> Bool -- ^ 'createModerationResponseResultsInnerCategoriesSexualMinors': Sexual content that includes an individual who is under 18 years old.
  -> Bool -- ^ 'createModerationResponseResultsInnerCategoriesViolence': Content that depicts death, violence, or physical injury.
  -> Bool -- ^ 'createModerationResponseResultsInnerCategoriesViolenceGraphic': Content that depicts death, violence, or physical injury in graphic detail.
  -> CreateModerationResponseResultsInnerCategories
mkCreateModerationResponseResultsInnerCategories createModerationResponseResultsInnerCategoriesHate createModerationResponseResultsInnerCategoriesHateThreatening createModerationResponseResultsInnerCategoriesHarassment createModerationResponseResultsInnerCategoriesHarassmentThreatening createModerationResponseResultsInnerCategoriesSelfHarm createModerationResponseResultsInnerCategoriesSelfHarmIntent createModerationResponseResultsInnerCategoriesSelfHarmInstructions createModerationResponseResultsInnerCategoriesSexual createModerationResponseResultsInnerCategoriesSexualMinors createModerationResponseResultsInnerCategoriesViolence createModerationResponseResultsInnerCategoriesViolenceGraphic =
  CreateModerationResponseResultsInnerCategories
  { createModerationResponseResultsInnerCategoriesHate
  , createModerationResponseResultsInnerCategoriesHateThreatening
  , createModerationResponseResultsInnerCategoriesHarassment
  , createModerationResponseResultsInnerCategoriesHarassmentThreatening
  , createModerationResponseResultsInnerCategoriesSelfHarm
  , createModerationResponseResultsInnerCategoriesSelfHarmIntent
  , createModerationResponseResultsInnerCategoriesSelfHarmInstructions
  , createModerationResponseResultsInnerCategoriesSexual
  , createModerationResponseResultsInnerCategoriesSexualMinors
  , createModerationResponseResultsInnerCategoriesViolence
  , createModerationResponseResultsInnerCategoriesViolenceGraphic
  }

-- ** CreateModerationResponseResultsInnerCategoryScores
-- | CreateModerationResponseResultsInnerCategoryScores
-- A list of the categories along with their scores as predicted by model.
data CreateModerationResponseResultsInnerCategoryScores = CreateModerationResponseResultsInnerCategoryScores
  { createModerationResponseResultsInnerCategoryScoresHate :: !(Double) -- ^ /Required/ "hate" - The score for the category &#39;hate&#39;.
  , createModerationResponseResultsInnerCategoryScoresHateThreatening :: !(Double) -- ^ /Required/ "hate/threatening" - The score for the category &#39;hate/threatening&#39;.
  , createModerationResponseResultsInnerCategoryScoresHarassment :: !(Double) -- ^ /Required/ "harassment" - The score for the category &#39;harassment&#39;.
  , createModerationResponseResultsInnerCategoryScoresHarassmentThreatening :: !(Double) -- ^ /Required/ "harassment/threatening" - The score for the category &#39;harassment/threatening&#39;.
  , createModerationResponseResultsInnerCategoryScoresSelfHarm :: !(Double) -- ^ /Required/ "self-harm" - The score for the category &#39;self-harm&#39;.
  , createModerationResponseResultsInnerCategoryScoresSelfHarmIntent :: !(Double) -- ^ /Required/ "self-harm/intent" - The score for the category &#39;self-harm/intent&#39;.
  , createModerationResponseResultsInnerCategoryScoresSelfHarmInstructions :: !(Double) -- ^ /Required/ "self-harm/instructions" - The score for the category &#39;self-harm/instructions&#39;.
  , createModerationResponseResultsInnerCategoryScoresSexual :: !(Double) -- ^ /Required/ "sexual" - The score for the category &#39;sexual&#39;.
  , createModerationResponseResultsInnerCategoryScoresSexualMinors :: !(Double) -- ^ /Required/ "sexual/minors" - The score for the category &#39;sexual/minors&#39;.
  , createModerationResponseResultsInnerCategoryScoresViolence :: !(Double) -- ^ /Required/ "violence" - The score for the category &#39;violence&#39;.
  , createModerationResponseResultsInnerCategoryScoresViolenceGraphic :: !(Double) -- ^ /Required/ "violence/graphic" - The score for the category &#39;violence/graphic&#39;.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateModerationResponseResultsInnerCategoryScores
instance A.FromJSON CreateModerationResponseResultsInnerCategoryScores where
  parseJSON = A.withObject "CreateModerationResponseResultsInnerCategoryScores" $ \o ->
    CreateModerationResponseResultsInnerCategoryScores
      <$> (o .:  "hate")
      <*> (o .:  "hate/threatening")
      <*> (o .:  "harassment")
      <*> (o .:  "harassment/threatening")
      <*> (o .:  "self-harm")
      <*> (o .:  "self-harm/intent")
      <*> (o .:  "self-harm/instructions")
      <*> (o .:  "sexual")
      <*> (o .:  "sexual/minors")
      <*> (o .:  "violence")
      <*> (o .:  "violence/graphic")

-- | ToJSON CreateModerationResponseResultsInnerCategoryScores
instance A.ToJSON CreateModerationResponseResultsInnerCategoryScores where
  toJSON CreateModerationResponseResultsInnerCategoryScores {..} =
   _omitNulls
      [ "hate" .= createModerationResponseResultsInnerCategoryScoresHate
      , "hate/threatening" .= createModerationResponseResultsInnerCategoryScoresHateThreatening
      , "harassment" .= createModerationResponseResultsInnerCategoryScoresHarassment
      , "harassment/threatening" .= createModerationResponseResultsInnerCategoryScoresHarassmentThreatening
      , "self-harm" .= createModerationResponseResultsInnerCategoryScoresSelfHarm
      , "self-harm/intent" .= createModerationResponseResultsInnerCategoryScoresSelfHarmIntent
      , "self-harm/instructions" .= createModerationResponseResultsInnerCategoryScoresSelfHarmInstructions
      , "sexual" .= createModerationResponseResultsInnerCategoryScoresSexual
      , "sexual/minors" .= createModerationResponseResultsInnerCategoryScoresSexualMinors
      , "violence" .= createModerationResponseResultsInnerCategoryScoresViolence
      , "violence/graphic" .= createModerationResponseResultsInnerCategoryScoresViolenceGraphic
      ]


-- | Construct a value of type 'CreateModerationResponseResultsInnerCategoryScores' (by applying it's required fields, if any)
mkCreateModerationResponseResultsInnerCategoryScores
  :: Double -- ^ 'createModerationResponseResultsInnerCategoryScoresHate': The score for the category 'hate'.
  -> Double -- ^ 'createModerationResponseResultsInnerCategoryScoresHateThreatening': The score for the category 'hate/threatening'.
  -> Double -- ^ 'createModerationResponseResultsInnerCategoryScoresHarassment': The score for the category 'harassment'.
  -> Double -- ^ 'createModerationResponseResultsInnerCategoryScoresHarassmentThreatening': The score for the category 'harassment/threatening'.
  -> Double -- ^ 'createModerationResponseResultsInnerCategoryScoresSelfHarm': The score for the category 'self-harm'.
  -> Double -- ^ 'createModerationResponseResultsInnerCategoryScoresSelfHarmIntent': The score for the category 'self-harm/intent'.
  -> Double -- ^ 'createModerationResponseResultsInnerCategoryScoresSelfHarmInstructions': The score for the category 'self-harm/instructions'.
  -> Double -- ^ 'createModerationResponseResultsInnerCategoryScoresSexual': The score for the category 'sexual'.
  -> Double -- ^ 'createModerationResponseResultsInnerCategoryScoresSexualMinors': The score for the category 'sexual/minors'.
  -> Double -- ^ 'createModerationResponseResultsInnerCategoryScoresViolence': The score for the category 'violence'.
  -> Double -- ^ 'createModerationResponseResultsInnerCategoryScoresViolenceGraphic': The score for the category 'violence/graphic'.
  -> CreateModerationResponseResultsInnerCategoryScores
mkCreateModerationResponseResultsInnerCategoryScores createModerationResponseResultsInnerCategoryScoresHate createModerationResponseResultsInnerCategoryScoresHateThreatening createModerationResponseResultsInnerCategoryScoresHarassment createModerationResponseResultsInnerCategoryScoresHarassmentThreatening createModerationResponseResultsInnerCategoryScoresSelfHarm createModerationResponseResultsInnerCategoryScoresSelfHarmIntent createModerationResponseResultsInnerCategoryScoresSelfHarmInstructions createModerationResponseResultsInnerCategoryScoresSexual createModerationResponseResultsInnerCategoryScoresSexualMinors createModerationResponseResultsInnerCategoryScoresViolence createModerationResponseResultsInnerCategoryScoresViolenceGraphic =
  CreateModerationResponseResultsInnerCategoryScores
  { createModerationResponseResultsInnerCategoryScoresHate
  , createModerationResponseResultsInnerCategoryScoresHateThreatening
  , createModerationResponseResultsInnerCategoryScoresHarassment
  , createModerationResponseResultsInnerCategoryScoresHarassmentThreatening
  , createModerationResponseResultsInnerCategoryScoresSelfHarm
  , createModerationResponseResultsInnerCategoryScoresSelfHarmIntent
  , createModerationResponseResultsInnerCategoryScoresSelfHarmInstructions
  , createModerationResponseResultsInnerCategoryScoresSexual
  , createModerationResponseResultsInnerCategoryScoresSexualMinors
  , createModerationResponseResultsInnerCategoryScoresViolence
  , createModerationResponseResultsInnerCategoryScoresViolenceGraphic
  }

-- ** CreateRunRequest
-- | CreateRunRequest
data CreateRunRequest = CreateRunRequest
  { createRunRequestAssistantId :: !(Text) -- ^ /Required/ "assistant_id" - The ID of the [assistant](/docs/api-reference/assistants) to use to execute this run.
  , createRunRequestModel :: !(Maybe Text) -- ^ "model" - The ID of the [Model](/docs/api-reference/models) to be used to execute this run. If a value is provided here, it will override the model associated with the assistant. If not, the model associated with the assistant will be used.
  , createRunRequestInstructions :: !(Maybe Text) -- ^ "instructions" - Overrides the [instructions](/docs/api-reference/assistants/createAssistant) of the assistant. This is useful for modifying the behavior on a per-run basis.
  , createRunRequestAdditionalInstructions :: !(Maybe Text) -- ^ "additional_instructions" - Appends additional instructions at the end of the instructions for the run. This is useful for modifying the behavior on a per-run basis without overriding other instructions.
  , createRunRequestTools :: !(Maybe [AssistantObjectToolsInner]) -- ^ "tools" - Override the tools the assistant can use for this run. This is useful for modifying the behavior on a per-run basis.
  , createRunRequestMetadata :: !(Maybe A.Value) -- ^ "metadata" - Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateRunRequest
instance A.FromJSON CreateRunRequest where
  parseJSON = A.withObject "CreateRunRequest" $ \o ->
    CreateRunRequest
      <$> (o .:  "assistant_id")
      <*> (o .:? "model")
      <*> (o .:? "instructions")
      <*> (o .:? "additional_instructions")
      <*> (o .:? "tools")
      <*> (o .:? "metadata")

-- | ToJSON CreateRunRequest
instance A.ToJSON CreateRunRequest where
  toJSON CreateRunRequest {..} =
   _omitNulls
      [ "assistant_id" .= createRunRequestAssistantId
      , "model" .= createRunRequestModel
      , "instructions" .= createRunRequestInstructions
      , "additional_instructions" .= createRunRequestAdditionalInstructions
      , "tools" .= createRunRequestTools
      , "metadata" .= createRunRequestMetadata
      ]


-- | Construct a value of type 'CreateRunRequest' (by applying it's required fields, if any)
mkCreateRunRequest
  :: Text -- ^ 'createRunRequestAssistantId': The ID of the [assistant](/docs/api-reference/assistants) to use to execute this run.
  -> CreateRunRequest
mkCreateRunRequest createRunRequestAssistantId =
  CreateRunRequest
  { createRunRequestAssistantId
  , createRunRequestModel = Nothing
  , createRunRequestInstructions = Nothing
  , createRunRequestAdditionalInstructions = Nothing
  , createRunRequestTools = Nothing
  , createRunRequestMetadata = Nothing
  }

-- ** CreateSpeechRequest
-- | CreateSpeechRequest
data CreateSpeechRequest = CreateSpeechRequest
  { createSpeechRequestModel :: !(CreateSpeechRequestModel) -- ^ /Required/ "model"
  , createSpeechRequestInput :: !(Text) -- ^ /Required/ "input" - The text to generate audio for. The maximum length is 4096 characters.
  , createSpeechRequestVoice :: !(E'Voice) -- ^ /Required/ "voice" - The voice to use when generating the audio. Supported voices are &#x60;alloy&#x60;, &#x60;echo&#x60;, &#x60;fable&#x60;, &#x60;onyx&#x60;, &#x60;nova&#x60;, and &#x60;shimmer&#x60;. Previews of the voices are available in the [Text to speech guide](/docs/guides/text-to-speech/voice-options).
  , createSpeechRequestResponseFormat :: !(Maybe E'ResponseFormat2) -- ^ "response_format" - The format to audio in. Supported formats are &#x60;mp3&#x60;, &#x60;opus&#x60;, &#x60;aac&#x60;, &#x60;flac&#x60;, &#x60;wav&#x60;, and &#x60;pcm&#x60;.
  , createSpeechRequestSpeed :: !(Maybe Double) -- ^ "speed" - The speed of the generated audio. Select a value from &#x60;0.25&#x60; to &#x60;4.0&#x60;. &#x60;1.0&#x60; is the default.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateSpeechRequest
instance A.FromJSON CreateSpeechRequest where
  parseJSON = A.withObject "CreateSpeechRequest" $ \o ->
    CreateSpeechRequest
      <$> (o .:  "model")
      <*> (o .:  "input")
      <*> (o .:  "voice")
      <*> (o .:? "response_format")
      <*> (o .:? "speed")

-- | ToJSON CreateSpeechRequest
instance A.ToJSON CreateSpeechRequest where
  toJSON CreateSpeechRequest {..} =
   _omitNulls
      [ "model" .= createSpeechRequestModel
      , "input" .= createSpeechRequestInput
      , "voice" .= createSpeechRequestVoice
      , "response_format" .= createSpeechRequestResponseFormat
      , "speed" .= createSpeechRequestSpeed
      ]


-- | Construct a value of type 'CreateSpeechRequest' (by applying it's required fields, if any)
mkCreateSpeechRequest
  :: CreateSpeechRequestModel -- ^ 'createSpeechRequestModel' 
  -> Text -- ^ 'createSpeechRequestInput': The text to generate audio for. The maximum length is 4096 characters.
  -> E'Voice -- ^ 'createSpeechRequestVoice': The voice to use when generating the audio. Supported voices are `alloy`, `echo`, `fable`, `onyx`, `nova`, and `shimmer`. Previews of the voices are available in the [Text to speech guide](/docs/guides/text-to-speech/voice-options).
  -> CreateSpeechRequest
mkCreateSpeechRequest createSpeechRequestModel createSpeechRequestInput createSpeechRequestVoice =
  CreateSpeechRequest
  { createSpeechRequestModel
  , createSpeechRequestInput
  , createSpeechRequestVoice
  , createSpeechRequestResponseFormat = Nothing
  , createSpeechRequestSpeed = Nothing
  }

-- ** CreateSpeechRequestModel
-- | CreateSpeechRequestModel
-- One of the available [TTS models](/docs/models/tts): `tts-1` or `tts-1-hd` 
data CreateSpeechRequestModel = CreateSpeechRequestModel
  { 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateSpeechRequestModel
instance A.FromJSON CreateSpeechRequestModel where
  parseJSON = A.withObject "CreateSpeechRequestModel" $ \o ->
    pure CreateSpeechRequestModel
      

-- | ToJSON CreateSpeechRequestModel
instance A.ToJSON CreateSpeechRequestModel where
  toJSON CreateSpeechRequestModel  =
   _omitNulls
      [ 
      ]


-- | Construct a value of type 'CreateSpeechRequestModel' (by applying it's required fields, if any)
mkCreateSpeechRequestModel
  :: CreateSpeechRequestModel
mkCreateSpeechRequestModel =
  CreateSpeechRequestModel
  { 
  }

-- ** CreateThreadAndRunRequest
-- | CreateThreadAndRunRequest
data CreateThreadAndRunRequest = CreateThreadAndRunRequest
  { createThreadAndRunRequestAssistantId :: !(Text) -- ^ /Required/ "assistant_id" - The ID of the [assistant](/docs/api-reference/assistants) to use to execute this run.
  , createThreadAndRunRequestThread :: !(Maybe CreateThreadRequest) -- ^ "thread"
  , createThreadAndRunRequestModel :: !(Maybe Text) -- ^ "model" - The ID of the [Model](/docs/api-reference/models) to be used to execute this run. If a value is provided here, it will override the model associated with the assistant. If not, the model associated with the assistant will be used.
  , createThreadAndRunRequestInstructions :: !(Maybe Text) -- ^ "instructions" - Override the default system message of the assistant. This is useful for modifying the behavior on a per-run basis.
  , createThreadAndRunRequestTools :: !(Maybe [CreateThreadAndRunRequestToolsInner]) -- ^ "tools" - Override the tools the assistant can use for this run. This is useful for modifying the behavior on a per-run basis.
  , createThreadAndRunRequestMetadata :: !(Maybe A.Value) -- ^ "metadata" - Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateThreadAndRunRequest
instance A.FromJSON CreateThreadAndRunRequest where
  parseJSON = A.withObject "CreateThreadAndRunRequest" $ \o ->
    CreateThreadAndRunRequest
      <$> (o .:  "assistant_id")
      <*> (o .:? "thread")
      <*> (o .:? "model")
      <*> (o .:? "instructions")
      <*> (o .:? "tools")
      <*> (o .:? "metadata")

-- | ToJSON CreateThreadAndRunRequest
instance A.ToJSON CreateThreadAndRunRequest where
  toJSON CreateThreadAndRunRequest {..} =
   _omitNulls
      [ "assistant_id" .= createThreadAndRunRequestAssistantId
      , "thread" .= createThreadAndRunRequestThread
      , "model" .= createThreadAndRunRequestModel
      , "instructions" .= createThreadAndRunRequestInstructions
      , "tools" .= createThreadAndRunRequestTools
      , "metadata" .= createThreadAndRunRequestMetadata
      ]


-- | Construct a value of type 'CreateThreadAndRunRequest' (by applying it's required fields, if any)
mkCreateThreadAndRunRequest
  :: Text -- ^ 'createThreadAndRunRequestAssistantId': The ID of the [assistant](/docs/api-reference/assistants) to use to execute this run.
  -> CreateThreadAndRunRequest
mkCreateThreadAndRunRequest createThreadAndRunRequestAssistantId =
  CreateThreadAndRunRequest
  { createThreadAndRunRequestAssistantId
  , createThreadAndRunRequestThread = Nothing
  , createThreadAndRunRequestModel = Nothing
  , createThreadAndRunRequestInstructions = Nothing
  , createThreadAndRunRequestTools = Nothing
  , createThreadAndRunRequestMetadata = Nothing
  }

-- ** CreateThreadAndRunRequestToolsInner
-- | CreateThreadAndRunRequestToolsInner
data CreateThreadAndRunRequestToolsInner = CreateThreadAndRunRequestToolsInner
  { createThreadAndRunRequestToolsInnerType :: !(E'Role) -- ^ /Required/ "type" - The type of tool being defined: &#x60;function&#x60;
  , createThreadAndRunRequestToolsInnerFunction :: !(FunctionObject) -- ^ /Required/ "function"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateThreadAndRunRequestToolsInner
instance A.FromJSON CreateThreadAndRunRequestToolsInner where
  parseJSON = A.withObject "CreateThreadAndRunRequestToolsInner" $ \o ->
    CreateThreadAndRunRequestToolsInner
      <$> (o .:  "type")
      <*> (o .:  "function")

-- | ToJSON CreateThreadAndRunRequestToolsInner
instance A.ToJSON CreateThreadAndRunRequestToolsInner where
  toJSON CreateThreadAndRunRequestToolsInner {..} =
   _omitNulls
      [ "type" .= createThreadAndRunRequestToolsInnerType
      , "function" .= createThreadAndRunRequestToolsInnerFunction
      ]


-- | Construct a value of type 'CreateThreadAndRunRequestToolsInner' (by applying it's required fields, if any)
mkCreateThreadAndRunRequestToolsInner
  :: E'Role -- ^ 'createThreadAndRunRequestToolsInnerType': The type of tool being defined: `function`
  -> FunctionObject -- ^ 'createThreadAndRunRequestToolsInnerFunction' 
  -> CreateThreadAndRunRequestToolsInner
mkCreateThreadAndRunRequestToolsInner createThreadAndRunRequestToolsInnerType createThreadAndRunRequestToolsInnerFunction =
  CreateThreadAndRunRequestToolsInner
  { createThreadAndRunRequestToolsInnerType
  , createThreadAndRunRequestToolsInnerFunction
  }

-- ** CreateThreadRequest
-- | CreateThreadRequest
data CreateThreadRequest = CreateThreadRequest
  { createThreadRequestMessages :: !(Maybe [CreateMessageRequest]) -- ^ "messages" - A list of [messages](/docs/api-reference/messages) to start the thread with.
  , createThreadRequestMetadata :: !(Maybe A.Value) -- ^ "metadata" - Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateThreadRequest
instance A.FromJSON CreateThreadRequest where
  parseJSON = A.withObject "CreateThreadRequest" $ \o ->
    CreateThreadRequest
      <$> (o .:? "messages")
      <*> (o .:? "metadata")

-- | ToJSON CreateThreadRequest
instance A.ToJSON CreateThreadRequest where
  toJSON CreateThreadRequest {..} =
   _omitNulls
      [ "messages" .= createThreadRequestMessages
      , "metadata" .= createThreadRequestMetadata
      ]


-- | Construct a value of type 'CreateThreadRequest' (by applying it's required fields, if any)
mkCreateThreadRequest
  :: CreateThreadRequest
mkCreateThreadRequest =
  CreateThreadRequest
  { createThreadRequestMessages = Nothing
  , createThreadRequestMetadata = Nothing
  }

-- ** CreateTranscription200Response
-- | CreateTranscription200Response
data CreateTranscription200Response = CreateTranscription200Response
  { createTranscription200ResponseText :: !(Text) -- ^ /Required/ "text" - The transcribed text.
  , createTranscription200ResponseLanguage :: !(Text) -- ^ /Required/ "language" - The language of the input audio.
  , createTranscription200ResponseDuration :: !(Text) -- ^ /Required/ "duration" - The duration of the input audio.
  , createTranscription200ResponseWords :: !(Maybe [TranscriptionWord]) -- ^ "words" - Extracted words and their corresponding timestamps.
  , createTranscription200ResponseSegments :: !(Maybe [TranscriptionSegment]) -- ^ "segments" - Segments of the transcribed text and their corresponding details.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateTranscription200Response
instance A.FromJSON CreateTranscription200Response where
  parseJSON = A.withObject "CreateTranscription200Response" $ \o ->
    CreateTranscription200Response
      <$> (o .:  "text")
      <*> (o .:  "language")
      <*> (o .:  "duration")
      <*> (o .:? "words")
      <*> (o .:? "segments")

-- | ToJSON CreateTranscription200Response
instance A.ToJSON CreateTranscription200Response where
  toJSON CreateTranscription200Response {..} =
   _omitNulls
      [ "text" .= createTranscription200ResponseText
      , "language" .= createTranscription200ResponseLanguage
      , "duration" .= createTranscription200ResponseDuration
      , "words" .= createTranscription200ResponseWords
      , "segments" .= createTranscription200ResponseSegments
      ]


-- | Construct a value of type 'CreateTranscription200Response' (by applying it's required fields, if any)
mkCreateTranscription200Response
  :: Text -- ^ 'createTranscription200ResponseText': The transcribed text.
  -> Text -- ^ 'createTranscription200ResponseLanguage': The language of the input audio.
  -> Text -- ^ 'createTranscription200ResponseDuration': The duration of the input audio.
  -> CreateTranscription200Response
mkCreateTranscription200Response createTranscription200ResponseText createTranscription200ResponseLanguage createTranscription200ResponseDuration =
  CreateTranscription200Response
  { createTranscription200ResponseText
  , createTranscription200ResponseLanguage
  , createTranscription200ResponseDuration
  , createTranscription200ResponseWords = Nothing
  , createTranscription200ResponseSegments = Nothing
  }

-- ** CreateTranscriptionResponseJson
-- | CreateTranscriptionResponseJson
-- Represents a transcription response returned by model, based on the provided input.
data CreateTranscriptionResponseJson = CreateTranscriptionResponseJson
  { createTranscriptionResponseJsonText :: !(Text) -- ^ /Required/ "text" - The transcribed text.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateTranscriptionResponseJson
instance A.FromJSON CreateTranscriptionResponseJson where
  parseJSON = A.withObject "CreateTranscriptionResponseJson" $ \o ->
    CreateTranscriptionResponseJson
      <$> (o .:  "text")

-- | ToJSON CreateTranscriptionResponseJson
instance A.ToJSON CreateTranscriptionResponseJson where
  toJSON CreateTranscriptionResponseJson {..} =
   _omitNulls
      [ "text" .= createTranscriptionResponseJsonText
      ]


-- | Construct a value of type 'CreateTranscriptionResponseJson' (by applying it's required fields, if any)
mkCreateTranscriptionResponseJson
  :: Text -- ^ 'createTranscriptionResponseJsonText': The transcribed text.
  -> CreateTranscriptionResponseJson
mkCreateTranscriptionResponseJson createTranscriptionResponseJsonText =
  CreateTranscriptionResponseJson
  { createTranscriptionResponseJsonText
  }

-- ** CreateTranscriptionResponseVerboseJson
-- | CreateTranscriptionResponseVerboseJson
-- Represents a verbose json transcription response returned by model, based on the provided input.
data CreateTranscriptionResponseVerboseJson = CreateTranscriptionResponseVerboseJson
  { createTranscriptionResponseVerboseJsonLanguage :: !(Text) -- ^ /Required/ "language" - The language of the input audio.
  , createTranscriptionResponseVerboseJsonDuration :: !(Text) -- ^ /Required/ "duration" - The duration of the input audio.
  , createTranscriptionResponseVerboseJsonText :: !(Text) -- ^ /Required/ "text" - The transcribed text.
  , createTranscriptionResponseVerboseJsonWords :: !(Maybe [TranscriptionWord]) -- ^ "words" - Extracted words and their corresponding timestamps.
  , createTranscriptionResponseVerboseJsonSegments :: !(Maybe [TranscriptionSegment]) -- ^ "segments" - Segments of the transcribed text and their corresponding details.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateTranscriptionResponseVerboseJson
instance A.FromJSON CreateTranscriptionResponseVerboseJson where
  parseJSON = A.withObject "CreateTranscriptionResponseVerboseJson" $ \o ->
    CreateTranscriptionResponseVerboseJson
      <$> (o .:  "language")
      <*> (o .:  "duration")
      <*> (o .:  "text")
      <*> (o .:? "words")
      <*> (o .:? "segments")

-- | ToJSON CreateTranscriptionResponseVerboseJson
instance A.ToJSON CreateTranscriptionResponseVerboseJson where
  toJSON CreateTranscriptionResponseVerboseJson {..} =
   _omitNulls
      [ "language" .= createTranscriptionResponseVerboseJsonLanguage
      , "duration" .= createTranscriptionResponseVerboseJsonDuration
      , "text" .= createTranscriptionResponseVerboseJsonText
      , "words" .= createTranscriptionResponseVerboseJsonWords
      , "segments" .= createTranscriptionResponseVerboseJsonSegments
      ]


-- | Construct a value of type 'CreateTranscriptionResponseVerboseJson' (by applying it's required fields, if any)
mkCreateTranscriptionResponseVerboseJson
  :: Text -- ^ 'createTranscriptionResponseVerboseJsonLanguage': The language of the input audio.
  -> Text -- ^ 'createTranscriptionResponseVerboseJsonDuration': The duration of the input audio.
  -> Text -- ^ 'createTranscriptionResponseVerboseJsonText': The transcribed text.
  -> CreateTranscriptionResponseVerboseJson
mkCreateTranscriptionResponseVerboseJson createTranscriptionResponseVerboseJsonLanguage createTranscriptionResponseVerboseJsonDuration createTranscriptionResponseVerboseJsonText =
  CreateTranscriptionResponseVerboseJson
  { createTranscriptionResponseVerboseJsonLanguage
  , createTranscriptionResponseVerboseJsonDuration
  , createTranscriptionResponseVerboseJsonText
  , createTranscriptionResponseVerboseJsonWords = Nothing
  , createTranscriptionResponseVerboseJsonSegments = Nothing
  }

-- ** CreateTranslation200Response
-- | CreateTranslation200Response
data CreateTranslation200Response = CreateTranslation200Response
  { createTranslation200ResponseText :: !(Text) -- ^ /Required/ "text" - The translated text.
  , createTranslation200ResponseLanguage :: !(Text) -- ^ /Required/ "language" - The language of the output translation (always &#x60;english&#x60;).
  , createTranslation200ResponseDuration :: !(Text) -- ^ /Required/ "duration" - The duration of the input audio.
  , createTranslation200ResponseSegments :: !(Maybe [TranscriptionSegment]) -- ^ "segments" - Segments of the translated text and their corresponding details.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateTranslation200Response
instance A.FromJSON CreateTranslation200Response where
  parseJSON = A.withObject "CreateTranslation200Response" $ \o ->
    CreateTranslation200Response
      <$> (o .:  "text")
      <*> (o .:  "language")
      <*> (o .:  "duration")
      <*> (o .:? "segments")

-- | ToJSON CreateTranslation200Response
instance A.ToJSON CreateTranslation200Response where
  toJSON CreateTranslation200Response {..} =
   _omitNulls
      [ "text" .= createTranslation200ResponseText
      , "language" .= createTranslation200ResponseLanguage
      , "duration" .= createTranslation200ResponseDuration
      , "segments" .= createTranslation200ResponseSegments
      ]


-- | Construct a value of type 'CreateTranslation200Response' (by applying it's required fields, if any)
mkCreateTranslation200Response
  :: Text -- ^ 'createTranslation200ResponseText': The translated text.
  -> Text -- ^ 'createTranslation200ResponseLanguage': The language of the output translation (always `english`).
  -> Text -- ^ 'createTranslation200ResponseDuration': The duration of the input audio.
  -> CreateTranslation200Response
mkCreateTranslation200Response createTranslation200ResponseText createTranslation200ResponseLanguage createTranslation200ResponseDuration =
  CreateTranslation200Response
  { createTranslation200ResponseText
  , createTranslation200ResponseLanguage
  , createTranslation200ResponseDuration
  , createTranslation200ResponseSegments = Nothing
  }

-- ** CreateTranslationResponseJson
-- | CreateTranslationResponseJson
data CreateTranslationResponseJson = CreateTranslationResponseJson
  { createTranslationResponseJsonText :: !(Text) -- ^ /Required/ "text"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateTranslationResponseJson
instance A.FromJSON CreateTranslationResponseJson where
  parseJSON = A.withObject "CreateTranslationResponseJson" $ \o ->
    CreateTranslationResponseJson
      <$> (o .:  "text")

-- | ToJSON CreateTranslationResponseJson
instance A.ToJSON CreateTranslationResponseJson where
  toJSON CreateTranslationResponseJson {..} =
   _omitNulls
      [ "text" .= createTranslationResponseJsonText
      ]


-- | Construct a value of type 'CreateTranslationResponseJson' (by applying it's required fields, if any)
mkCreateTranslationResponseJson
  :: Text -- ^ 'createTranslationResponseJsonText' 
  -> CreateTranslationResponseJson
mkCreateTranslationResponseJson createTranslationResponseJsonText =
  CreateTranslationResponseJson
  { createTranslationResponseJsonText
  }

-- ** CreateTranslationResponseVerboseJson
-- | CreateTranslationResponseVerboseJson
data CreateTranslationResponseVerboseJson = CreateTranslationResponseVerboseJson
  { createTranslationResponseVerboseJsonLanguage :: !(Text) -- ^ /Required/ "language" - The language of the output translation (always &#x60;english&#x60;).
  , createTranslationResponseVerboseJsonDuration :: !(Text) -- ^ /Required/ "duration" - The duration of the input audio.
  , createTranslationResponseVerboseJsonText :: !(Text) -- ^ /Required/ "text" - The translated text.
  , createTranslationResponseVerboseJsonSegments :: !(Maybe [TranscriptionSegment]) -- ^ "segments" - Segments of the translated text and their corresponding details.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateTranslationResponseVerboseJson
instance A.FromJSON CreateTranslationResponseVerboseJson where
  parseJSON = A.withObject "CreateTranslationResponseVerboseJson" $ \o ->
    CreateTranslationResponseVerboseJson
      <$> (o .:  "language")
      <*> (o .:  "duration")
      <*> (o .:  "text")
      <*> (o .:? "segments")

-- | ToJSON CreateTranslationResponseVerboseJson
instance A.ToJSON CreateTranslationResponseVerboseJson where
  toJSON CreateTranslationResponseVerboseJson {..} =
   _omitNulls
      [ "language" .= createTranslationResponseVerboseJsonLanguage
      , "duration" .= createTranslationResponseVerboseJsonDuration
      , "text" .= createTranslationResponseVerboseJsonText
      , "segments" .= createTranslationResponseVerboseJsonSegments
      ]


-- | Construct a value of type 'CreateTranslationResponseVerboseJson' (by applying it's required fields, if any)
mkCreateTranslationResponseVerboseJson
  :: Text -- ^ 'createTranslationResponseVerboseJsonLanguage': The language of the output translation (always `english`).
  -> Text -- ^ 'createTranslationResponseVerboseJsonDuration': The duration of the input audio.
  -> Text -- ^ 'createTranslationResponseVerboseJsonText': The translated text.
  -> CreateTranslationResponseVerboseJson
mkCreateTranslationResponseVerboseJson createTranslationResponseVerboseJsonLanguage createTranslationResponseVerboseJsonDuration createTranslationResponseVerboseJsonText =
  CreateTranslationResponseVerboseJson
  { createTranslationResponseVerboseJsonLanguage
  , createTranslationResponseVerboseJsonDuration
  , createTranslationResponseVerboseJsonText
  , createTranslationResponseVerboseJsonSegments = Nothing
  }

-- ** DeleteAssistantFileResponse
-- | DeleteAssistantFileResponse
-- Deletes the association between the assistant and the file, but does not delete the [File](/docs/api-reference/files) object itself.
data DeleteAssistantFileResponse = DeleteAssistantFileResponse
  { deleteAssistantFileResponseId :: !(Text) -- ^ /Required/ "id"
  , deleteAssistantFileResponseDeleted :: !(Bool) -- ^ /Required/ "deleted"
  , deleteAssistantFileResponseObject :: !(E'Object18) -- ^ /Required/ "object"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON DeleteAssistantFileResponse
instance A.FromJSON DeleteAssistantFileResponse where
  parseJSON = A.withObject "DeleteAssistantFileResponse" $ \o ->
    DeleteAssistantFileResponse
      <$> (o .:  "id")
      <*> (o .:  "deleted")
      <*> (o .:  "object")

-- | ToJSON DeleteAssistantFileResponse
instance A.ToJSON DeleteAssistantFileResponse where
  toJSON DeleteAssistantFileResponse {..} =
   _omitNulls
      [ "id" .= deleteAssistantFileResponseId
      , "deleted" .= deleteAssistantFileResponseDeleted
      , "object" .= deleteAssistantFileResponseObject
      ]


-- | Construct a value of type 'DeleteAssistantFileResponse' (by applying it's required fields, if any)
mkDeleteAssistantFileResponse
  :: Text -- ^ 'deleteAssistantFileResponseId' 
  -> Bool -- ^ 'deleteAssistantFileResponseDeleted' 
  -> E'Object18 -- ^ 'deleteAssistantFileResponseObject' 
  -> DeleteAssistantFileResponse
mkDeleteAssistantFileResponse deleteAssistantFileResponseId deleteAssistantFileResponseDeleted deleteAssistantFileResponseObject =
  DeleteAssistantFileResponse
  { deleteAssistantFileResponseId
  , deleteAssistantFileResponseDeleted
  , deleteAssistantFileResponseObject
  }

-- ** DeleteAssistantResponse
-- | DeleteAssistantResponse
data DeleteAssistantResponse = DeleteAssistantResponse
  { deleteAssistantResponseId :: !(Text) -- ^ /Required/ "id"
  , deleteAssistantResponseDeleted :: !(Bool) -- ^ /Required/ "deleted"
  , deleteAssistantResponseObject :: !(E'Object10) -- ^ /Required/ "object"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON DeleteAssistantResponse
instance A.FromJSON DeleteAssistantResponse where
  parseJSON = A.withObject "DeleteAssistantResponse" $ \o ->
    DeleteAssistantResponse
      <$> (o .:  "id")
      <*> (o .:  "deleted")
      <*> (o .:  "object")

-- | ToJSON DeleteAssistantResponse
instance A.ToJSON DeleteAssistantResponse where
  toJSON DeleteAssistantResponse {..} =
   _omitNulls
      [ "id" .= deleteAssistantResponseId
      , "deleted" .= deleteAssistantResponseDeleted
      , "object" .= deleteAssistantResponseObject
      ]


-- | Construct a value of type 'DeleteAssistantResponse' (by applying it's required fields, if any)
mkDeleteAssistantResponse
  :: Text -- ^ 'deleteAssistantResponseId' 
  -> Bool -- ^ 'deleteAssistantResponseDeleted' 
  -> E'Object10 -- ^ 'deleteAssistantResponseObject' 
  -> DeleteAssistantResponse
mkDeleteAssistantResponse deleteAssistantResponseId deleteAssistantResponseDeleted deleteAssistantResponseObject =
  DeleteAssistantResponse
  { deleteAssistantResponseId
  , deleteAssistantResponseDeleted
  , deleteAssistantResponseObject
  }

-- ** DeleteFileResponse
-- | DeleteFileResponse
data DeleteFileResponse = DeleteFileResponse
  { deleteFileResponseId :: !(Text) -- ^ /Required/ "id"
  , deleteFileResponseObject :: !(E'Object5) -- ^ /Required/ "object"
  , deleteFileResponseDeleted :: !(Bool) -- ^ /Required/ "deleted"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON DeleteFileResponse
instance A.FromJSON DeleteFileResponse where
  parseJSON = A.withObject "DeleteFileResponse" $ \o ->
    DeleteFileResponse
      <$> (o .:  "id")
      <*> (o .:  "object")
      <*> (o .:  "deleted")

-- | ToJSON DeleteFileResponse
instance A.ToJSON DeleteFileResponse where
  toJSON DeleteFileResponse {..} =
   _omitNulls
      [ "id" .= deleteFileResponseId
      , "object" .= deleteFileResponseObject
      , "deleted" .= deleteFileResponseDeleted
      ]


-- | Construct a value of type 'DeleteFileResponse' (by applying it's required fields, if any)
mkDeleteFileResponse
  :: Text -- ^ 'deleteFileResponseId' 
  -> E'Object5 -- ^ 'deleteFileResponseObject' 
  -> Bool -- ^ 'deleteFileResponseDeleted' 
  -> DeleteFileResponse
mkDeleteFileResponse deleteFileResponseId deleteFileResponseObject deleteFileResponseDeleted =
  DeleteFileResponse
  { deleteFileResponseId
  , deleteFileResponseObject
  , deleteFileResponseDeleted
  }

-- ** DeleteMessageResponse
-- | DeleteMessageResponse
data DeleteMessageResponse = DeleteMessageResponse
  { deleteMessageResponseId :: !(Text) -- ^ /Required/ "id"
  , deleteMessageResponseDeleted :: !(Bool) -- ^ /Required/ "deleted"
  , deleteMessageResponseObject :: !(E'Object15) -- ^ /Required/ "object"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON DeleteMessageResponse
instance A.FromJSON DeleteMessageResponse where
  parseJSON = A.withObject "DeleteMessageResponse" $ \o ->
    DeleteMessageResponse
      <$> (o .:  "id")
      <*> (o .:  "deleted")
      <*> (o .:  "object")

-- | ToJSON DeleteMessageResponse
instance A.ToJSON DeleteMessageResponse where
  toJSON DeleteMessageResponse {..} =
   _omitNulls
      [ "id" .= deleteMessageResponseId
      , "deleted" .= deleteMessageResponseDeleted
      , "object" .= deleteMessageResponseObject
      ]


-- | Construct a value of type 'DeleteMessageResponse' (by applying it's required fields, if any)
mkDeleteMessageResponse
  :: Text -- ^ 'deleteMessageResponseId' 
  -> Bool -- ^ 'deleteMessageResponseDeleted' 
  -> E'Object15 -- ^ 'deleteMessageResponseObject' 
  -> DeleteMessageResponse
mkDeleteMessageResponse deleteMessageResponseId deleteMessageResponseDeleted deleteMessageResponseObject =
  DeleteMessageResponse
  { deleteMessageResponseId
  , deleteMessageResponseDeleted
  , deleteMessageResponseObject
  }

-- ** DeleteModelResponse
-- | DeleteModelResponse
data DeleteModelResponse = DeleteModelResponse
  { deleteModelResponseId :: !(Text) -- ^ /Required/ "id"
  , deleteModelResponseDeleted :: !(Bool) -- ^ /Required/ "deleted"
  , deleteModelResponseObject :: !(Text) -- ^ /Required/ "object"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON DeleteModelResponse
instance A.FromJSON DeleteModelResponse where
  parseJSON = A.withObject "DeleteModelResponse" $ \o ->
    DeleteModelResponse
      <$> (o .:  "id")
      <*> (o .:  "deleted")
      <*> (o .:  "object")

-- | ToJSON DeleteModelResponse
instance A.ToJSON DeleteModelResponse where
  toJSON DeleteModelResponse {..} =
   _omitNulls
      [ "id" .= deleteModelResponseId
      , "deleted" .= deleteModelResponseDeleted
      , "object" .= deleteModelResponseObject
      ]


-- | Construct a value of type 'DeleteModelResponse' (by applying it's required fields, if any)
mkDeleteModelResponse
  :: Text -- ^ 'deleteModelResponseId' 
  -> Bool -- ^ 'deleteModelResponseDeleted' 
  -> Text -- ^ 'deleteModelResponseObject' 
  -> DeleteModelResponse
mkDeleteModelResponse deleteModelResponseId deleteModelResponseDeleted deleteModelResponseObject =
  DeleteModelResponse
  { deleteModelResponseId
  , deleteModelResponseDeleted
  , deleteModelResponseObject
  }

-- ** DeleteThreadResponse
-- | DeleteThreadResponse
data DeleteThreadResponse = DeleteThreadResponse
  { deleteThreadResponseId :: !(Text) -- ^ /Required/ "id"
  , deleteThreadResponseDeleted :: !(Bool) -- ^ /Required/ "deleted"
  , deleteThreadResponseObject :: !(E'Object13) -- ^ /Required/ "object"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON DeleteThreadResponse
instance A.FromJSON DeleteThreadResponse where
  parseJSON = A.withObject "DeleteThreadResponse" $ \o ->
    DeleteThreadResponse
      <$> (o .:  "id")
      <*> (o .:  "deleted")
      <*> (o .:  "object")

-- | ToJSON DeleteThreadResponse
instance A.ToJSON DeleteThreadResponse where
  toJSON DeleteThreadResponse {..} =
   _omitNulls
      [ "id" .= deleteThreadResponseId
      , "deleted" .= deleteThreadResponseDeleted
      , "object" .= deleteThreadResponseObject
      ]


-- | Construct a value of type 'DeleteThreadResponse' (by applying it's required fields, if any)
mkDeleteThreadResponse
  :: Text -- ^ 'deleteThreadResponseId' 
  -> Bool -- ^ 'deleteThreadResponseDeleted' 
  -> E'Object13 -- ^ 'deleteThreadResponseObject' 
  -> DeleteThreadResponse
mkDeleteThreadResponse deleteThreadResponseId deleteThreadResponseDeleted deleteThreadResponseObject =
  DeleteThreadResponse
  { deleteThreadResponseId
  , deleteThreadResponseDeleted
  , deleteThreadResponseObject
  }

-- ** Embedding
-- | Embedding
-- Represents an embedding vector returned by embedding endpoint. 
data Embedding = Embedding
  { embeddingIndex :: !(Int) -- ^ /Required/ "index" - The index of the embedding in the list of embeddings.
  , embeddingEmbedding :: !([Double]) -- ^ /Required/ "embedding" - The embedding vector, which is a list of floats. The length of vector depends on the model as listed in the [embedding guide](/docs/guides/embeddings). 
  , embeddingObject :: !(E'Object7) -- ^ /Required/ "object" - The object type, which is always \&quot;embedding\&quot;.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Embedding
instance A.FromJSON Embedding where
  parseJSON = A.withObject "Embedding" $ \o ->
    Embedding
      <$> (o .:  "index")
      <*> (o .:  "embedding")
      <*> (o .:  "object")

-- | ToJSON Embedding
instance A.ToJSON Embedding where
  toJSON Embedding {..} =
   _omitNulls
      [ "index" .= embeddingIndex
      , "embedding" .= embeddingEmbedding
      , "object" .= embeddingObject
      ]


-- | Construct a value of type 'Embedding' (by applying it's required fields, if any)
mkEmbedding
  :: Int -- ^ 'embeddingIndex': The index of the embedding in the list of embeddings.
  -> [Double] -- ^ 'embeddingEmbedding': The embedding vector, which is a list of floats. The length of vector depends on the model as listed in the [embedding guide](/docs/guides/embeddings). 
  -> E'Object7 -- ^ 'embeddingObject': The object type, which is always \"embedding\".
  -> Embedding
mkEmbedding embeddingIndex embeddingEmbedding embeddingObject =
  Embedding
  { embeddingIndex
  , embeddingEmbedding
  , embeddingObject
  }

-- ** Error
-- | Error
data Error = Error
  { errorCode :: !(Text) -- ^ /Required/ "code"
  , errorMessage :: !(Text) -- ^ /Required/ "message"
  , errorParam :: !(Text) -- ^ /Required/ "param"
  , errorType :: !(Text) -- ^ /Required/ "type"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Error
instance A.FromJSON Error where
  parseJSON = A.withObject "Error" $ \o ->
    Error
      <$> (o .:  "code")
      <*> (o .:  "message")
      <*> (o .:  "param")
      <*> (o .:  "type")

-- | ToJSON Error
instance A.ToJSON Error where
  toJSON Error {..} =
   _omitNulls
      [ "code" .= errorCode
      , "message" .= errorMessage
      , "param" .= errorParam
      , "type" .= errorType
      ]


-- | Construct a value of type 'Error' (by applying it's required fields, if any)
mkError
  :: Text -- ^ 'errorCode' 
  -> Text -- ^ 'errorMessage' 
  -> Text -- ^ 'errorParam' 
  -> Text -- ^ 'errorType' 
  -> Error
mkError errorCode errorMessage errorParam errorType =
  Error
  { errorCode
  , errorMessage
  , errorParam
  , errorType
  }

-- ** ErrorResponse
-- | ErrorResponse
data ErrorResponse = ErrorResponse
  { errorResponseError :: !(Error) -- ^ /Required/ "error"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ErrorResponse
instance A.FromJSON ErrorResponse where
  parseJSON = A.withObject "ErrorResponse" $ \o ->
    ErrorResponse
      <$> (o .:  "error")

-- | ToJSON ErrorResponse
instance A.ToJSON ErrorResponse where
  toJSON ErrorResponse {..} =
   _omitNulls
      [ "error" .= errorResponseError
      ]


-- | Construct a value of type 'ErrorResponse' (by applying it's required fields, if any)
mkErrorResponse
  :: Error -- ^ 'errorResponseError' 
  -> ErrorResponse
mkErrorResponse errorResponseError =
  ErrorResponse
  { errorResponseError
  }

-- ** FineTuningJob
-- | FineTuningJob
-- FineTuningJob
-- 
-- The `fine_tuning.job` object represents a fine-tuning job that has been created through the API. 
data FineTuningJob = FineTuningJob
  { fineTuningJobId :: !(Text) -- ^ /Required/ "id" - The object identifier, which can be referenced in the API endpoints.
  , fineTuningJobCreatedAt :: !(Int) -- ^ /Required/ "created_at" - The Unix timestamp (in seconds) for when the fine-tuning job was created.
  , fineTuningJobError :: !(FineTuningJobError) -- ^ /Required/ "error"
  , fineTuningJobFineTunedModel :: !(Text) -- ^ /Required/ "fine_tuned_model" - The name of the fine-tuned model that is being created. The value will be null if the fine-tuning job is still running.
  , fineTuningJobFinishedAt :: !(Int) -- ^ /Required/ "finished_at" - The Unix timestamp (in seconds) for when the fine-tuning job was finished. The value will be null if the fine-tuning job is still running.
  , fineTuningJobHyperparameters :: !(FineTuningJobHyperparameters) -- ^ /Required/ "hyperparameters"
  , fineTuningJobModel :: !(Text) -- ^ /Required/ "model" - The base model that is being fine-tuned.
  , fineTuningJobObject :: !(E'Object8) -- ^ /Required/ "object" - The object type, which is always \&quot;fine_tuning.job\&quot;.
  , fineTuningJobOrganizationId :: !(Text) -- ^ /Required/ "organization_id" - The organization that owns the fine-tuning job.
  , fineTuningJobResultFiles :: !([Text]) -- ^ /Required/ "result_files" - The compiled results file ID(s) for the fine-tuning job. You can retrieve the results with the [Files API](/docs/api-reference/files/retrieve-contents).
  , fineTuningJobStatus :: !(E'Status2) -- ^ /Required/ "status" - The current status of the fine-tuning job, which can be either &#x60;validating_files&#x60;, &#x60;queued&#x60;, &#x60;running&#x60;, &#x60;succeeded&#x60;, &#x60;failed&#x60;, or &#x60;cancelled&#x60;.
  , fineTuningJobTrainedTokens :: !(Int) -- ^ /Required/ "trained_tokens" - The total number of billable tokens processed by this fine-tuning job. The value will be null if the fine-tuning job is still running.
  , fineTuningJobTrainingFile :: !(Text) -- ^ /Required/ "training_file" - The file ID used for training. You can retrieve the training data with the [Files API](/docs/api-reference/files/retrieve-contents).
  , fineTuningJobValidationFile :: !(Text) -- ^ /Required/ "validation_file" - The file ID used for validation. You can retrieve the validation results with the [Files API](/docs/api-reference/files/retrieve-contents).
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON FineTuningJob
instance A.FromJSON FineTuningJob where
  parseJSON = A.withObject "FineTuningJob" $ \o ->
    FineTuningJob
      <$> (o .:  "id")
      <*> (o .:  "created_at")
      <*> (o .:  "error")
      <*> (o .:  "fine_tuned_model")
      <*> (o .:  "finished_at")
      <*> (o .:  "hyperparameters")
      <*> (o .:  "model")
      <*> (o .:  "object")
      <*> (o .:  "organization_id")
      <*> (o .:  "result_files")
      <*> (o .:  "status")
      <*> (o .:  "trained_tokens")
      <*> (o .:  "training_file")
      <*> (o .:  "validation_file")

-- | ToJSON FineTuningJob
instance A.ToJSON FineTuningJob where
  toJSON FineTuningJob {..} =
   _omitNulls
      [ "id" .= fineTuningJobId
      , "created_at" .= fineTuningJobCreatedAt
      , "error" .= fineTuningJobError
      , "fine_tuned_model" .= fineTuningJobFineTunedModel
      , "finished_at" .= fineTuningJobFinishedAt
      , "hyperparameters" .= fineTuningJobHyperparameters
      , "model" .= fineTuningJobModel
      , "object" .= fineTuningJobObject
      , "organization_id" .= fineTuningJobOrganizationId
      , "result_files" .= fineTuningJobResultFiles
      , "status" .= fineTuningJobStatus
      , "trained_tokens" .= fineTuningJobTrainedTokens
      , "training_file" .= fineTuningJobTrainingFile
      , "validation_file" .= fineTuningJobValidationFile
      ]


-- | Construct a value of type 'FineTuningJob' (by applying it's required fields, if any)
mkFineTuningJob
  :: Text -- ^ 'fineTuningJobId': The object identifier, which can be referenced in the API endpoints.
  -> Int -- ^ 'fineTuningJobCreatedAt': The Unix timestamp (in seconds) for when the fine-tuning job was created.
  -> FineTuningJobError -- ^ 'fineTuningJobError' 
  -> Text -- ^ 'fineTuningJobFineTunedModel': The name of the fine-tuned model that is being created. The value will be null if the fine-tuning job is still running.
  -> Int -- ^ 'fineTuningJobFinishedAt': The Unix timestamp (in seconds) for when the fine-tuning job was finished. The value will be null if the fine-tuning job is still running.
  -> FineTuningJobHyperparameters -- ^ 'fineTuningJobHyperparameters' 
  -> Text -- ^ 'fineTuningJobModel': The base model that is being fine-tuned.
  -> E'Object8 -- ^ 'fineTuningJobObject': The object type, which is always \"fine_tuning.job\".
  -> Text -- ^ 'fineTuningJobOrganizationId': The organization that owns the fine-tuning job.
  -> [Text] -- ^ 'fineTuningJobResultFiles': The compiled results file ID(s) for the fine-tuning job. You can retrieve the results with the [Files API](/docs/api-reference/files/retrieve-contents).
  -> E'Status2 -- ^ 'fineTuningJobStatus': The current status of the fine-tuning job, which can be either `validating_files`, `queued`, `running`, `succeeded`, `failed`, or `cancelled`.
  -> Int -- ^ 'fineTuningJobTrainedTokens': The total number of billable tokens processed by this fine-tuning job. The value will be null if the fine-tuning job is still running.
  -> Text -- ^ 'fineTuningJobTrainingFile': The file ID used for training. You can retrieve the training data with the [Files API](/docs/api-reference/files/retrieve-contents).
  -> Text -- ^ 'fineTuningJobValidationFile': The file ID used for validation. You can retrieve the validation results with the [Files API](/docs/api-reference/files/retrieve-contents).
  -> FineTuningJob
mkFineTuningJob fineTuningJobId fineTuningJobCreatedAt fineTuningJobError fineTuningJobFineTunedModel fineTuningJobFinishedAt fineTuningJobHyperparameters fineTuningJobModel fineTuningJobObject fineTuningJobOrganizationId fineTuningJobResultFiles fineTuningJobStatus fineTuningJobTrainedTokens fineTuningJobTrainingFile fineTuningJobValidationFile =
  FineTuningJob
  { fineTuningJobId
  , fineTuningJobCreatedAt
  , fineTuningJobError
  , fineTuningJobFineTunedModel
  , fineTuningJobFinishedAt
  , fineTuningJobHyperparameters
  , fineTuningJobModel
  , fineTuningJobObject
  , fineTuningJobOrganizationId
  , fineTuningJobResultFiles
  , fineTuningJobStatus
  , fineTuningJobTrainedTokens
  , fineTuningJobTrainingFile
  , fineTuningJobValidationFile
  }

-- ** FineTuningJobError
-- | FineTuningJobError
-- For fine-tuning jobs that have `failed`, this will contain more information on the cause of the failure.
data FineTuningJobError = FineTuningJobError
  { fineTuningJobErrorCode :: !(Text) -- ^ /Required/ "code" - A machine-readable error code.
  , fineTuningJobErrorMessage :: !(Text) -- ^ /Required/ "message" - A human-readable error message.
  , fineTuningJobErrorParam :: !(Text) -- ^ /Required/ "param" - The parameter that was invalid, usually &#x60;training_file&#x60; or &#x60;validation_file&#x60;. This field will be null if the failure was not parameter-specific.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON FineTuningJobError
instance A.FromJSON FineTuningJobError where
  parseJSON = A.withObject "FineTuningJobError" $ \o ->
    FineTuningJobError
      <$> (o .:  "code")
      <*> (o .:  "message")
      <*> (o .:  "param")

-- | ToJSON FineTuningJobError
instance A.ToJSON FineTuningJobError where
  toJSON FineTuningJobError {..} =
   _omitNulls
      [ "code" .= fineTuningJobErrorCode
      , "message" .= fineTuningJobErrorMessage
      , "param" .= fineTuningJobErrorParam
      ]


-- | Construct a value of type 'FineTuningJobError' (by applying it's required fields, if any)
mkFineTuningJobError
  :: Text -- ^ 'fineTuningJobErrorCode': A machine-readable error code.
  -> Text -- ^ 'fineTuningJobErrorMessage': A human-readable error message.
  -> Text -- ^ 'fineTuningJobErrorParam': The parameter that was invalid, usually `training_file` or `validation_file`. This field will be null if the failure was not parameter-specific.
  -> FineTuningJobError
mkFineTuningJobError fineTuningJobErrorCode fineTuningJobErrorMessage fineTuningJobErrorParam =
  FineTuningJobError
  { fineTuningJobErrorCode
  , fineTuningJobErrorMessage
  , fineTuningJobErrorParam
  }

-- ** FineTuningJobEvent
-- | FineTuningJobEvent
-- Fine-tuning job event object
data FineTuningJobEvent = FineTuningJobEvent
  { fineTuningJobEventId :: !(Text) -- ^ /Required/ "id"
  , fineTuningJobEventCreatedAt :: !(Int) -- ^ /Required/ "created_at"
  , fineTuningJobEventLevel :: !(E'Level) -- ^ /Required/ "level"
  , fineTuningJobEventMessage :: !(Text) -- ^ /Required/ "message"
  , fineTuningJobEventObject :: !(E'Object9) -- ^ /Required/ "object"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON FineTuningJobEvent
instance A.FromJSON FineTuningJobEvent where
  parseJSON = A.withObject "FineTuningJobEvent" $ \o ->
    FineTuningJobEvent
      <$> (o .:  "id")
      <*> (o .:  "created_at")
      <*> (o .:  "level")
      <*> (o .:  "message")
      <*> (o .:  "object")

-- | ToJSON FineTuningJobEvent
instance A.ToJSON FineTuningJobEvent where
  toJSON FineTuningJobEvent {..} =
   _omitNulls
      [ "id" .= fineTuningJobEventId
      , "created_at" .= fineTuningJobEventCreatedAt
      , "level" .= fineTuningJobEventLevel
      , "message" .= fineTuningJobEventMessage
      , "object" .= fineTuningJobEventObject
      ]


-- | Construct a value of type 'FineTuningJobEvent' (by applying it's required fields, if any)
mkFineTuningJobEvent
  :: Text -- ^ 'fineTuningJobEventId' 
  -> Int -- ^ 'fineTuningJobEventCreatedAt' 
  -> E'Level -- ^ 'fineTuningJobEventLevel' 
  -> Text -- ^ 'fineTuningJobEventMessage' 
  -> E'Object9 -- ^ 'fineTuningJobEventObject' 
  -> FineTuningJobEvent
mkFineTuningJobEvent fineTuningJobEventId fineTuningJobEventCreatedAt fineTuningJobEventLevel fineTuningJobEventMessage fineTuningJobEventObject =
  FineTuningJobEvent
  { fineTuningJobEventId
  , fineTuningJobEventCreatedAt
  , fineTuningJobEventLevel
  , fineTuningJobEventMessage
  , fineTuningJobEventObject
  }

-- ** FineTuningJobHyperparameters
-- | FineTuningJobHyperparameters
-- The hyperparameters used for the fine-tuning job. See the [fine-tuning guide](/docs/guides/fine-tuning) for more details.
data FineTuningJobHyperparameters = FineTuningJobHyperparameters
  { fineTuningJobHyperparametersNEpochs :: !(FineTuningJobHyperparametersNEpochs) -- ^ /Required/ "n_epochs"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON FineTuningJobHyperparameters
instance A.FromJSON FineTuningJobHyperparameters where
  parseJSON = A.withObject "FineTuningJobHyperparameters" $ \o ->
    FineTuningJobHyperparameters
      <$> (o .:  "n_epochs")

-- | ToJSON FineTuningJobHyperparameters
instance A.ToJSON FineTuningJobHyperparameters where
  toJSON FineTuningJobHyperparameters {..} =
   _omitNulls
      [ "n_epochs" .= fineTuningJobHyperparametersNEpochs
      ]


-- | Construct a value of type 'FineTuningJobHyperparameters' (by applying it's required fields, if any)
mkFineTuningJobHyperparameters
  :: FineTuningJobHyperparametersNEpochs -- ^ 'fineTuningJobHyperparametersNEpochs' 
  -> FineTuningJobHyperparameters
mkFineTuningJobHyperparameters fineTuningJobHyperparametersNEpochs =
  FineTuningJobHyperparameters
  { fineTuningJobHyperparametersNEpochs
  }

-- ** FineTuningJobHyperparametersNEpochs
-- | FineTuningJobHyperparametersNEpochs
-- The number of epochs to train the model for. An epoch refers to one full cycle through the training dataset. \"auto\" decides the optimal number of epochs based on the size of the dataset. If setting the number manually, we support any number between 1 and 50 epochs.
data FineTuningJobHyperparametersNEpochs = FineTuningJobHyperparametersNEpochs
  { 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON FineTuningJobHyperparametersNEpochs
instance A.FromJSON FineTuningJobHyperparametersNEpochs where
  parseJSON = A.withObject "FineTuningJobHyperparametersNEpochs" $ \o ->
    pure FineTuningJobHyperparametersNEpochs
      

-- | ToJSON FineTuningJobHyperparametersNEpochs
instance A.ToJSON FineTuningJobHyperparametersNEpochs where
  toJSON FineTuningJobHyperparametersNEpochs  =
   _omitNulls
      [ 
      ]


-- | Construct a value of type 'FineTuningJobHyperparametersNEpochs' (by applying it's required fields, if any)
mkFineTuningJobHyperparametersNEpochs
  :: FineTuningJobHyperparametersNEpochs
mkFineTuningJobHyperparametersNEpochs =
  FineTuningJobHyperparametersNEpochs
  { 
  }

-- ** FunctionObject
-- | FunctionObject
data FunctionObject = FunctionObject
  { functionObjectDescription :: !(Maybe Text) -- ^ "description" - A description of what the function does, used by the model to choose when and how to call the function.
  , functionObjectName :: !(Text) -- ^ /Required/ "name" - The name of the function to be called. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
  , functionObjectParameters :: !(Maybe (Map.Map String A.Value)) -- ^ "parameters" - The parameters the functions accepts, described as a JSON Schema object. See the [guide](/docs/guides/text-generation/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format.   Omitting &#x60;parameters&#x60; defines a function with an empty parameter list.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON FunctionObject
instance A.FromJSON FunctionObject where
  parseJSON = A.withObject "FunctionObject" $ \o ->
    FunctionObject
      <$> (o .:? "description")
      <*> (o .:  "name")
      <*> (o .:? "parameters")

-- | ToJSON FunctionObject
instance A.ToJSON FunctionObject where
  toJSON FunctionObject {..} =
   _omitNulls
      [ "description" .= functionObjectDescription
      , "name" .= functionObjectName
      , "parameters" .= functionObjectParameters
      ]


-- | Construct a value of type 'FunctionObject' (by applying it's required fields, if any)
mkFunctionObject
  :: Text -- ^ 'functionObjectName': The name of the function to be called. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
  -> FunctionObject
mkFunctionObject functionObjectName =
  FunctionObject
  { functionObjectDescription = Nothing
  , functionObjectName
  , functionObjectParameters = Nothing
  }

-- ** Image
-- | Image
-- Represents the url or the content of an image generated by the OpenAI API.
data Image = Image
  { imageB64Json :: !(Maybe Text) -- ^ "b64_json" - The base64-encoded JSON of the generated image, if &#x60;response_format&#x60; is &#x60;b64_json&#x60;.
  , imageUrl :: !(Maybe Text) -- ^ "url" - The URL of the generated image, if &#x60;response_format&#x60; is &#x60;url&#x60; (default).
  , imageRevisedPrompt :: !(Maybe Text) -- ^ "revised_prompt" - The prompt that was used to generate the image, if there was any revision to the prompt.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Image
instance A.FromJSON Image where
  parseJSON = A.withObject "Image" $ \o ->
    Image
      <$> (o .:? "b64_json")
      <*> (o .:? "url")
      <*> (o .:? "revised_prompt")

-- | ToJSON Image
instance A.ToJSON Image where
  toJSON Image {..} =
   _omitNulls
      [ "b64_json" .= imageB64Json
      , "url" .= imageUrl
      , "revised_prompt" .= imageRevisedPrompt
      ]


-- | Construct a value of type 'Image' (by applying it's required fields, if any)
mkImage
  :: Image
mkImage =
  Image
  { imageB64Json = Nothing
  , imageUrl = Nothing
  , imageRevisedPrompt = Nothing
  }

-- ** ImagesResponse
-- | ImagesResponse
data ImagesResponse = ImagesResponse
  { imagesResponseCreated :: !(Int) -- ^ /Required/ "created"
  , imagesResponseData :: !([Image]) -- ^ /Required/ "data"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ImagesResponse
instance A.FromJSON ImagesResponse where
  parseJSON = A.withObject "ImagesResponse" $ \o ->
    ImagesResponse
      <$> (o .:  "created")
      <*> (o .:  "data")

-- | ToJSON ImagesResponse
instance A.ToJSON ImagesResponse where
  toJSON ImagesResponse {..} =
   _omitNulls
      [ "created" .= imagesResponseCreated
      , "data" .= imagesResponseData
      ]


-- | Construct a value of type 'ImagesResponse' (by applying it's required fields, if any)
mkImagesResponse
  :: Int -- ^ 'imagesResponseCreated' 
  -> [Image] -- ^ 'imagesResponseData' 
  -> ImagesResponse
mkImagesResponse imagesResponseCreated imagesResponseData =
  ImagesResponse
  { imagesResponseCreated
  , imagesResponseData
  }

-- ** ListAssistantFilesResponse
-- | ListAssistantFilesResponse
data ListAssistantFilesResponse = ListAssistantFilesResponse
  { listAssistantFilesResponseObject :: !(Text) -- ^ /Required/ "object"
  , listAssistantFilesResponseData :: !([AssistantFileObject]) -- ^ /Required/ "data"
  , listAssistantFilesResponseFirstId :: !(Text) -- ^ /Required/ "first_id"
  , listAssistantFilesResponseLastId :: !(Text) -- ^ /Required/ "last_id"
  , listAssistantFilesResponseHasMore :: !(Bool) -- ^ /Required/ "has_more"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ListAssistantFilesResponse
instance A.FromJSON ListAssistantFilesResponse where
  parseJSON = A.withObject "ListAssistantFilesResponse" $ \o ->
    ListAssistantFilesResponse
      <$> (o .:  "object")
      <*> (o .:  "data")
      <*> (o .:  "first_id")
      <*> (o .:  "last_id")
      <*> (o .:  "has_more")

-- | ToJSON ListAssistantFilesResponse
instance A.ToJSON ListAssistantFilesResponse where
  toJSON ListAssistantFilesResponse {..} =
   _omitNulls
      [ "object" .= listAssistantFilesResponseObject
      , "data" .= listAssistantFilesResponseData
      , "first_id" .= listAssistantFilesResponseFirstId
      , "last_id" .= listAssistantFilesResponseLastId
      , "has_more" .= listAssistantFilesResponseHasMore
      ]


-- | Construct a value of type 'ListAssistantFilesResponse' (by applying it's required fields, if any)
mkListAssistantFilesResponse
  :: Text -- ^ 'listAssistantFilesResponseObject' 
  -> [AssistantFileObject] -- ^ 'listAssistantFilesResponseData' 
  -> Text -- ^ 'listAssistantFilesResponseFirstId' 
  -> Text -- ^ 'listAssistantFilesResponseLastId' 
  -> Bool -- ^ 'listAssistantFilesResponseHasMore' 
  -> ListAssistantFilesResponse
mkListAssistantFilesResponse listAssistantFilesResponseObject listAssistantFilesResponseData listAssistantFilesResponseFirstId listAssistantFilesResponseLastId listAssistantFilesResponseHasMore =
  ListAssistantFilesResponse
  { listAssistantFilesResponseObject
  , listAssistantFilesResponseData
  , listAssistantFilesResponseFirstId
  , listAssistantFilesResponseLastId
  , listAssistantFilesResponseHasMore
  }

-- ** ListAssistantsResponse
-- | ListAssistantsResponse
data ListAssistantsResponse = ListAssistantsResponse
  { listAssistantsResponseObject :: !(Text) -- ^ /Required/ "object"
  , listAssistantsResponseData :: !([AssistantObject]) -- ^ /Required/ "data"
  , listAssistantsResponseFirstId :: !(Text) -- ^ /Required/ "first_id"
  , listAssistantsResponseLastId :: !(Text) -- ^ /Required/ "last_id"
  , listAssistantsResponseHasMore :: !(Bool) -- ^ /Required/ "has_more"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ListAssistantsResponse
instance A.FromJSON ListAssistantsResponse where
  parseJSON = A.withObject "ListAssistantsResponse" $ \o ->
    ListAssistantsResponse
      <$> (o .:  "object")
      <*> (o .:  "data")
      <*> (o .:  "first_id")
      <*> (o .:  "last_id")
      <*> (o .:  "has_more")

-- | ToJSON ListAssistantsResponse
instance A.ToJSON ListAssistantsResponse where
  toJSON ListAssistantsResponse {..} =
   _omitNulls
      [ "object" .= listAssistantsResponseObject
      , "data" .= listAssistantsResponseData
      , "first_id" .= listAssistantsResponseFirstId
      , "last_id" .= listAssistantsResponseLastId
      , "has_more" .= listAssistantsResponseHasMore
      ]


-- | Construct a value of type 'ListAssistantsResponse' (by applying it's required fields, if any)
mkListAssistantsResponse
  :: Text -- ^ 'listAssistantsResponseObject' 
  -> [AssistantObject] -- ^ 'listAssistantsResponseData' 
  -> Text -- ^ 'listAssistantsResponseFirstId' 
  -> Text -- ^ 'listAssistantsResponseLastId' 
  -> Bool -- ^ 'listAssistantsResponseHasMore' 
  -> ListAssistantsResponse
mkListAssistantsResponse listAssistantsResponseObject listAssistantsResponseData listAssistantsResponseFirstId listAssistantsResponseLastId listAssistantsResponseHasMore =
  ListAssistantsResponse
  { listAssistantsResponseObject
  , listAssistantsResponseData
  , listAssistantsResponseFirstId
  , listAssistantsResponseLastId
  , listAssistantsResponseHasMore
  }

-- ** ListFilesResponse
-- | ListFilesResponse
data ListFilesResponse = ListFilesResponse
  { listFilesResponseData :: !([OpenAIFile]) -- ^ /Required/ "data"
  , listFilesResponseObject :: !(E'Object) -- ^ /Required/ "object"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ListFilesResponse
instance A.FromJSON ListFilesResponse where
  parseJSON = A.withObject "ListFilesResponse" $ \o ->
    ListFilesResponse
      <$> (o .:  "data")
      <*> (o .:  "object")

-- | ToJSON ListFilesResponse
instance A.ToJSON ListFilesResponse where
  toJSON ListFilesResponse {..} =
   _omitNulls
      [ "data" .= listFilesResponseData
      , "object" .= listFilesResponseObject
      ]


-- | Construct a value of type 'ListFilesResponse' (by applying it's required fields, if any)
mkListFilesResponse
  :: [OpenAIFile] -- ^ 'listFilesResponseData' 
  -> E'Object -- ^ 'listFilesResponseObject' 
  -> ListFilesResponse
mkListFilesResponse listFilesResponseData listFilesResponseObject =
  ListFilesResponse
  { listFilesResponseData
  , listFilesResponseObject
  }

-- ** ListFineTuningJobEventsResponse
-- | ListFineTuningJobEventsResponse
data ListFineTuningJobEventsResponse = ListFineTuningJobEventsResponse
  { listFineTuningJobEventsResponseData :: !([FineTuningJobEvent]) -- ^ /Required/ "data"
  , listFineTuningJobEventsResponseObject :: !(E'Object) -- ^ /Required/ "object"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ListFineTuningJobEventsResponse
instance A.FromJSON ListFineTuningJobEventsResponse where
  parseJSON = A.withObject "ListFineTuningJobEventsResponse" $ \o ->
    ListFineTuningJobEventsResponse
      <$> (o .:  "data")
      <*> (o .:  "object")

-- | ToJSON ListFineTuningJobEventsResponse
instance A.ToJSON ListFineTuningJobEventsResponse where
  toJSON ListFineTuningJobEventsResponse {..} =
   _omitNulls
      [ "data" .= listFineTuningJobEventsResponseData
      , "object" .= listFineTuningJobEventsResponseObject
      ]


-- | Construct a value of type 'ListFineTuningJobEventsResponse' (by applying it's required fields, if any)
mkListFineTuningJobEventsResponse
  :: [FineTuningJobEvent] -- ^ 'listFineTuningJobEventsResponseData' 
  -> E'Object -- ^ 'listFineTuningJobEventsResponseObject' 
  -> ListFineTuningJobEventsResponse
mkListFineTuningJobEventsResponse listFineTuningJobEventsResponseData listFineTuningJobEventsResponseObject =
  ListFineTuningJobEventsResponse
  { listFineTuningJobEventsResponseData
  , listFineTuningJobEventsResponseObject
  }

-- ** ListMessageFilesResponse
-- | ListMessageFilesResponse
data ListMessageFilesResponse = ListMessageFilesResponse
  { listMessageFilesResponseObject :: !(Text) -- ^ /Required/ "object"
  , listMessageFilesResponseData :: !([MessageFileObject]) -- ^ /Required/ "data"
  , listMessageFilesResponseFirstId :: !(Text) -- ^ /Required/ "first_id"
  , listMessageFilesResponseLastId :: !(Text) -- ^ /Required/ "last_id"
  , listMessageFilesResponseHasMore :: !(Bool) -- ^ /Required/ "has_more"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ListMessageFilesResponse
instance A.FromJSON ListMessageFilesResponse where
  parseJSON = A.withObject "ListMessageFilesResponse" $ \o ->
    ListMessageFilesResponse
      <$> (o .:  "object")
      <*> (o .:  "data")
      <*> (o .:  "first_id")
      <*> (o .:  "last_id")
      <*> (o .:  "has_more")

-- | ToJSON ListMessageFilesResponse
instance A.ToJSON ListMessageFilesResponse where
  toJSON ListMessageFilesResponse {..} =
   _omitNulls
      [ "object" .= listMessageFilesResponseObject
      , "data" .= listMessageFilesResponseData
      , "first_id" .= listMessageFilesResponseFirstId
      , "last_id" .= listMessageFilesResponseLastId
      , "has_more" .= listMessageFilesResponseHasMore
      ]


-- | Construct a value of type 'ListMessageFilesResponse' (by applying it's required fields, if any)
mkListMessageFilesResponse
  :: Text -- ^ 'listMessageFilesResponseObject' 
  -> [MessageFileObject] -- ^ 'listMessageFilesResponseData' 
  -> Text -- ^ 'listMessageFilesResponseFirstId' 
  -> Text -- ^ 'listMessageFilesResponseLastId' 
  -> Bool -- ^ 'listMessageFilesResponseHasMore' 
  -> ListMessageFilesResponse
mkListMessageFilesResponse listMessageFilesResponseObject listMessageFilesResponseData listMessageFilesResponseFirstId listMessageFilesResponseLastId listMessageFilesResponseHasMore =
  ListMessageFilesResponse
  { listMessageFilesResponseObject
  , listMessageFilesResponseData
  , listMessageFilesResponseFirstId
  , listMessageFilesResponseLastId
  , listMessageFilesResponseHasMore
  }

-- ** ListMessagesResponse
-- | ListMessagesResponse
data ListMessagesResponse = ListMessagesResponse
  { listMessagesResponseObject :: !(Text) -- ^ /Required/ "object"
  , listMessagesResponseData :: !([MessageObject]) -- ^ /Required/ "data"
  , listMessagesResponseFirstId :: !(Text) -- ^ /Required/ "first_id"
  , listMessagesResponseLastId :: !(Text) -- ^ /Required/ "last_id"
  , listMessagesResponseHasMore :: !(Bool) -- ^ /Required/ "has_more"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ListMessagesResponse
instance A.FromJSON ListMessagesResponse where
  parseJSON = A.withObject "ListMessagesResponse" $ \o ->
    ListMessagesResponse
      <$> (o .:  "object")
      <*> (o .:  "data")
      <*> (o .:  "first_id")
      <*> (o .:  "last_id")
      <*> (o .:  "has_more")

-- | ToJSON ListMessagesResponse
instance A.ToJSON ListMessagesResponse where
  toJSON ListMessagesResponse {..} =
   _omitNulls
      [ "object" .= listMessagesResponseObject
      , "data" .= listMessagesResponseData
      , "first_id" .= listMessagesResponseFirstId
      , "last_id" .= listMessagesResponseLastId
      , "has_more" .= listMessagesResponseHasMore
      ]


-- | Construct a value of type 'ListMessagesResponse' (by applying it's required fields, if any)
mkListMessagesResponse
  :: Text -- ^ 'listMessagesResponseObject' 
  -> [MessageObject] -- ^ 'listMessagesResponseData' 
  -> Text -- ^ 'listMessagesResponseFirstId' 
  -> Text -- ^ 'listMessagesResponseLastId' 
  -> Bool -- ^ 'listMessagesResponseHasMore' 
  -> ListMessagesResponse
mkListMessagesResponse listMessagesResponseObject listMessagesResponseData listMessagesResponseFirstId listMessagesResponseLastId listMessagesResponseHasMore =
  ListMessagesResponse
  { listMessagesResponseObject
  , listMessagesResponseData
  , listMessagesResponseFirstId
  , listMessagesResponseLastId
  , listMessagesResponseHasMore
  }

-- ** ListModelsResponse
-- | ListModelsResponse
data ListModelsResponse = ListModelsResponse
  { listModelsResponseObject :: !(E'Object) -- ^ /Required/ "object"
  , listModelsResponseData :: !([Model]) -- ^ /Required/ "data"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ListModelsResponse
instance A.FromJSON ListModelsResponse where
  parseJSON = A.withObject "ListModelsResponse" $ \o ->
    ListModelsResponse
      <$> (o .:  "object")
      <*> (o .:  "data")

-- | ToJSON ListModelsResponse
instance A.ToJSON ListModelsResponse where
  toJSON ListModelsResponse {..} =
   _omitNulls
      [ "object" .= listModelsResponseObject
      , "data" .= listModelsResponseData
      ]


-- | Construct a value of type 'ListModelsResponse' (by applying it's required fields, if any)
mkListModelsResponse
  :: E'Object -- ^ 'listModelsResponseObject' 
  -> [Model] -- ^ 'listModelsResponseData' 
  -> ListModelsResponse
mkListModelsResponse listModelsResponseObject listModelsResponseData =
  ListModelsResponse
  { listModelsResponseObject
  , listModelsResponseData
  }

-- ** ListPaginatedFineTuningJobsResponse
-- | ListPaginatedFineTuningJobsResponse
data ListPaginatedFineTuningJobsResponse = ListPaginatedFineTuningJobsResponse
  { listPaginatedFineTuningJobsResponseData :: !([FineTuningJob]) -- ^ /Required/ "data"
  , listPaginatedFineTuningJobsResponseHasMore :: !(Bool) -- ^ /Required/ "has_more"
  , listPaginatedFineTuningJobsResponseObject :: !(E'Object) -- ^ /Required/ "object"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ListPaginatedFineTuningJobsResponse
instance A.FromJSON ListPaginatedFineTuningJobsResponse where
  parseJSON = A.withObject "ListPaginatedFineTuningJobsResponse" $ \o ->
    ListPaginatedFineTuningJobsResponse
      <$> (o .:  "data")
      <*> (o .:  "has_more")
      <*> (o .:  "object")

-- | ToJSON ListPaginatedFineTuningJobsResponse
instance A.ToJSON ListPaginatedFineTuningJobsResponse where
  toJSON ListPaginatedFineTuningJobsResponse {..} =
   _omitNulls
      [ "data" .= listPaginatedFineTuningJobsResponseData
      , "has_more" .= listPaginatedFineTuningJobsResponseHasMore
      , "object" .= listPaginatedFineTuningJobsResponseObject
      ]


-- | Construct a value of type 'ListPaginatedFineTuningJobsResponse' (by applying it's required fields, if any)
mkListPaginatedFineTuningJobsResponse
  :: [FineTuningJob] -- ^ 'listPaginatedFineTuningJobsResponseData' 
  -> Bool -- ^ 'listPaginatedFineTuningJobsResponseHasMore' 
  -> E'Object -- ^ 'listPaginatedFineTuningJobsResponseObject' 
  -> ListPaginatedFineTuningJobsResponse
mkListPaginatedFineTuningJobsResponse listPaginatedFineTuningJobsResponseData listPaginatedFineTuningJobsResponseHasMore listPaginatedFineTuningJobsResponseObject =
  ListPaginatedFineTuningJobsResponse
  { listPaginatedFineTuningJobsResponseData
  , listPaginatedFineTuningJobsResponseHasMore
  , listPaginatedFineTuningJobsResponseObject
  }

-- ** ListRunStepsResponse
-- | ListRunStepsResponse
data ListRunStepsResponse = ListRunStepsResponse
  { listRunStepsResponseObject :: !(Text) -- ^ /Required/ "object"
  , listRunStepsResponseData :: !([RunStepObject]) -- ^ /Required/ "data"
  , listRunStepsResponseFirstId :: !(Text) -- ^ /Required/ "first_id"
  , listRunStepsResponseLastId :: !(Text) -- ^ /Required/ "last_id"
  , listRunStepsResponseHasMore :: !(Bool) -- ^ /Required/ "has_more"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ListRunStepsResponse
instance A.FromJSON ListRunStepsResponse where
  parseJSON = A.withObject "ListRunStepsResponse" $ \o ->
    ListRunStepsResponse
      <$> (o .:  "object")
      <*> (o .:  "data")
      <*> (o .:  "first_id")
      <*> (o .:  "last_id")
      <*> (o .:  "has_more")

-- | ToJSON ListRunStepsResponse
instance A.ToJSON ListRunStepsResponse where
  toJSON ListRunStepsResponse {..} =
   _omitNulls
      [ "object" .= listRunStepsResponseObject
      , "data" .= listRunStepsResponseData
      , "first_id" .= listRunStepsResponseFirstId
      , "last_id" .= listRunStepsResponseLastId
      , "has_more" .= listRunStepsResponseHasMore
      ]


-- | Construct a value of type 'ListRunStepsResponse' (by applying it's required fields, if any)
mkListRunStepsResponse
  :: Text -- ^ 'listRunStepsResponseObject' 
  -> [RunStepObject] -- ^ 'listRunStepsResponseData' 
  -> Text -- ^ 'listRunStepsResponseFirstId' 
  -> Text -- ^ 'listRunStepsResponseLastId' 
  -> Bool -- ^ 'listRunStepsResponseHasMore' 
  -> ListRunStepsResponse
mkListRunStepsResponse listRunStepsResponseObject listRunStepsResponseData listRunStepsResponseFirstId listRunStepsResponseLastId listRunStepsResponseHasMore =
  ListRunStepsResponse
  { listRunStepsResponseObject
  , listRunStepsResponseData
  , listRunStepsResponseFirstId
  , listRunStepsResponseLastId
  , listRunStepsResponseHasMore
  }

-- ** ListRunsResponse
-- | ListRunsResponse
data ListRunsResponse = ListRunsResponse
  { listRunsResponseObject :: !(Text) -- ^ /Required/ "object"
  , listRunsResponseData :: !([RunObject]) -- ^ /Required/ "data"
  , listRunsResponseFirstId :: !(Text) -- ^ /Required/ "first_id"
  , listRunsResponseLastId :: !(Text) -- ^ /Required/ "last_id"
  , listRunsResponseHasMore :: !(Bool) -- ^ /Required/ "has_more"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ListRunsResponse
instance A.FromJSON ListRunsResponse where
  parseJSON = A.withObject "ListRunsResponse" $ \o ->
    ListRunsResponse
      <$> (o .:  "object")
      <*> (o .:  "data")
      <*> (o .:  "first_id")
      <*> (o .:  "last_id")
      <*> (o .:  "has_more")

-- | ToJSON ListRunsResponse
instance A.ToJSON ListRunsResponse where
  toJSON ListRunsResponse {..} =
   _omitNulls
      [ "object" .= listRunsResponseObject
      , "data" .= listRunsResponseData
      , "first_id" .= listRunsResponseFirstId
      , "last_id" .= listRunsResponseLastId
      , "has_more" .= listRunsResponseHasMore
      ]


-- | Construct a value of type 'ListRunsResponse' (by applying it's required fields, if any)
mkListRunsResponse
  :: Text -- ^ 'listRunsResponseObject' 
  -> [RunObject] -- ^ 'listRunsResponseData' 
  -> Text -- ^ 'listRunsResponseFirstId' 
  -> Text -- ^ 'listRunsResponseLastId' 
  -> Bool -- ^ 'listRunsResponseHasMore' 
  -> ListRunsResponse
mkListRunsResponse listRunsResponseObject listRunsResponseData listRunsResponseFirstId listRunsResponseLastId listRunsResponseHasMore =
  ListRunsResponse
  { listRunsResponseObject
  , listRunsResponseData
  , listRunsResponseFirstId
  , listRunsResponseLastId
  , listRunsResponseHasMore
  }

-- ** ListThreadsResponse
-- | ListThreadsResponse
data ListThreadsResponse = ListThreadsResponse
  { listThreadsResponseObject :: !(Text) -- ^ /Required/ "object"
  , listThreadsResponseData :: !([ThreadObject]) -- ^ /Required/ "data"
  , listThreadsResponseFirstId :: !(Text) -- ^ /Required/ "first_id"
  , listThreadsResponseLastId :: !(Text) -- ^ /Required/ "last_id"
  , listThreadsResponseHasMore :: !(Bool) -- ^ /Required/ "has_more"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ListThreadsResponse
instance A.FromJSON ListThreadsResponse where
  parseJSON = A.withObject "ListThreadsResponse" $ \o ->
    ListThreadsResponse
      <$> (o .:  "object")
      <*> (o .:  "data")
      <*> (o .:  "first_id")
      <*> (o .:  "last_id")
      <*> (o .:  "has_more")

-- | ToJSON ListThreadsResponse
instance A.ToJSON ListThreadsResponse where
  toJSON ListThreadsResponse {..} =
   _omitNulls
      [ "object" .= listThreadsResponseObject
      , "data" .= listThreadsResponseData
      , "first_id" .= listThreadsResponseFirstId
      , "last_id" .= listThreadsResponseLastId
      , "has_more" .= listThreadsResponseHasMore
      ]


-- | Construct a value of type 'ListThreadsResponse' (by applying it's required fields, if any)
mkListThreadsResponse
  :: Text -- ^ 'listThreadsResponseObject' 
  -> [ThreadObject] -- ^ 'listThreadsResponseData' 
  -> Text -- ^ 'listThreadsResponseFirstId' 
  -> Text -- ^ 'listThreadsResponseLastId' 
  -> Bool -- ^ 'listThreadsResponseHasMore' 
  -> ListThreadsResponse
mkListThreadsResponse listThreadsResponseObject listThreadsResponseData listThreadsResponseFirstId listThreadsResponseLastId listThreadsResponseHasMore =
  ListThreadsResponse
  { listThreadsResponseObject
  , listThreadsResponseData
  , listThreadsResponseFirstId
  , listThreadsResponseLastId
  , listThreadsResponseHasMore
  }

-- ** MessageContentImageFileObject
-- | MessageContentImageFileObject
-- Image file
-- 
-- References an image [File](/docs/api-reference/files) in the content of a message.
data MessageContentImageFileObject = MessageContentImageFileObject
  { messageContentImageFileObjectType :: !(E'Type5) -- ^ /Required/ "type" - Always &#x60;image_file&#x60;.
  , messageContentImageFileObjectImageFile :: !(MessageContentImageFileObjectImageFile) -- ^ /Required/ "image_file"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON MessageContentImageFileObject
instance A.FromJSON MessageContentImageFileObject where
  parseJSON = A.withObject "MessageContentImageFileObject" $ \o ->
    MessageContentImageFileObject
      <$> (o .:  "type")
      <*> (o .:  "image_file")

-- | ToJSON MessageContentImageFileObject
instance A.ToJSON MessageContentImageFileObject where
  toJSON MessageContentImageFileObject {..} =
   _omitNulls
      [ "type" .= messageContentImageFileObjectType
      , "image_file" .= messageContentImageFileObjectImageFile
      ]


-- | Construct a value of type 'MessageContentImageFileObject' (by applying it's required fields, if any)
mkMessageContentImageFileObject
  :: E'Type5 -- ^ 'messageContentImageFileObjectType': Always `image_file`.
  -> MessageContentImageFileObjectImageFile -- ^ 'messageContentImageFileObjectImageFile' 
  -> MessageContentImageFileObject
mkMessageContentImageFileObject messageContentImageFileObjectType messageContentImageFileObjectImageFile =
  MessageContentImageFileObject
  { messageContentImageFileObjectType
  , messageContentImageFileObjectImageFile
  }

-- ** MessageContentImageFileObjectImageFile
-- | MessageContentImageFileObjectImageFile
data MessageContentImageFileObjectImageFile = MessageContentImageFileObjectImageFile
  { messageContentImageFileObjectImageFileFileId :: !(Text) -- ^ /Required/ "file_id" - The [File](/docs/api-reference/files) ID of the image in the message content.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON MessageContentImageFileObjectImageFile
instance A.FromJSON MessageContentImageFileObjectImageFile where
  parseJSON = A.withObject "MessageContentImageFileObjectImageFile" $ \o ->
    MessageContentImageFileObjectImageFile
      <$> (o .:  "file_id")

-- | ToJSON MessageContentImageFileObjectImageFile
instance A.ToJSON MessageContentImageFileObjectImageFile where
  toJSON MessageContentImageFileObjectImageFile {..} =
   _omitNulls
      [ "file_id" .= messageContentImageFileObjectImageFileFileId
      ]


-- | Construct a value of type 'MessageContentImageFileObjectImageFile' (by applying it's required fields, if any)
mkMessageContentImageFileObjectImageFile
  :: Text -- ^ 'messageContentImageFileObjectImageFileFileId': The [File](/docs/api-reference/files) ID of the image in the message content.
  -> MessageContentImageFileObjectImageFile
mkMessageContentImageFileObjectImageFile messageContentImageFileObjectImageFileFileId =
  MessageContentImageFileObjectImageFile
  { messageContentImageFileObjectImageFileFileId
  }

-- ** MessageContentTextAnnotationsFileCitationObject
-- | MessageContentTextAnnotationsFileCitationObject
-- File citation
-- 
-- A citation within the message that points to a specific quote from a specific File associated with the assistant or the message. Generated when the assistant uses the \"retrieval\" tool to search files.
data MessageContentTextAnnotationsFileCitationObject = MessageContentTextAnnotationsFileCitationObject
  { messageContentTextAnnotationsFileCitationObjectType :: !(E'Type6) -- ^ /Required/ "type" - Always &#x60;file_citation&#x60;.
  , messageContentTextAnnotationsFileCitationObjectText :: !(Text) -- ^ /Required/ "text" - The text in the message content that needs to be replaced.
  , messageContentTextAnnotationsFileCitationObjectFileCitation :: !(MessageContentTextAnnotationsFileCitationObjectFileCitation) -- ^ /Required/ "file_citation"
  , messageContentTextAnnotationsFileCitationObjectStartIndex :: !(Int) -- ^ /Required/ "start_index"
  , messageContentTextAnnotationsFileCitationObjectEndIndex :: !(Int) -- ^ /Required/ "end_index"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON MessageContentTextAnnotationsFileCitationObject
instance A.FromJSON MessageContentTextAnnotationsFileCitationObject where
  parseJSON = A.withObject "MessageContentTextAnnotationsFileCitationObject" $ \o ->
    MessageContentTextAnnotationsFileCitationObject
      <$> (o .:  "type")
      <*> (o .:  "text")
      <*> (o .:  "file_citation")
      <*> (o .:  "start_index")
      <*> (o .:  "end_index")

-- | ToJSON MessageContentTextAnnotationsFileCitationObject
instance A.ToJSON MessageContentTextAnnotationsFileCitationObject where
  toJSON MessageContentTextAnnotationsFileCitationObject {..} =
   _omitNulls
      [ "type" .= messageContentTextAnnotationsFileCitationObjectType
      , "text" .= messageContentTextAnnotationsFileCitationObjectText
      , "file_citation" .= messageContentTextAnnotationsFileCitationObjectFileCitation
      , "start_index" .= messageContentTextAnnotationsFileCitationObjectStartIndex
      , "end_index" .= messageContentTextAnnotationsFileCitationObjectEndIndex
      ]


-- | Construct a value of type 'MessageContentTextAnnotationsFileCitationObject' (by applying it's required fields, if any)
mkMessageContentTextAnnotationsFileCitationObject
  :: E'Type6 -- ^ 'messageContentTextAnnotationsFileCitationObjectType': Always `file_citation`.
  -> Text -- ^ 'messageContentTextAnnotationsFileCitationObjectText': The text in the message content that needs to be replaced.
  -> MessageContentTextAnnotationsFileCitationObjectFileCitation -- ^ 'messageContentTextAnnotationsFileCitationObjectFileCitation' 
  -> Int -- ^ 'messageContentTextAnnotationsFileCitationObjectStartIndex' 
  -> Int -- ^ 'messageContentTextAnnotationsFileCitationObjectEndIndex' 
  -> MessageContentTextAnnotationsFileCitationObject
mkMessageContentTextAnnotationsFileCitationObject messageContentTextAnnotationsFileCitationObjectType messageContentTextAnnotationsFileCitationObjectText messageContentTextAnnotationsFileCitationObjectFileCitation messageContentTextAnnotationsFileCitationObjectStartIndex messageContentTextAnnotationsFileCitationObjectEndIndex =
  MessageContentTextAnnotationsFileCitationObject
  { messageContentTextAnnotationsFileCitationObjectType
  , messageContentTextAnnotationsFileCitationObjectText
  , messageContentTextAnnotationsFileCitationObjectFileCitation
  , messageContentTextAnnotationsFileCitationObjectStartIndex
  , messageContentTextAnnotationsFileCitationObjectEndIndex
  }

-- ** MessageContentTextAnnotationsFileCitationObjectFileCitation
-- | MessageContentTextAnnotationsFileCitationObjectFileCitation
data MessageContentTextAnnotationsFileCitationObjectFileCitation = MessageContentTextAnnotationsFileCitationObjectFileCitation
  { messageContentTextAnnotationsFileCitationObjectFileCitationFileId :: !(Text) -- ^ /Required/ "file_id" - The ID of the specific File the citation is from.
  , messageContentTextAnnotationsFileCitationObjectFileCitationQuote :: !(Text) -- ^ /Required/ "quote" - The specific quote in the file.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON MessageContentTextAnnotationsFileCitationObjectFileCitation
instance A.FromJSON MessageContentTextAnnotationsFileCitationObjectFileCitation where
  parseJSON = A.withObject "MessageContentTextAnnotationsFileCitationObjectFileCitation" $ \o ->
    MessageContentTextAnnotationsFileCitationObjectFileCitation
      <$> (o .:  "file_id")
      <*> (o .:  "quote")

-- | ToJSON MessageContentTextAnnotationsFileCitationObjectFileCitation
instance A.ToJSON MessageContentTextAnnotationsFileCitationObjectFileCitation where
  toJSON MessageContentTextAnnotationsFileCitationObjectFileCitation {..} =
   _omitNulls
      [ "file_id" .= messageContentTextAnnotationsFileCitationObjectFileCitationFileId
      , "quote" .= messageContentTextAnnotationsFileCitationObjectFileCitationQuote
      ]


-- | Construct a value of type 'MessageContentTextAnnotationsFileCitationObjectFileCitation' (by applying it's required fields, if any)
mkMessageContentTextAnnotationsFileCitationObjectFileCitation
  :: Text -- ^ 'messageContentTextAnnotationsFileCitationObjectFileCitationFileId': The ID of the specific File the citation is from.
  -> Text -- ^ 'messageContentTextAnnotationsFileCitationObjectFileCitationQuote': The specific quote in the file.
  -> MessageContentTextAnnotationsFileCitationObjectFileCitation
mkMessageContentTextAnnotationsFileCitationObjectFileCitation messageContentTextAnnotationsFileCitationObjectFileCitationFileId messageContentTextAnnotationsFileCitationObjectFileCitationQuote =
  MessageContentTextAnnotationsFileCitationObjectFileCitation
  { messageContentTextAnnotationsFileCitationObjectFileCitationFileId
  , messageContentTextAnnotationsFileCitationObjectFileCitationQuote
  }

-- ** MessageContentTextAnnotationsFilePathObject
-- | MessageContentTextAnnotationsFilePathObject
-- File path
-- 
-- A URL for the file that's generated when the assistant used the `code_interpreter` tool to generate a file.
data MessageContentTextAnnotationsFilePathObject = MessageContentTextAnnotationsFilePathObject
  { messageContentTextAnnotationsFilePathObjectType :: !(E'Type7) -- ^ /Required/ "type" - Always &#x60;file_path&#x60;.
  , messageContentTextAnnotationsFilePathObjectText :: !(Text) -- ^ /Required/ "text" - The text in the message content that needs to be replaced.
  , messageContentTextAnnotationsFilePathObjectFilePath :: !(MessageContentTextAnnotationsFilePathObjectFilePath) -- ^ /Required/ "file_path"
  , messageContentTextAnnotationsFilePathObjectStartIndex :: !(Int) -- ^ /Required/ "start_index"
  , messageContentTextAnnotationsFilePathObjectEndIndex :: !(Int) -- ^ /Required/ "end_index"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON MessageContentTextAnnotationsFilePathObject
instance A.FromJSON MessageContentTextAnnotationsFilePathObject where
  parseJSON = A.withObject "MessageContentTextAnnotationsFilePathObject" $ \o ->
    MessageContentTextAnnotationsFilePathObject
      <$> (o .:  "type")
      <*> (o .:  "text")
      <*> (o .:  "file_path")
      <*> (o .:  "start_index")
      <*> (o .:  "end_index")

-- | ToJSON MessageContentTextAnnotationsFilePathObject
instance A.ToJSON MessageContentTextAnnotationsFilePathObject where
  toJSON MessageContentTextAnnotationsFilePathObject {..} =
   _omitNulls
      [ "type" .= messageContentTextAnnotationsFilePathObjectType
      , "text" .= messageContentTextAnnotationsFilePathObjectText
      , "file_path" .= messageContentTextAnnotationsFilePathObjectFilePath
      , "start_index" .= messageContentTextAnnotationsFilePathObjectStartIndex
      , "end_index" .= messageContentTextAnnotationsFilePathObjectEndIndex
      ]


-- | Construct a value of type 'MessageContentTextAnnotationsFilePathObject' (by applying it's required fields, if any)
mkMessageContentTextAnnotationsFilePathObject
  :: E'Type7 -- ^ 'messageContentTextAnnotationsFilePathObjectType': Always `file_path`.
  -> Text -- ^ 'messageContentTextAnnotationsFilePathObjectText': The text in the message content that needs to be replaced.
  -> MessageContentTextAnnotationsFilePathObjectFilePath -- ^ 'messageContentTextAnnotationsFilePathObjectFilePath' 
  -> Int -- ^ 'messageContentTextAnnotationsFilePathObjectStartIndex' 
  -> Int -- ^ 'messageContentTextAnnotationsFilePathObjectEndIndex' 
  -> MessageContentTextAnnotationsFilePathObject
mkMessageContentTextAnnotationsFilePathObject messageContentTextAnnotationsFilePathObjectType messageContentTextAnnotationsFilePathObjectText messageContentTextAnnotationsFilePathObjectFilePath messageContentTextAnnotationsFilePathObjectStartIndex messageContentTextAnnotationsFilePathObjectEndIndex =
  MessageContentTextAnnotationsFilePathObject
  { messageContentTextAnnotationsFilePathObjectType
  , messageContentTextAnnotationsFilePathObjectText
  , messageContentTextAnnotationsFilePathObjectFilePath
  , messageContentTextAnnotationsFilePathObjectStartIndex
  , messageContentTextAnnotationsFilePathObjectEndIndex
  }

-- ** MessageContentTextAnnotationsFilePathObjectFilePath
-- | MessageContentTextAnnotationsFilePathObjectFilePath
data MessageContentTextAnnotationsFilePathObjectFilePath = MessageContentTextAnnotationsFilePathObjectFilePath
  { messageContentTextAnnotationsFilePathObjectFilePathFileId :: !(Text) -- ^ /Required/ "file_id" - The ID of the file that was generated.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON MessageContentTextAnnotationsFilePathObjectFilePath
instance A.FromJSON MessageContentTextAnnotationsFilePathObjectFilePath where
  parseJSON = A.withObject "MessageContentTextAnnotationsFilePathObjectFilePath" $ \o ->
    MessageContentTextAnnotationsFilePathObjectFilePath
      <$> (o .:  "file_id")

-- | ToJSON MessageContentTextAnnotationsFilePathObjectFilePath
instance A.ToJSON MessageContentTextAnnotationsFilePathObjectFilePath where
  toJSON MessageContentTextAnnotationsFilePathObjectFilePath {..} =
   _omitNulls
      [ "file_id" .= messageContentTextAnnotationsFilePathObjectFilePathFileId
      ]


-- | Construct a value of type 'MessageContentTextAnnotationsFilePathObjectFilePath' (by applying it's required fields, if any)
mkMessageContentTextAnnotationsFilePathObjectFilePath
  :: Text -- ^ 'messageContentTextAnnotationsFilePathObjectFilePathFileId': The ID of the file that was generated.
  -> MessageContentTextAnnotationsFilePathObjectFilePath
mkMessageContentTextAnnotationsFilePathObjectFilePath messageContentTextAnnotationsFilePathObjectFilePathFileId =
  MessageContentTextAnnotationsFilePathObjectFilePath
  { messageContentTextAnnotationsFilePathObjectFilePathFileId
  }

-- ** MessageContentTextObject
-- | MessageContentTextObject
-- Text
-- 
-- The text content that is part of a message.
data MessageContentTextObject = MessageContentTextObject
  { messageContentTextObjectType :: !(E'Type2) -- ^ /Required/ "type" - Always &#x60;text&#x60;.
  , messageContentTextObjectText :: !(MessageContentTextObjectText) -- ^ /Required/ "text"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON MessageContentTextObject
instance A.FromJSON MessageContentTextObject where
  parseJSON = A.withObject "MessageContentTextObject" $ \o ->
    MessageContentTextObject
      <$> (o .:  "type")
      <*> (o .:  "text")

-- | ToJSON MessageContentTextObject
instance A.ToJSON MessageContentTextObject where
  toJSON MessageContentTextObject {..} =
   _omitNulls
      [ "type" .= messageContentTextObjectType
      , "text" .= messageContentTextObjectText
      ]


-- | Construct a value of type 'MessageContentTextObject' (by applying it's required fields, if any)
mkMessageContentTextObject
  :: E'Type2 -- ^ 'messageContentTextObjectType': Always `text`.
  -> MessageContentTextObjectText -- ^ 'messageContentTextObjectText' 
  -> MessageContentTextObject
mkMessageContentTextObject messageContentTextObjectType messageContentTextObjectText =
  MessageContentTextObject
  { messageContentTextObjectType
  , messageContentTextObjectText
  }

-- ** MessageContentTextObjectText
-- | MessageContentTextObjectText
data MessageContentTextObjectText = MessageContentTextObjectText
  { messageContentTextObjectTextValue :: !(Text) -- ^ /Required/ "value" - The data that makes up the text.
  , messageContentTextObjectTextAnnotations :: !([MessageContentTextObjectTextAnnotationsInner]) -- ^ /Required/ "annotations"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON MessageContentTextObjectText
instance A.FromJSON MessageContentTextObjectText where
  parseJSON = A.withObject "MessageContentTextObjectText" $ \o ->
    MessageContentTextObjectText
      <$> (o .:  "value")
      <*> (o .:  "annotations")

-- | ToJSON MessageContentTextObjectText
instance A.ToJSON MessageContentTextObjectText where
  toJSON MessageContentTextObjectText {..} =
   _omitNulls
      [ "value" .= messageContentTextObjectTextValue
      , "annotations" .= messageContentTextObjectTextAnnotations
      ]


-- | Construct a value of type 'MessageContentTextObjectText' (by applying it's required fields, if any)
mkMessageContentTextObjectText
  :: Text -- ^ 'messageContentTextObjectTextValue': The data that makes up the text.
  -> [MessageContentTextObjectTextAnnotationsInner] -- ^ 'messageContentTextObjectTextAnnotations' 
  -> MessageContentTextObjectText
mkMessageContentTextObjectText messageContentTextObjectTextValue messageContentTextObjectTextAnnotations =
  MessageContentTextObjectText
  { messageContentTextObjectTextValue
  , messageContentTextObjectTextAnnotations
  }

-- ** MessageContentTextObjectTextAnnotationsInner
-- | MessageContentTextObjectTextAnnotationsInner
data MessageContentTextObjectTextAnnotationsInner = MessageContentTextObjectTextAnnotationsInner
  { messageContentTextObjectTextAnnotationsInnerType :: !(E'Type7) -- ^ /Required/ "type" - Always &#x60;file_path&#x60;.
  , messageContentTextObjectTextAnnotationsInnerText :: !(Text) -- ^ /Required/ "text" - The text in the message content that needs to be replaced.
  , messageContentTextObjectTextAnnotationsInnerFileCitation :: !(MessageContentTextAnnotationsFileCitationObjectFileCitation) -- ^ /Required/ "file_citation"
  , messageContentTextObjectTextAnnotationsInnerStartIndex :: !(Int) -- ^ /Required/ "start_index"
  , messageContentTextObjectTextAnnotationsInnerEndIndex :: !(Int) -- ^ /Required/ "end_index"
  , messageContentTextObjectTextAnnotationsInnerFilePath :: !(MessageContentTextAnnotationsFilePathObjectFilePath) -- ^ /Required/ "file_path"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON MessageContentTextObjectTextAnnotationsInner
instance A.FromJSON MessageContentTextObjectTextAnnotationsInner where
  parseJSON = A.withObject "MessageContentTextObjectTextAnnotationsInner" $ \o ->
    MessageContentTextObjectTextAnnotationsInner
      <$> (o .:  "type")
      <*> (o .:  "text")
      <*> (o .:  "file_citation")
      <*> (o .:  "start_index")
      <*> (o .:  "end_index")
      <*> (o .:  "file_path")

-- | ToJSON MessageContentTextObjectTextAnnotationsInner
instance A.ToJSON MessageContentTextObjectTextAnnotationsInner where
  toJSON MessageContentTextObjectTextAnnotationsInner {..} =
   _omitNulls
      [ "type" .= messageContentTextObjectTextAnnotationsInnerType
      , "text" .= messageContentTextObjectTextAnnotationsInnerText
      , "file_citation" .= messageContentTextObjectTextAnnotationsInnerFileCitation
      , "start_index" .= messageContentTextObjectTextAnnotationsInnerStartIndex
      , "end_index" .= messageContentTextObjectTextAnnotationsInnerEndIndex
      , "file_path" .= messageContentTextObjectTextAnnotationsInnerFilePath
      ]


-- | Construct a value of type 'MessageContentTextObjectTextAnnotationsInner' (by applying it's required fields, if any)
mkMessageContentTextObjectTextAnnotationsInner
  :: E'Type7 -- ^ 'messageContentTextObjectTextAnnotationsInnerType': Always `file_path`.
  -> Text -- ^ 'messageContentTextObjectTextAnnotationsInnerText': The text in the message content that needs to be replaced.
  -> MessageContentTextAnnotationsFileCitationObjectFileCitation -- ^ 'messageContentTextObjectTextAnnotationsInnerFileCitation' 
  -> Int -- ^ 'messageContentTextObjectTextAnnotationsInnerStartIndex' 
  -> Int -- ^ 'messageContentTextObjectTextAnnotationsInnerEndIndex' 
  -> MessageContentTextAnnotationsFilePathObjectFilePath -- ^ 'messageContentTextObjectTextAnnotationsInnerFilePath' 
  -> MessageContentTextObjectTextAnnotationsInner
mkMessageContentTextObjectTextAnnotationsInner messageContentTextObjectTextAnnotationsInnerType messageContentTextObjectTextAnnotationsInnerText messageContentTextObjectTextAnnotationsInnerFileCitation messageContentTextObjectTextAnnotationsInnerStartIndex messageContentTextObjectTextAnnotationsInnerEndIndex messageContentTextObjectTextAnnotationsInnerFilePath =
  MessageContentTextObjectTextAnnotationsInner
  { messageContentTextObjectTextAnnotationsInnerType
  , messageContentTextObjectTextAnnotationsInnerText
  , messageContentTextObjectTextAnnotationsInnerFileCitation
  , messageContentTextObjectTextAnnotationsInnerStartIndex
  , messageContentTextObjectTextAnnotationsInnerEndIndex
  , messageContentTextObjectTextAnnotationsInnerFilePath
  }

-- ** MessageFileObject
-- | MessageFileObject
-- Message files
-- 
-- A list of files attached to a `message`.
data MessageFileObject = MessageFileObject
  { messageFileObjectId :: !(Text) -- ^ /Required/ "id" - The identifier, which can be referenced in API endpoints.
  , messageFileObjectObject :: !(E'Object19) -- ^ /Required/ "object" - The object type, which is always &#x60;thread.message.file&#x60;.
  , messageFileObjectCreatedAt :: !(Int) -- ^ /Required/ "created_at" - The Unix timestamp (in seconds) for when the message file was created.
  , messageFileObjectMessageId :: !(Text) -- ^ /Required/ "message_id" - The ID of the [message](/docs/api-reference/messages) that the [File](/docs/api-reference/files) is attached to.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON MessageFileObject
instance A.FromJSON MessageFileObject where
  parseJSON = A.withObject "MessageFileObject" $ \o ->
    MessageFileObject
      <$> (o .:  "id")
      <*> (o .:  "object")
      <*> (o .:  "created_at")
      <*> (o .:  "message_id")

-- | ToJSON MessageFileObject
instance A.ToJSON MessageFileObject where
  toJSON MessageFileObject {..} =
   _omitNulls
      [ "id" .= messageFileObjectId
      , "object" .= messageFileObjectObject
      , "created_at" .= messageFileObjectCreatedAt
      , "message_id" .= messageFileObjectMessageId
      ]


-- | Construct a value of type 'MessageFileObject' (by applying it's required fields, if any)
mkMessageFileObject
  :: Text -- ^ 'messageFileObjectId': The identifier, which can be referenced in API endpoints.
  -> E'Object19 -- ^ 'messageFileObjectObject': The object type, which is always `thread.message.file`.
  -> Int -- ^ 'messageFileObjectCreatedAt': The Unix timestamp (in seconds) for when the message file was created.
  -> Text -- ^ 'messageFileObjectMessageId': The ID of the [message](/docs/api-reference/messages) that the [File](/docs/api-reference/files) is attached to.
  -> MessageFileObject
mkMessageFileObject messageFileObjectId messageFileObjectObject messageFileObjectCreatedAt messageFileObjectMessageId =
  MessageFileObject
  { messageFileObjectId
  , messageFileObjectObject
  , messageFileObjectCreatedAt
  , messageFileObjectMessageId
  }

-- ** MessageObject
-- | MessageObject
-- The message object
-- 
-- Represents a message within a [thread](/docs/api-reference/threads).
data MessageObject = MessageObject
  { messageObjectId :: !(Text) -- ^ /Required/ "id" - The identifier, which can be referenced in API endpoints.
  , messageObjectObject :: !(E'Object14) -- ^ /Required/ "object" - The object type, which is always &#x60;thread.message&#x60;.
  , messageObjectCreatedAt :: !(Int) -- ^ /Required/ "created_at" - The Unix timestamp (in seconds) for when the message was created.
  , messageObjectThreadId :: !(Text) -- ^ /Required/ "thread_id" - The [thread](/docs/api-reference/threads) ID that this message belongs to.
  , messageObjectRole :: !(E'Role7) -- ^ /Required/ "role" - The entity that produced the message. One of &#x60;user&#x60; or &#x60;assistant&#x60;.
  , messageObjectContent :: !([MessageObjectContentInner]) -- ^ /Required/ "content" - The content of the message in array of text and/or images.
  , messageObjectAssistantId :: !(Text) -- ^ /Required/ "assistant_id" - If applicable, the ID of the [assistant](/docs/api-reference/assistants) that authored this message.
  , messageObjectRunId :: !(Text) -- ^ /Required/ "run_id" - If applicable, the ID of the [run](/docs/api-reference/runs) associated with the authoring of this message.
  , messageObjectFileIds :: !([Text]) -- ^ /Required/ "file_ids" - A list of [file](/docs/api-reference/files) IDs that the assistant should use. Useful for tools like retrieval and code_interpreter that can access files. A maximum of 10 files can be attached to a message.
  , messageObjectMetadata :: !(A.Value) -- ^ /Required/ "metadata" - Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON MessageObject
instance A.FromJSON MessageObject where
  parseJSON = A.withObject "MessageObject" $ \o ->
    MessageObject
      <$> (o .:  "id")
      <*> (o .:  "object")
      <*> (o .:  "created_at")
      <*> (o .:  "thread_id")
      <*> (o .:  "role")
      <*> (o .:  "content")
      <*> (o .:  "assistant_id")
      <*> (o .:  "run_id")
      <*> (o .:  "file_ids")
      <*> (o .:  "metadata")

-- | ToJSON MessageObject
instance A.ToJSON MessageObject where
  toJSON MessageObject {..} =
   _omitNulls
      [ "id" .= messageObjectId
      , "object" .= messageObjectObject
      , "created_at" .= messageObjectCreatedAt
      , "thread_id" .= messageObjectThreadId
      , "role" .= messageObjectRole
      , "content" .= messageObjectContent
      , "assistant_id" .= messageObjectAssistantId
      , "run_id" .= messageObjectRunId
      , "file_ids" .= messageObjectFileIds
      , "metadata" .= messageObjectMetadata
      ]


-- | Construct a value of type 'MessageObject' (by applying it's required fields, if any)
mkMessageObject
  :: Text -- ^ 'messageObjectId': The identifier, which can be referenced in API endpoints.
  -> E'Object14 -- ^ 'messageObjectObject': The object type, which is always `thread.message`.
  -> Int -- ^ 'messageObjectCreatedAt': The Unix timestamp (in seconds) for when the message was created.
  -> Text -- ^ 'messageObjectThreadId': The [thread](/docs/api-reference/threads) ID that this message belongs to.
  -> E'Role7 -- ^ 'messageObjectRole': The entity that produced the message. One of `user` or `assistant`.
  -> [MessageObjectContentInner] -- ^ 'messageObjectContent': The content of the message in array of text and/or images.
  -> Text -- ^ 'messageObjectAssistantId': If applicable, the ID of the [assistant](/docs/api-reference/assistants) that authored this message.
  -> Text -- ^ 'messageObjectRunId': If applicable, the ID of the [run](/docs/api-reference/runs) associated with the authoring of this message.
  -> [Text] -- ^ 'messageObjectFileIds': A list of [file](/docs/api-reference/files) IDs that the assistant should use. Useful for tools like retrieval and code_interpreter that can access files. A maximum of 10 files can be attached to a message.
  -> A.Value -- ^ 'messageObjectMetadata': Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long. 
  -> MessageObject
mkMessageObject messageObjectId messageObjectObject messageObjectCreatedAt messageObjectThreadId messageObjectRole messageObjectContent messageObjectAssistantId messageObjectRunId messageObjectFileIds messageObjectMetadata =
  MessageObject
  { messageObjectId
  , messageObjectObject
  , messageObjectCreatedAt
  , messageObjectThreadId
  , messageObjectRole
  , messageObjectContent
  , messageObjectAssistantId
  , messageObjectRunId
  , messageObjectFileIds
  , messageObjectMetadata
  }

-- ** MessageObjectContentInner
-- | MessageObjectContentInner
data MessageObjectContentInner = MessageObjectContentInner
  { messageObjectContentInnerType :: !(E'Type2) -- ^ /Required/ "type" - Always &#x60;text&#x60;.
  , messageObjectContentInnerImageFile :: !(MessageContentImageFileObjectImageFile) -- ^ /Required/ "image_file"
  , messageObjectContentInnerText :: !(MessageContentTextObjectText) -- ^ /Required/ "text"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON MessageObjectContentInner
instance A.FromJSON MessageObjectContentInner where
  parseJSON = A.withObject "MessageObjectContentInner" $ \o ->
    MessageObjectContentInner
      <$> (o .:  "type")
      <*> (o .:  "image_file")
      <*> (o .:  "text")

-- | ToJSON MessageObjectContentInner
instance A.ToJSON MessageObjectContentInner where
  toJSON MessageObjectContentInner {..} =
   _omitNulls
      [ "type" .= messageObjectContentInnerType
      , "image_file" .= messageObjectContentInnerImageFile
      , "text" .= messageObjectContentInnerText
      ]


-- | Construct a value of type 'MessageObjectContentInner' (by applying it's required fields, if any)
mkMessageObjectContentInner
  :: E'Type2 -- ^ 'messageObjectContentInnerType': Always `text`.
  -> MessageContentImageFileObjectImageFile -- ^ 'messageObjectContentInnerImageFile' 
  -> MessageContentTextObjectText -- ^ 'messageObjectContentInnerText' 
  -> MessageObjectContentInner
mkMessageObjectContentInner messageObjectContentInnerType messageObjectContentInnerImageFile messageObjectContentInnerText =
  MessageObjectContentInner
  { messageObjectContentInnerType
  , messageObjectContentInnerImageFile
  , messageObjectContentInnerText
  }

-- ** Model
-- | Model
-- Model
-- 
-- Describes an OpenAI model offering that can be used with the API.
data Model = Model
  { modelId :: !(Text) -- ^ /Required/ "id" - The model identifier, which can be referenced in the API endpoints.
  , modelCreated :: !(Int) -- ^ /Required/ "created" - The Unix timestamp (in seconds) when the model was created.
  , modelObject :: !(E'Object6) -- ^ /Required/ "object" - The object type, which is always \&quot;model\&quot;.
  , modelOwnedBy :: !(Text) -- ^ /Required/ "owned_by" - The organization that owns the model.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON Model
instance A.FromJSON Model where
  parseJSON = A.withObject "Model" $ \o ->
    Model
      <$> (o .:  "id")
      <*> (o .:  "created")
      <*> (o .:  "object")
      <*> (o .:  "owned_by")

-- | ToJSON Model
instance A.ToJSON Model where
  toJSON Model {..} =
   _omitNulls
      [ "id" .= modelId
      , "created" .= modelCreated
      , "object" .= modelObject
      , "owned_by" .= modelOwnedBy
      ]


-- | Construct a value of type 'Model' (by applying it's required fields, if any)
mkModel
  :: Text -- ^ 'modelId': The model identifier, which can be referenced in the API endpoints.
  -> Int -- ^ 'modelCreated': The Unix timestamp (in seconds) when the model was created.
  -> E'Object6 -- ^ 'modelObject': The object type, which is always \"model\".
  -> Text -- ^ 'modelOwnedBy': The organization that owns the model.
  -> Model
mkModel modelId modelCreated modelObject modelOwnedBy =
  Model
  { modelId
  , modelCreated
  , modelObject
  , modelOwnedBy
  }

-- ** ModifyAssistantRequest
-- | ModifyAssistantRequest
data ModifyAssistantRequest = ModifyAssistantRequest
  { modifyAssistantRequestModel :: !(Maybe CreateAssistantRequestModel) -- ^ "model"
  , modifyAssistantRequestName :: !(Maybe Text) -- ^ "name" - The name of the assistant. The maximum length is 256 characters. 
  , modifyAssistantRequestDescription :: !(Maybe Text) -- ^ "description" - The description of the assistant. The maximum length is 512 characters. 
  , modifyAssistantRequestInstructions :: !(Maybe Text) -- ^ "instructions" - The system instructions that the assistant uses. The maximum length is 32768 characters. 
  , modifyAssistantRequestTools :: !(Maybe [AssistantObjectToolsInner]) -- ^ "tools" - A list of tool enabled on the assistant. There can be a maximum of 128 tools per assistant. Tools can be of types &#x60;code_interpreter&#x60;, &#x60;retrieval&#x60;, or &#x60;function&#x60;. 
  , modifyAssistantRequestFileIds :: !(Maybe [Text]) -- ^ "file_ids" - A list of [File](/docs/api-reference/files) IDs attached to this assistant. There can be a maximum of 20 files attached to the assistant. Files are ordered by their creation date in ascending order. If a file was previously attached to the list but does not show up in the list, it will be deleted from the assistant. 
  , modifyAssistantRequestMetadata :: !(Maybe A.Value) -- ^ "metadata" - Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ModifyAssistantRequest
instance A.FromJSON ModifyAssistantRequest where
  parseJSON = A.withObject "ModifyAssistantRequest" $ \o ->
    ModifyAssistantRequest
      <$> (o .:? "model")
      <*> (o .:? "name")
      <*> (o .:? "description")
      <*> (o .:? "instructions")
      <*> (o .:? "tools")
      <*> (o .:? "file_ids")
      <*> (o .:? "metadata")

-- | ToJSON ModifyAssistantRequest
instance A.ToJSON ModifyAssistantRequest where
  toJSON ModifyAssistantRequest {..} =
   _omitNulls
      [ "model" .= modifyAssistantRequestModel
      , "name" .= modifyAssistantRequestName
      , "description" .= modifyAssistantRequestDescription
      , "instructions" .= modifyAssistantRequestInstructions
      , "tools" .= modifyAssistantRequestTools
      , "file_ids" .= modifyAssistantRequestFileIds
      , "metadata" .= modifyAssistantRequestMetadata
      ]


-- | Construct a value of type 'ModifyAssistantRequest' (by applying it's required fields, if any)
mkModifyAssistantRequest
  :: ModifyAssistantRequest
mkModifyAssistantRequest =
  ModifyAssistantRequest
  { modifyAssistantRequestModel = Nothing
  , modifyAssistantRequestName = Nothing
  , modifyAssistantRequestDescription = Nothing
  , modifyAssistantRequestInstructions = Nothing
  , modifyAssistantRequestTools = Nothing
  , modifyAssistantRequestFileIds = Nothing
  , modifyAssistantRequestMetadata = Nothing
  }

-- ** ModifyMessageRequest
-- | ModifyMessageRequest
data ModifyMessageRequest = ModifyMessageRequest
  { modifyMessageRequestMetadata :: !(Maybe A.Value) -- ^ "metadata" - Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ModifyMessageRequest
instance A.FromJSON ModifyMessageRequest where
  parseJSON = A.withObject "ModifyMessageRequest" $ \o ->
    ModifyMessageRequest
      <$> (o .:? "metadata")

-- | ToJSON ModifyMessageRequest
instance A.ToJSON ModifyMessageRequest where
  toJSON ModifyMessageRequest {..} =
   _omitNulls
      [ "metadata" .= modifyMessageRequestMetadata
      ]


-- | Construct a value of type 'ModifyMessageRequest' (by applying it's required fields, if any)
mkModifyMessageRequest
  :: ModifyMessageRequest
mkModifyMessageRequest =
  ModifyMessageRequest
  { modifyMessageRequestMetadata = Nothing
  }

-- ** ModifyRunRequest
-- | ModifyRunRequest
data ModifyRunRequest = ModifyRunRequest
  { modifyRunRequestMetadata :: !(Maybe A.Value) -- ^ "metadata" - Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ModifyRunRequest
instance A.FromJSON ModifyRunRequest where
  parseJSON = A.withObject "ModifyRunRequest" $ \o ->
    ModifyRunRequest
      <$> (o .:? "metadata")

-- | ToJSON ModifyRunRequest
instance A.ToJSON ModifyRunRequest where
  toJSON ModifyRunRequest {..} =
   _omitNulls
      [ "metadata" .= modifyRunRequestMetadata
      ]


-- | Construct a value of type 'ModifyRunRequest' (by applying it's required fields, if any)
mkModifyRunRequest
  :: ModifyRunRequest
mkModifyRunRequest =
  ModifyRunRequest
  { modifyRunRequestMetadata = Nothing
  }

-- ** ModifyThreadRequest
-- | ModifyThreadRequest
data ModifyThreadRequest = ModifyThreadRequest
  { modifyThreadRequestMetadata :: !(Maybe A.Value) -- ^ "metadata" - Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ModifyThreadRequest
instance A.FromJSON ModifyThreadRequest where
  parseJSON = A.withObject "ModifyThreadRequest" $ \o ->
    ModifyThreadRequest
      <$> (o .:? "metadata")

-- | ToJSON ModifyThreadRequest
instance A.ToJSON ModifyThreadRequest where
  toJSON ModifyThreadRequest {..} =
   _omitNulls
      [ "metadata" .= modifyThreadRequestMetadata
      ]


-- | Construct a value of type 'ModifyThreadRequest' (by applying it's required fields, if any)
mkModifyThreadRequest
  :: ModifyThreadRequest
mkModifyThreadRequest =
  ModifyThreadRequest
  { modifyThreadRequestMetadata = Nothing
  }

-- ** OpenAIFile
-- | OpenAIFile
-- OpenAIFile
-- 
-- The `File` object represents a document that has been uploaded to OpenAI.
data OpenAIFile = OpenAIFile
  { openAIFileId :: !(Text) -- ^ /Required/ "id" - The file identifier, which can be referenced in the API endpoints.
  , openAIFileBytes :: !(Int) -- ^ /Required/ "bytes" - The size of the file, in bytes.
  , openAIFileCreatedAt :: !(Int) -- ^ /Required/ "created_at" - The Unix timestamp (in seconds) for when the file was created.
  , openAIFileFilename :: !(Text) -- ^ /Required/ "filename" - The name of the file.
  , openAIFileObject :: !(E'Object5) -- ^ /Required/ "object" - The object type, which is always &#x60;file&#x60;.
  , openAIFilePurpose :: !(E'Purpose) -- ^ /Required/ "purpose" - The intended purpose of the file. Supported values are &#x60;fine-tune&#x60;, &#x60;fine-tune-results&#x60;, &#x60;assistants&#x60;, and &#x60;assistants_output&#x60;.
  , openAIFileStatus :: !(E'Status) -- ^ /Required/ "status" - Deprecated. The current status of the file, which can be either &#x60;uploaded&#x60;, &#x60;processed&#x60;, or &#x60;error&#x60;.
  , openAIFileStatusDetails :: !(Maybe Text) -- ^ "status_details" - Deprecated. For details on why a fine-tuning training file failed validation, see the &#x60;error&#x60; field on &#x60;fine_tuning.job&#x60;.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON OpenAIFile
instance A.FromJSON OpenAIFile where
  parseJSON = A.withObject "OpenAIFile" $ \o ->
    OpenAIFile
      <$> (o .:  "id")
      <*> (o .:  "bytes")
      <*> (o .:  "created_at")
      <*> (o .:  "filename")
      <*> (o .:  "object")
      <*> (o .:  "purpose")
      <*> (o .:  "status")
      <*> (o .:? "status_details")

-- | ToJSON OpenAIFile
instance A.ToJSON OpenAIFile where
  toJSON OpenAIFile {..} =
   _omitNulls
      [ "id" .= openAIFileId
      , "bytes" .= openAIFileBytes
      , "created_at" .= openAIFileCreatedAt
      , "filename" .= openAIFileFilename
      , "object" .= openAIFileObject
      , "purpose" .= openAIFilePurpose
      , "status" .= openAIFileStatus
      , "status_details" .= openAIFileStatusDetails
      ]


-- | Construct a value of type 'OpenAIFile' (by applying it's required fields, if any)
mkOpenAIFile
  :: Text -- ^ 'openAIFileId': The file identifier, which can be referenced in the API endpoints.
  -> Int -- ^ 'openAIFileBytes': The size of the file, in bytes.
  -> Int -- ^ 'openAIFileCreatedAt': The Unix timestamp (in seconds) for when the file was created.
  -> Text -- ^ 'openAIFileFilename': The name of the file.
  -> E'Object5 -- ^ 'openAIFileObject': The object type, which is always `file`.
  -> E'Purpose -- ^ 'openAIFilePurpose': The intended purpose of the file. Supported values are `fine-tune`, `fine-tune-results`, `assistants`, and `assistants_output`.
  -> E'Status -- ^ 'openAIFileStatus': Deprecated. The current status of the file, which can be either `uploaded`, `processed`, or `error`.
  -> OpenAIFile
mkOpenAIFile openAIFileId openAIFileBytes openAIFileCreatedAt openAIFileFilename openAIFileObject openAIFilePurpose openAIFileStatus =
  OpenAIFile
  { openAIFileId
  , openAIFileBytes
  , openAIFileCreatedAt
  , openAIFileFilename
  , openAIFileObject
  , openAIFilePurpose
  , openAIFileStatus
  , openAIFileStatusDetails = Nothing
  }

-- ** RunCompletionUsage
-- | RunCompletionUsage
-- Usage statistics related to the run. This value will be `null` if the run is not in a terminal state (i.e. `in_progress`, `queued`, etc.).
data RunCompletionUsage = RunCompletionUsage
  { runCompletionUsageCompletionTokens :: !(Int) -- ^ /Required/ "completion_tokens" - Number of completion tokens used over the course of the run.
  , runCompletionUsagePromptTokens :: !(Int) -- ^ /Required/ "prompt_tokens" - Number of prompt tokens used over the course of the run.
  , runCompletionUsageTotalTokens :: !(Int) -- ^ /Required/ "total_tokens" - Total number of tokens used (prompt + completion).
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON RunCompletionUsage
instance A.FromJSON RunCompletionUsage where
  parseJSON = A.withObject "RunCompletionUsage" $ \o ->
    RunCompletionUsage
      <$> (o .:  "completion_tokens")
      <*> (o .:  "prompt_tokens")
      <*> (o .:  "total_tokens")

-- | ToJSON RunCompletionUsage
instance A.ToJSON RunCompletionUsage where
  toJSON RunCompletionUsage {..} =
   _omitNulls
      [ "completion_tokens" .= runCompletionUsageCompletionTokens
      , "prompt_tokens" .= runCompletionUsagePromptTokens
      , "total_tokens" .= runCompletionUsageTotalTokens
      ]


-- | Construct a value of type 'RunCompletionUsage' (by applying it's required fields, if any)
mkRunCompletionUsage
  :: Int -- ^ 'runCompletionUsageCompletionTokens': Number of completion tokens used over the course of the run.
  -> Int -- ^ 'runCompletionUsagePromptTokens': Number of prompt tokens used over the course of the run.
  -> Int -- ^ 'runCompletionUsageTotalTokens': Total number of tokens used (prompt + completion).
  -> RunCompletionUsage
mkRunCompletionUsage runCompletionUsageCompletionTokens runCompletionUsagePromptTokens runCompletionUsageTotalTokens =
  RunCompletionUsage
  { runCompletionUsageCompletionTokens
  , runCompletionUsagePromptTokens
  , runCompletionUsageTotalTokens
  }

-- ** RunObject
-- | RunObject
-- A run on a thread
-- 
-- Represents an execution run on a [thread](/docs/api-reference/threads).
data RunObject = RunObject
  { runObjectId :: !(Text) -- ^ /Required/ "id" - The identifier, which can be referenced in API endpoints.
  , runObjectObject :: !(E'Object11) -- ^ /Required/ "object" - The object type, which is always &#x60;thread.run&#x60;.
  , runObjectCreatedAt :: !(Int) -- ^ /Required/ "created_at" - The Unix timestamp (in seconds) for when the run was created.
  , runObjectThreadId :: !(Text) -- ^ /Required/ "thread_id" - The ID of the [thread](/docs/api-reference/threads) that was executed on as a part of this run.
  , runObjectAssistantId :: !(Text) -- ^ /Required/ "assistant_id" - The ID of the [assistant](/docs/api-reference/assistants) used for execution of this run.
  , runObjectStatus :: !(E'Status3) -- ^ /Required/ "status" - The status of the run, which can be either &#x60;queued&#x60;, &#x60;in_progress&#x60;, &#x60;requires_action&#x60;, &#x60;cancelling&#x60;, &#x60;cancelled&#x60;, &#x60;failed&#x60;, &#x60;completed&#x60;, or &#x60;expired&#x60;.
  , runObjectRequiredAction :: !(RunObjectRequiredAction) -- ^ /Required/ "required_action"
  , runObjectLastError :: !(RunObjectLastError) -- ^ /Required/ "last_error"
  , runObjectExpiresAt :: !(Int) -- ^ /Required/ "expires_at" - The Unix timestamp (in seconds) for when the run will expire.
  , runObjectStartedAt :: !(Int) -- ^ /Required/ "started_at" - The Unix timestamp (in seconds) for when the run was started.
  , runObjectCancelledAt :: !(Int) -- ^ /Required/ "cancelled_at" - The Unix timestamp (in seconds) for when the run was cancelled.
  , runObjectFailedAt :: !(Int) -- ^ /Required/ "failed_at" - The Unix timestamp (in seconds) for when the run failed.
  , runObjectCompletedAt :: !(Int) -- ^ /Required/ "completed_at" - The Unix timestamp (in seconds) for when the run was completed.
  , runObjectModel :: !(Text) -- ^ /Required/ "model" - The model that the [assistant](/docs/api-reference/assistants) used for this run.
  , runObjectInstructions :: !(Text) -- ^ /Required/ "instructions" - The instructions that the [assistant](/docs/api-reference/assistants) used for this run.
  , runObjectTools :: !([AssistantObjectToolsInner]) -- ^ /Required/ "tools" - The list of tools that the [assistant](/docs/api-reference/assistants) used for this run.
  , runObjectFileIds :: !([Text]) -- ^ /Required/ "file_ids" - The list of [File](/docs/api-reference/files) IDs the [assistant](/docs/api-reference/assistants) used for this run.
  , runObjectMetadata :: !(A.Value) -- ^ /Required/ "metadata" - Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long. 
  , runObjectUsage :: !(RunCompletionUsage) -- ^ /Required/ "usage"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON RunObject
instance A.FromJSON RunObject where
  parseJSON = A.withObject "RunObject" $ \o ->
    RunObject
      <$> (o .:  "id")
      <*> (o .:  "object")
      <*> (o .:  "created_at")
      <*> (o .:  "thread_id")
      <*> (o .:  "assistant_id")
      <*> (o .:  "status")
      <*> (o .:  "required_action")
      <*> (o .:  "last_error")
      <*> (o .:  "expires_at")
      <*> (o .:  "started_at")
      <*> (o .:  "cancelled_at")
      <*> (o .:  "failed_at")
      <*> (o .:  "completed_at")
      <*> (o .:  "model")
      <*> (o .:  "instructions")
      <*> (o .:  "tools")
      <*> (o .:  "file_ids")
      <*> (o .:  "metadata")
      <*> (o .:  "usage")

-- | ToJSON RunObject
instance A.ToJSON RunObject where
  toJSON RunObject {..} =
   _omitNulls
      [ "id" .= runObjectId
      , "object" .= runObjectObject
      , "created_at" .= runObjectCreatedAt
      , "thread_id" .= runObjectThreadId
      , "assistant_id" .= runObjectAssistantId
      , "status" .= runObjectStatus
      , "required_action" .= runObjectRequiredAction
      , "last_error" .= runObjectLastError
      , "expires_at" .= runObjectExpiresAt
      , "started_at" .= runObjectStartedAt
      , "cancelled_at" .= runObjectCancelledAt
      , "failed_at" .= runObjectFailedAt
      , "completed_at" .= runObjectCompletedAt
      , "model" .= runObjectModel
      , "instructions" .= runObjectInstructions
      , "tools" .= runObjectTools
      , "file_ids" .= runObjectFileIds
      , "metadata" .= runObjectMetadata
      , "usage" .= runObjectUsage
      ]


-- | Construct a value of type 'RunObject' (by applying it's required fields, if any)
mkRunObject
  :: Text -- ^ 'runObjectId': The identifier, which can be referenced in API endpoints.
  -> E'Object11 -- ^ 'runObjectObject': The object type, which is always `thread.run`.
  -> Int -- ^ 'runObjectCreatedAt': The Unix timestamp (in seconds) for when the run was created.
  -> Text -- ^ 'runObjectThreadId': The ID of the [thread](/docs/api-reference/threads) that was executed on as a part of this run.
  -> Text -- ^ 'runObjectAssistantId': The ID of the [assistant](/docs/api-reference/assistants) used for execution of this run.
  -> E'Status3 -- ^ 'runObjectStatus': The status of the run, which can be either `queued`, `in_progress`, `requires_action`, `cancelling`, `cancelled`, `failed`, `completed`, or `expired`.
  -> RunObjectRequiredAction -- ^ 'runObjectRequiredAction' 
  -> RunObjectLastError -- ^ 'runObjectLastError' 
  -> Int -- ^ 'runObjectExpiresAt': The Unix timestamp (in seconds) for when the run will expire.
  -> Int -- ^ 'runObjectStartedAt': The Unix timestamp (in seconds) for when the run was started.
  -> Int -- ^ 'runObjectCancelledAt': The Unix timestamp (in seconds) for when the run was cancelled.
  -> Int -- ^ 'runObjectFailedAt': The Unix timestamp (in seconds) for when the run failed.
  -> Int -- ^ 'runObjectCompletedAt': The Unix timestamp (in seconds) for when the run was completed.
  -> Text -- ^ 'runObjectModel': The model that the [assistant](/docs/api-reference/assistants) used for this run.
  -> Text -- ^ 'runObjectInstructions': The instructions that the [assistant](/docs/api-reference/assistants) used for this run.
  -> [AssistantObjectToolsInner] -- ^ 'runObjectTools': The list of tools that the [assistant](/docs/api-reference/assistants) used for this run.
  -> [Text] -- ^ 'runObjectFileIds': The list of [File](/docs/api-reference/files) IDs the [assistant](/docs/api-reference/assistants) used for this run.
  -> A.Value -- ^ 'runObjectMetadata': Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long. 
  -> RunCompletionUsage -- ^ 'runObjectUsage' 
  -> RunObject
mkRunObject runObjectId runObjectObject runObjectCreatedAt runObjectThreadId runObjectAssistantId runObjectStatus runObjectRequiredAction runObjectLastError runObjectExpiresAt runObjectStartedAt runObjectCancelledAt runObjectFailedAt runObjectCompletedAt runObjectModel runObjectInstructions runObjectTools runObjectFileIds runObjectMetadata runObjectUsage =
  RunObject
  { runObjectId
  , runObjectObject
  , runObjectCreatedAt
  , runObjectThreadId
  , runObjectAssistantId
  , runObjectStatus
  , runObjectRequiredAction
  , runObjectLastError
  , runObjectExpiresAt
  , runObjectStartedAt
  , runObjectCancelledAt
  , runObjectFailedAt
  , runObjectCompletedAt
  , runObjectModel
  , runObjectInstructions
  , runObjectTools
  , runObjectFileIds
  , runObjectMetadata
  , runObjectUsage
  }

-- ** RunObjectLastError
-- | RunObjectLastError
-- The last error associated with this run. Will be `null` if there are no errors.
data RunObjectLastError = RunObjectLastError
  { runObjectLastErrorCode :: !(E'Code) -- ^ /Required/ "code" - One of &#x60;server_error&#x60;, &#x60;rate_limit_exceeded&#x60;, or &#x60;invalid_prompt&#x60;.
  , runObjectLastErrorMessage :: !(Text) -- ^ /Required/ "message" - A human-readable description of the error.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON RunObjectLastError
instance A.FromJSON RunObjectLastError where
  parseJSON = A.withObject "RunObjectLastError" $ \o ->
    RunObjectLastError
      <$> (o .:  "code")
      <*> (o .:  "message")

-- | ToJSON RunObjectLastError
instance A.ToJSON RunObjectLastError where
  toJSON RunObjectLastError {..} =
   _omitNulls
      [ "code" .= runObjectLastErrorCode
      , "message" .= runObjectLastErrorMessage
      ]


-- | Construct a value of type 'RunObjectLastError' (by applying it's required fields, if any)
mkRunObjectLastError
  :: E'Code -- ^ 'runObjectLastErrorCode': One of `server_error`, `rate_limit_exceeded`, or `invalid_prompt`.
  -> Text -- ^ 'runObjectLastErrorMessage': A human-readable description of the error.
  -> RunObjectLastError
mkRunObjectLastError runObjectLastErrorCode runObjectLastErrorMessage =
  RunObjectLastError
  { runObjectLastErrorCode
  , runObjectLastErrorMessage
  }

-- ** RunObjectRequiredAction
-- | RunObjectRequiredAction
-- Details on the action required to continue the run. Will be `null` if no action is required.
data RunObjectRequiredAction = RunObjectRequiredAction
  { runObjectRequiredActionType :: !(E'Type14) -- ^ /Required/ "type" - For now, this is always &#x60;submit_tool_outputs&#x60;.
  , runObjectRequiredActionSubmitToolOutputs :: !(RunObjectRequiredActionSubmitToolOutputs) -- ^ /Required/ "submit_tool_outputs"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON RunObjectRequiredAction
instance A.FromJSON RunObjectRequiredAction where
  parseJSON = A.withObject "RunObjectRequiredAction" $ \o ->
    RunObjectRequiredAction
      <$> (o .:  "type")
      <*> (o .:  "submit_tool_outputs")

-- | ToJSON RunObjectRequiredAction
instance A.ToJSON RunObjectRequiredAction where
  toJSON RunObjectRequiredAction {..} =
   _omitNulls
      [ "type" .= runObjectRequiredActionType
      , "submit_tool_outputs" .= runObjectRequiredActionSubmitToolOutputs
      ]


-- | Construct a value of type 'RunObjectRequiredAction' (by applying it's required fields, if any)
mkRunObjectRequiredAction
  :: E'Type14 -- ^ 'runObjectRequiredActionType': For now, this is always `submit_tool_outputs`.
  -> RunObjectRequiredActionSubmitToolOutputs -- ^ 'runObjectRequiredActionSubmitToolOutputs' 
  -> RunObjectRequiredAction
mkRunObjectRequiredAction runObjectRequiredActionType runObjectRequiredActionSubmitToolOutputs =
  RunObjectRequiredAction
  { runObjectRequiredActionType
  , runObjectRequiredActionSubmitToolOutputs
  }

-- ** RunObjectRequiredActionSubmitToolOutputs
-- | RunObjectRequiredActionSubmitToolOutputs
-- Details on the tool outputs needed for this run to continue.
data RunObjectRequiredActionSubmitToolOutputs = RunObjectRequiredActionSubmitToolOutputs
  { runObjectRequiredActionSubmitToolOutputsToolCalls :: !([RunToolCallObject]) -- ^ /Required/ "tool_calls" - A list of the relevant tool calls.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON RunObjectRequiredActionSubmitToolOutputs
instance A.FromJSON RunObjectRequiredActionSubmitToolOutputs where
  parseJSON = A.withObject "RunObjectRequiredActionSubmitToolOutputs" $ \o ->
    RunObjectRequiredActionSubmitToolOutputs
      <$> (o .:  "tool_calls")

-- | ToJSON RunObjectRequiredActionSubmitToolOutputs
instance A.ToJSON RunObjectRequiredActionSubmitToolOutputs where
  toJSON RunObjectRequiredActionSubmitToolOutputs {..} =
   _omitNulls
      [ "tool_calls" .= runObjectRequiredActionSubmitToolOutputsToolCalls
      ]


-- | Construct a value of type 'RunObjectRequiredActionSubmitToolOutputs' (by applying it's required fields, if any)
mkRunObjectRequiredActionSubmitToolOutputs
  :: [RunToolCallObject] -- ^ 'runObjectRequiredActionSubmitToolOutputsToolCalls': A list of the relevant tool calls.
  -> RunObjectRequiredActionSubmitToolOutputs
mkRunObjectRequiredActionSubmitToolOutputs runObjectRequiredActionSubmitToolOutputsToolCalls =
  RunObjectRequiredActionSubmitToolOutputs
  { runObjectRequiredActionSubmitToolOutputsToolCalls
  }

-- ** RunStepCompletionUsage
-- | RunStepCompletionUsage
-- Usage statistics related to the run step. This value will be `null` while the run step's status is `in_progress`.
data RunStepCompletionUsage = RunStepCompletionUsage
  { runStepCompletionUsageCompletionTokens :: !(Int) -- ^ /Required/ "completion_tokens" - Number of completion tokens used over the course of the run step.
  , runStepCompletionUsagePromptTokens :: !(Int) -- ^ /Required/ "prompt_tokens" - Number of prompt tokens used over the course of the run step.
  , runStepCompletionUsageTotalTokens :: !(Int) -- ^ /Required/ "total_tokens" - Total number of tokens used (prompt + completion).
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON RunStepCompletionUsage
instance A.FromJSON RunStepCompletionUsage where
  parseJSON = A.withObject "RunStepCompletionUsage" $ \o ->
    RunStepCompletionUsage
      <$> (o .:  "completion_tokens")
      <*> (o .:  "prompt_tokens")
      <*> (o .:  "total_tokens")

-- | ToJSON RunStepCompletionUsage
instance A.ToJSON RunStepCompletionUsage where
  toJSON RunStepCompletionUsage {..} =
   _omitNulls
      [ "completion_tokens" .= runStepCompletionUsageCompletionTokens
      , "prompt_tokens" .= runStepCompletionUsagePromptTokens
      , "total_tokens" .= runStepCompletionUsageTotalTokens
      ]


-- | Construct a value of type 'RunStepCompletionUsage' (by applying it's required fields, if any)
mkRunStepCompletionUsage
  :: Int -- ^ 'runStepCompletionUsageCompletionTokens': Number of completion tokens used over the course of the run step.
  -> Int -- ^ 'runStepCompletionUsagePromptTokens': Number of prompt tokens used over the course of the run step.
  -> Int -- ^ 'runStepCompletionUsageTotalTokens': Total number of tokens used (prompt + completion).
  -> RunStepCompletionUsage
mkRunStepCompletionUsage runStepCompletionUsageCompletionTokens runStepCompletionUsagePromptTokens runStepCompletionUsageTotalTokens =
  RunStepCompletionUsage
  { runStepCompletionUsageCompletionTokens
  , runStepCompletionUsagePromptTokens
  , runStepCompletionUsageTotalTokens
  }

-- ** RunStepDetailsMessageCreationObject
-- | RunStepDetailsMessageCreationObject
-- Message creation
-- 
-- Details of the message creation by the run step.
data RunStepDetailsMessageCreationObject = RunStepDetailsMessageCreationObject
  { runStepDetailsMessageCreationObjectType :: !(E'Type9) -- ^ /Required/ "type" - Always &#x60;message_creation&#x60;.
  , runStepDetailsMessageCreationObjectMessageCreation :: !(RunStepDetailsMessageCreationObjectMessageCreation) -- ^ /Required/ "message_creation"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON RunStepDetailsMessageCreationObject
instance A.FromJSON RunStepDetailsMessageCreationObject where
  parseJSON = A.withObject "RunStepDetailsMessageCreationObject" $ \o ->
    RunStepDetailsMessageCreationObject
      <$> (o .:  "type")
      <*> (o .:  "message_creation")

-- | ToJSON RunStepDetailsMessageCreationObject
instance A.ToJSON RunStepDetailsMessageCreationObject where
  toJSON RunStepDetailsMessageCreationObject {..} =
   _omitNulls
      [ "type" .= runStepDetailsMessageCreationObjectType
      , "message_creation" .= runStepDetailsMessageCreationObjectMessageCreation
      ]


-- | Construct a value of type 'RunStepDetailsMessageCreationObject' (by applying it's required fields, if any)
mkRunStepDetailsMessageCreationObject
  :: E'Type9 -- ^ 'runStepDetailsMessageCreationObjectType': Always `message_creation`.
  -> RunStepDetailsMessageCreationObjectMessageCreation -- ^ 'runStepDetailsMessageCreationObjectMessageCreation' 
  -> RunStepDetailsMessageCreationObject
mkRunStepDetailsMessageCreationObject runStepDetailsMessageCreationObjectType runStepDetailsMessageCreationObjectMessageCreation =
  RunStepDetailsMessageCreationObject
  { runStepDetailsMessageCreationObjectType
  , runStepDetailsMessageCreationObjectMessageCreation
  }

-- ** RunStepDetailsMessageCreationObjectMessageCreation
-- | RunStepDetailsMessageCreationObjectMessageCreation
data RunStepDetailsMessageCreationObjectMessageCreation = RunStepDetailsMessageCreationObjectMessageCreation
  { runStepDetailsMessageCreationObjectMessageCreationMessageId :: !(Text) -- ^ /Required/ "message_id" - The ID of the message that was created by this run step.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON RunStepDetailsMessageCreationObjectMessageCreation
instance A.FromJSON RunStepDetailsMessageCreationObjectMessageCreation where
  parseJSON = A.withObject "RunStepDetailsMessageCreationObjectMessageCreation" $ \o ->
    RunStepDetailsMessageCreationObjectMessageCreation
      <$> (o .:  "message_id")

-- | ToJSON RunStepDetailsMessageCreationObjectMessageCreation
instance A.ToJSON RunStepDetailsMessageCreationObjectMessageCreation where
  toJSON RunStepDetailsMessageCreationObjectMessageCreation {..} =
   _omitNulls
      [ "message_id" .= runStepDetailsMessageCreationObjectMessageCreationMessageId
      ]


-- | Construct a value of type 'RunStepDetailsMessageCreationObjectMessageCreation' (by applying it's required fields, if any)
mkRunStepDetailsMessageCreationObjectMessageCreation
  :: Text -- ^ 'runStepDetailsMessageCreationObjectMessageCreationMessageId': The ID of the message that was created by this run step.
  -> RunStepDetailsMessageCreationObjectMessageCreation
mkRunStepDetailsMessageCreationObjectMessageCreation runStepDetailsMessageCreationObjectMessageCreationMessageId =
  RunStepDetailsMessageCreationObjectMessageCreation
  { runStepDetailsMessageCreationObjectMessageCreationMessageId
  }

-- ** RunStepDetailsToolCallsCodeObject
-- | RunStepDetailsToolCallsCodeObject
-- Code interpreter tool call
-- 
-- Details of the Code Interpreter tool call the run step was involved in.
data RunStepDetailsToolCallsCodeObject = RunStepDetailsToolCallsCodeObject
  { runStepDetailsToolCallsCodeObjectId :: !(Text) -- ^ /Required/ "id" - The ID of the tool call.
  , runStepDetailsToolCallsCodeObjectType :: !(E'Type3) -- ^ /Required/ "type" - The type of tool call. This is always going to be &#x60;code_interpreter&#x60; for this type of tool call.
  , runStepDetailsToolCallsCodeObjectCodeInterpreter :: !(RunStepDetailsToolCallsCodeObjectCodeInterpreter) -- ^ /Required/ "code_interpreter"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON RunStepDetailsToolCallsCodeObject
instance A.FromJSON RunStepDetailsToolCallsCodeObject where
  parseJSON = A.withObject "RunStepDetailsToolCallsCodeObject" $ \o ->
    RunStepDetailsToolCallsCodeObject
      <$> (o .:  "id")
      <*> (o .:  "type")
      <*> (o .:  "code_interpreter")

-- | ToJSON RunStepDetailsToolCallsCodeObject
instance A.ToJSON RunStepDetailsToolCallsCodeObject where
  toJSON RunStepDetailsToolCallsCodeObject {..} =
   _omitNulls
      [ "id" .= runStepDetailsToolCallsCodeObjectId
      , "type" .= runStepDetailsToolCallsCodeObjectType
      , "code_interpreter" .= runStepDetailsToolCallsCodeObjectCodeInterpreter
      ]


-- | Construct a value of type 'RunStepDetailsToolCallsCodeObject' (by applying it's required fields, if any)
mkRunStepDetailsToolCallsCodeObject
  :: Text -- ^ 'runStepDetailsToolCallsCodeObjectId': The ID of the tool call.
  -> E'Type3 -- ^ 'runStepDetailsToolCallsCodeObjectType': The type of tool call. This is always going to be `code_interpreter` for this type of tool call.
  -> RunStepDetailsToolCallsCodeObjectCodeInterpreter -- ^ 'runStepDetailsToolCallsCodeObjectCodeInterpreter' 
  -> RunStepDetailsToolCallsCodeObject
mkRunStepDetailsToolCallsCodeObject runStepDetailsToolCallsCodeObjectId runStepDetailsToolCallsCodeObjectType runStepDetailsToolCallsCodeObjectCodeInterpreter =
  RunStepDetailsToolCallsCodeObject
  { runStepDetailsToolCallsCodeObjectId
  , runStepDetailsToolCallsCodeObjectType
  , runStepDetailsToolCallsCodeObjectCodeInterpreter
  }

-- ** RunStepDetailsToolCallsCodeObjectCodeInterpreter
-- | RunStepDetailsToolCallsCodeObjectCodeInterpreter
-- The Code Interpreter tool call definition.
data RunStepDetailsToolCallsCodeObjectCodeInterpreter = RunStepDetailsToolCallsCodeObjectCodeInterpreter
  { runStepDetailsToolCallsCodeObjectCodeInterpreterInput :: !(Text) -- ^ /Required/ "input" - The input to the Code Interpreter tool call.
  , runStepDetailsToolCallsCodeObjectCodeInterpreterOutputs :: !([RunStepDetailsToolCallsCodeObjectCodeInterpreterOutputsInner]) -- ^ /Required/ "outputs" - The outputs from the Code Interpreter tool call. Code Interpreter can output one or more items, including text (&#x60;logs&#x60;) or images (&#x60;image&#x60;). Each of these are represented by a different object type.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON RunStepDetailsToolCallsCodeObjectCodeInterpreter
instance A.FromJSON RunStepDetailsToolCallsCodeObjectCodeInterpreter where
  parseJSON = A.withObject "RunStepDetailsToolCallsCodeObjectCodeInterpreter" $ \o ->
    RunStepDetailsToolCallsCodeObjectCodeInterpreter
      <$> (o .:  "input")
      <*> (o .:  "outputs")

-- | ToJSON RunStepDetailsToolCallsCodeObjectCodeInterpreter
instance A.ToJSON RunStepDetailsToolCallsCodeObjectCodeInterpreter where
  toJSON RunStepDetailsToolCallsCodeObjectCodeInterpreter {..} =
   _omitNulls
      [ "input" .= runStepDetailsToolCallsCodeObjectCodeInterpreterInput
      , "outputs" .= runStepDetailsToolCallsCodeObjectCodeInterpreterOutputs
      ]


-- | Construct a value of type 'RunStepDetailsToolCallsCodeObjectCodeInterpreter' (by applying it's required fields, if any)
mkRunStepDetailsToolCallsCodeObjectCodeInterpreter
  :: Text -- ^ 'runStepDetailsToolCallsCodeObjectCodeInterpreterInput': The input to the Code Interpreter tool call.
  -> [RunStepDetailsToolCallsCodeObjectCodeInterpreterOutputsInner] -- ^ 'runStepDetailsToolCallsCodeObjectCodeInterpreterOutputs': The outputs from the Code Interpreter tool call. Code Interpreter can output one or more items, including text (`logs`) or images (`image`). Each of these are represented by a different object type.
  -> RunStepDetailsToolCallsCodeObjectCodeInterpreter
mkRunStepDetailsToolCallsCodeObjectCodeInterpreter runStepDetailsToolCallsCodeObjectCodeInterpreterInput runStepDetailsToolCallsCodeObjectCodeInterpreterOutputs =
  RunStepDetailsToolCallsCodeObjectCodeInterpreter
  { runStepDetailsToolCallsCodeObjectCodeInterpreterInput
  , runStepDetailsToolCallsCodeObjectCodeInterpreterOutputs
  }

-- ** RunStepDetailsToolCallsCodeObjectCodeInterpreterOutputsInner
-- | RunStepDetailsToolCallsCodeObjectCodeInterpreterOutputsInner
data RunStepDetailsToolCallsCodeObjectCodeInterpreterOutputsInner = RunStepDetailsToolCallsCodeObjectCodeInterpreterOutputsInner
  { runStepDetailsToolCallsCodeObjectCodeInterpreterOutputsInnerType :: !(E'Type12) -- ^ /Required/ "type" - Always &#x60;image&#x60;.
  , runStepDetailsToolCallsCodeObjectCodeInterpreterOutputsInnerLogs :: !(Text) -- ^ /Required/ "logs" - The text output from the Code Interpreter tool call.
  , runStepDetailsToolCallsCodeObjectCodeInterpreterOutputsInnerImage :: !(RunStepDetailsToolCallsCodeOutputImageObjectImage) -- ^ /Required/ "image"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON RunStepDetailsToolCallsCodeObjectCodeInterpreterOutputsInner
instance A.FromJSON RunStepDetailsToolCallsCodeObjectCodeInterpreterOutputsInner where
  parseJSON = A.withObject "RunStepDetailsToolCallsCodeObjectCodeInterpreterOutputsInner" $ \o ->
    RunStepDetailsToolCallsCodeObjectCodeInterpreterOutputsInner
      <$> (o .:  "type")
      <*> (o .:  "logs")
      <*> (o .:  "image")

-- | ToJSON RunStepDetailsToolCallsCodeObjectCodeInterpreterOutputsInner
instance A.ToJSON RunStepDetailsToolCallsCodeObjectCodeInterpreterOutputsInner where
  toJSON RunStepDetailsToolCallsCodeObjectCodeInterpreterOutputsInner {..} =
   _omitNulls
      [ "type" .= runStepDetailsToolCallsCodeObjectCodeInterpreterOutputsInnerType
      , "logs" .= runStepDetailsToolCallsCodeObjectCodeInterpreterOutputsInnerLogs
      , "image" .= runStepDetailsToolCallsCodeObjectCodeInterpreterOutputsInnerImage
      ]


-- | Construct a value of type 'RunStepDetailsToolCallsCodeObjectCodeInterpreterOutputsInner' (by applying it's required fields, if any)
mkRunStepDetailsToolCallsCodeObjectCodeInterpreterOutputsInner
  :: E'Type12 -- ^ 'runStepDetailsToolCallsCodeObjectCodeInterpreterOutputsInnerType': Always `image`.
  -> Text -- ^ 'runStepDetailsToolCallsCodeObjectCodeInterpreterOutputsInnerLogs': The text output from the Code Interpreter tool call.
  -> RunStepDetailsToolCallsCodeOutputImageObjectImage -- ^ 'runStepDetailsToolCallsCodeObjectCodeInterpreterOutputsInnerImage' 
  -> RunStepDetailsToolCallsCodeObjectCodeInterpreterOutputsInner
mkRunStepDetailsToolCallsCodeObjectCodeInterpreterOutputsInner runStepDetailsToolCallsCodeObjectCodeInterpreterOutputsInnerType runStepDetailsToolCallsCodeObjectCodeInterpreterOutputsInnerLogs runStepDetailsToolCallsCodeObjectCodeInterpreterOutputsInnerImage =
  RunStepDetailsToolCallsCodeObjectCodeInterpreterOutputsInner
  { runStepDetailsToolCallsCodeObjectCodeInterpreterOutputsInnerType
  , runStepDetailsToolCallsCodeObjectCodeInterpreterOutputsInnerLogs
  , runStepDetailsToolCallsCodeObjectCodeInterpreterOutputsInnerImage
  }

-- ** RunStepDetailsToolCallsCodeOutputImageObject
-- | RunStepDetailsToolCallsCodeOutputImageObject
-- Code interpreter image output
-- 
data RunStepDetailsToolCallsCodeOutputImageObject = RunStepDetailsToolCallsCodeOutputImageObject
  { runStepDetailsToolCallsCodeOutputImageObjectType :: !(E'Type12) -- ^ /Required/ "type" - Always &#x60;image&#x60;.
  , runStepDetailsToolCallsCodeOutputImageObjectImage :: !(RunStepDetailsToolCallsCodeOutputImageObjectImage) -- ^ /Required/ "image"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON RunStepDetailsToolCallsCodeOutputImageObject
instance A.FromJSON RunStepDetailsToolCallsCodeOutputImageObject where
  parseJSON = A.withObject "RunStepDetailsToolCallsCodeOutputImageObject" $ \o ->
    RunStepDetailsToolCallsCodeOutputImageObject
      <$> (o .:  "type")
      <*> (o .:  "image")

-- | ToJSON RunStepDetailsToolCallsCodeOutputImageObject
instance A.ToJSON RunStepDetailsToolCallsCodeOutputImageObject where
  toJSON RunStepDetailsToolCallsCodeOutputImageObject {..} =
   _omitNulls
      [ "type" .= runStepDetailsToolCallsCodeOutputImageObjectType
      , "image" .= runStepDetailsToolCallsCodeOutputImageObjectImage
      ]


-- | Construct a value of type 'RunStepDetailsToolCallsCodeOutputImageObject' (by applying it's required fields, if any)
mkRunStepDetailsToolCallsCodeOutputImageObject
  :: E'Type12 -- ^ 'runStepDetailsToolCallsCodeOutputImageObjectType': Always `image`.
  -> RunStepDetailsToolCallsCodeOutputImageObjectImage -- ^ 'runStepDetailsToolCallsCodeOutputImageObjectImage' 
  -> RunStepDetailsToolCallsCodeOutputImageObject
mkRunStepDetailsToolCallsCodeOutputImageObject runStepDetailsToolCallsCodeOutputImageObjectType runStepDetailsToolCallsCodeOutputImageObjectImage =
  RunStepDetailsToolCallsCodeOutputImageObject
  { runStepDetailsToolCallsCodeOutputImageObjectType
  , runStepDetailsToolCallsCodeOutputImageObjectImage
  }

-- ** RunStepDetailsToolCallsCodeOutputImageObjectImage
-- | RunStepDetailsToolCallsCodeOutputImageObjectImage
data RunStepDetailsToolCallsCodeOutputImageObjectImage = RunStepDetailsToolCallsCodeOutputImageObjectImage
  { runStepDetailsToolCallsCodeOutputImageObjectImageFileId :: !(Text) -- ^ /Required/ "file_id" - The [file](/docs/api-reference/files) ID of the image.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON RunStepDetailsToolCallsCodeOutputImageObjectImage
instance A.FromJSON RunStepDetailsToolCallsCodeOutputImageObjectImage where
  parseJSON = A.withObject "RunStepDetailsToolCallsCodeOutputImageObjectImage" $ \o ->
    RunStepDetailsToolCallsCodeOutputImageObjectImage
      <$> (o .:  "file_id")

-- | ToJSON RunStepDetailsToolCallsCodeOutputImageObjectImage
instance A.ToJSON RunStepDetailsToolCallsCodeOutputImageObjectImage where
  toJSON RunStepDetailsToolCallsCodeOutputImageObjectImage {..} =
   _omitNulls
      [ "file_id" .= runStepDetailsToolCallsCodeOutputImageObjectImageFileId
      ]


-- | Construct a value of type 'RunStepDetailsToolCallsCodeOutputImageObjectImage' (by applying it's required fields, if any)
mkRunStepDetailsToolCallsCodeOutputImageObjectImage
  :: Text -- ^ 'runStepDetailsToolCallsCodeOutputImageObjectImageFileId': The [file](/docs/api-reference/files) ID of the image.
  -> RunStepDetailsToolCallsCodeOutputImageObjectImage
mkRunStepDetailsToolCallsCodeOutputImageObjectImage runStepDetailsToolCallsCodeOutputImageObjectImageFileId =
  RunStepDetailsToolCallsCodeOutputImageObjectImage
  { runStepDetailsToolCallsCodeOutputImageObjectImageFileId
  }

-- ** RunStepDetailsToolCallsCodeOutputLogsObject
-- | RunStepDetailsToolCallsCodeOutputLogsObject
-- Code interpreter log output
-- 
-- Text output from the Code Interpreter tool call as part of a run step.
data RunStepDetailsToolCallsCodeOutputLogsObject = RunStepDetailsToolCallsCodeOutputLogsObject
  { runStepDetailsToolCallsCodeOutputLogsObjectType :: !(E'Type11) -- ^ /Required/ "type" - Always &#x60;logs&#x60;.
  , runStepDetailsToolCallsCodeOutputLogsObjectLogs :: !(Text) -- ^ /Required/ "logs" - The text output from the Code Interpreter tool call.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON RunStepDetailsToolCallsCodeOutputLogsObject
instance A.FromJSON RunStepDetailsToolCallsCodeOutputLogsObject where
  parseJSON = A.withObject "RunStepDetailsToolCallsCodeOutputLogsObject" $ \o ->
    RunStepDetailsToolCallsCodeOutputLogsObject
      <$> (o .:  "type")
      <*> (o .:  "logs")

-- | ToJSON RunStepDetailsToolCallsCodeOutputLogsObject
instance A.ToJSON RunStepDetailsToolCallsCodeOutputLogsObject where
  toJSON RunStepDetailsToolCallsCodeOutputLogsObject {..} =
   _omitNulls
      [ "type" .= runStepDetailsToolCallsCodeOutputLogsObjectType
      , "logs" .= runStepDetailsToolCallsCodeOutputLogsObjectLogs
      ]


-- | Construct a value of type 'RunStepDetailsToolCallsCodeOutputLogsObject' (by applying it's required fields, if any)
mkRunStepDetailsToolCallsCodeOutputLogsObject
  :: E'Type11 -- ^ 'runStepDetailsToolCallsCodeOutputLogsObjectType': Always `logs`.
  -> Text -- ^ 'runStepDetailsToolCallsCodeOutputLogsObjectLogs': The text output from the Code Interpreter tool call.
  -> RunStepDetailsToolCallsCodeOutputLogsObject
mkRunStepDetailsToolCallsCodeOutputLogsObject runStepDetailsToolCallsCodeOutputLogsObjectType runStepDetailsToolCallsCodeOutputLogsObjectLogs =
  RunStepDetailsToolCallsCodeOutputLogsObject
  { runStepDetailsToolCallsCodeOutputLogsObjectType
  , runStepDetailsToolCallsCodeOutputLogsObjectLogs
  }

-- ** RunStepDetailsToolCallsFunctionObject
-- | RunStepDetailsToolCallsFunctionObject
-- Function tool call
-- 
data RunStepDetailsToolCallsFunctionObject = RunStepDetailsToolCallsFunctionObject
  { runStepDetailsToolCallsFunctionObjectId :: !(Text) -- ^ /Required/ "id" - The ID of the tool call object.
  , runStepDetailsToolCallsFunctionObjectType :: !(E'Role) -- ^ /Required/ "type" - The type of tool call. This is always going to be &#x60;function&#x60; for this type of tool call.
  , runStepDetailsToolCallsFunctionObjectFunction :: !(RunStepDetailsToolCallsFunctionObjectFunction) -- ^ /Required/ "function"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON RunStepDetailsToolCallsFunctionObject
instance A.FromJSON RunStepDetailsToolCallsFunctionObject where
  parseJSON = A.withObject "RunStepDetailsToolCallsFunctionObject" $ \o ->
    RunStepDetailsToolCallsFunctionObject
      <$> (o .:  "id")
      <*> (o .:  "type")
      <*> (o .:  "function")

-- | ToJSON RunStepDetailsToolCallsFunctionObject
instance A.ToJSON RunStepDetailsToolCallsFunctionObject where
  toJSON RunStepDetailsToolCallsFunctionObject {..} =
   _omitNulls
      [ "id" .= runStepDetailsToolCallsFunctionObjectId
      , "type" .= runStepDetailsToolCallsFunctionObjectType
      , "function" .= runStepDetailsToolCallsFunctionObjectFunction
      ]


-- | Construct a value of type 'RunStepDetailsToolCallsFunctionObject' (by applying it's required fields, if any)
mkRunStepDetailsToolCallsFunctionObject
  :: Text -- ^ 'runStepDetailsToolCallsFunctionObjectId': The ID of the tool call object.
  -> E'Role -- ^ 'runStepDetailsToolCallsFunctionObjectType': The type of tool call. This is always going to be `function` for this type of tool call.
  -> RunStepDetailsToolCallsFunctionObjectFunction -- ^ 'runStepDetailsToolCallsFunctionObjectFunction' 
  -> RunStepDetailsToolCallsFunctionObject
mkRunStepDetailsToolCallsFunctionObject runStepDetailsToolCallsFunctionObjectId runStepDetailsToolCallsFunctionObjectType runStepDetailsToolCallsFunctionObjectFunction =
  RunStepDetailsToolCallsFunctionObject
  { runStepDetailsToolCallsFunctionObjectId
  , runStepDetailsToolCallsFunctionObjectType
  , runStepDetailsToolCallsFunctionObjectFunction
  }

-- ** RunStepDetailsToolCallsFunctionObjectFunction
-- | RunStepDetailsToolCallsFunctionObjectFunction
-- The definition of the function that was called.
data RunStepDetailsToolCallsFunctionObjectFunction = RunStepDetailsToolCallsFunctionObjectFunction
  { runStepDetailsToolCallsFunctionObjectFunctionName :: !(Text) -- ^ /Required/ "name" - The name of the function.
  , runStepDetailsToolCallsFunctionObjectFunctionArguments :: !(Text) -- ^ /Required/ "arguments" - The arguments passed to the function.
  , runStepDetailsToolCallsFunctionObjectFunctionOutput :: !(Text) -- ^ /Required/ "output" - The output of the function. This will be &#x60;null&#x60; if the outputs have not been [submitted](/docs/api-reference/runs/submitToolOutputs) yet.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON RunStepDetailsToolCallsFunctionObjectFunction
instance A.FromJSON RunStepDetailsToolCallsFunctionObjectFunction where
  parseJSON = A.withObject "RunStepDetailsToolCallsFunctionObjectFunction" $ \o ->
    RunStepDetailsToolCallsFunctionObjectFunction
      <$> (o .:  "name")
      <*> (o .:  "arguments")
      <*> (o .:  "output")

-- | ToJSON RunStepDetailsToolCallsFunctionObjectFunction
instance A.ToJSON RunStepDetailsToolCallsFunctionObjectFunction where
  toJSON RunStepDetailsToolCallsFunctionObjectFunction {..} =
   _omitNulls
      [ "name" .= runStepDetailsToolCallsFunctionObjectFunctionName
      , "arguments" .= runStepDetailsToolCallsFunctionObjectFunctionArguments
      , "output" .= runStepDetailsToolCallsFunctionObjectFunctionOutput
      ]


-- | Construct a value of type 'RunStepDetailsToolCallsFunctionObjectFunction' (by applying it's required fields, if any)
mkRunStepDetailsToolCallsFunctionObjectFunction
  :: Text -- ^ 'runStepDetailsToolCallsFunctionObjectFunctionName': The name of the function.
  -> Text -- ^ 'runStepDetailsToolCallsFunctionObjectFunctionArguments': The arguments passed to the function.
  -> Text -- ^ 'runStepDetailsToolCallsFunctionObjectFunctionOutput': The output of the function. This will be `null` if the outputs have not been [submitted](/docs/api-reference/runs/submitToolOutputs) yet.
  -> RunStepDetailsToolCallsFunctionObjectFunction
mkRunStepDetailsToolCallsFunctionObjectFunction runStepDetailsToolCallsFunctionObjectFunctionName runStepDetailsToolCallsFunctionObjectFunctionArguments runStepDetailsToolCallsFunctionObjectFunctionOutput =
  RunStepDetailsToolCallsFunctionObjectFunction
  { runStepDetailsToolCallsFunctionObjectFunctionName
  , runStepDetailsToolCallsFunctionObjectFunctionArguments
  , runStepDetailsToolCallsFunctionObjectFunctionOutput
  }

-- ** RunStepDetailsToolCallsObject
-- | RunStepDetailsToolCallsObject
-- Tool calls
-- 
-- Details of the tool call.
data RunStepDetailsToolCallsObject = RunStepDetailsToolCallsObject
  { runStepDetailsToolCallsObjectType :: !(E'Type10) -- ^ /Required/ "type" - Always &#x60;tool_calls&#x60;.
  , runStepDetailsToolCallsObjectToolCalls :: !([RunStepDetailsToolCallsObjectToolCallsInner]) -- ^ /Required/ "tool_calls" - An array of tool calls the run step was involved in. These can be associated with one of three types of tools: &#x60;code_interpreter&#x60;, &#x60;retrieval&#x60;, or &#x60;function&#x60;. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON RunStepDetailsToolCallsObject
instance A.FromJSON RunStepDetailsToolCallsObject where
  parseJSON = A.withObject "RunStepDetailsToolCallsObject" $ \o ->
    RunStepDetailsToolCallsObject
      <$> (o .:  "type")
      <*> (o .:  "tool_calls")

-- | ToJSON RunStepDetailsToolCallsObject
instance A.ToJSON RunStepDetailsToolCallsObject where
  toJSON RunStepDetailsToolCallsObject {..} =
   _omitNulls
      [ "type" .= runStepDetailsToolCallsObjectType
      , "tool_calls" .= runStepDetailsToolCallsObjectToolCalls
      ]


-- | Construct a value of type 'RunStepDetailsToolCallsObject' (by applying it's required fields, if any)
mkRunStepDetailsToolCallsObject
  :: E'Type10 -- ^ 'runStepDetailsToolCallsObjectType': Always `tool_calls`.
  -> [RunStepDetailsToolCallsObjectToolCallsInner] -- ^ 'runStepDetailsToolCallsObjectToolCalls': An array of tool calls the run step was involved in. These can be associated with one of three types of tools: `code_interpreter`, `retrieval`, or `function`. 
  -> RunStepDetailsToolCallsObject
mkRunStepDetailsToolCallsObject runStepDetailsToolCallsObjectType runStepDetailsToolCallsObjectToolCalls =
  RunStepDetailsToolCallsObject
  { runStepDetailsToolCallsObjectType
  , runStepDetailsToolCallsObjectToolCalls
  }

-- ** RunStepDetailsToolCallsObjectToolCallsInner
-- | RunStepDetailsToolCallsObjectToolCallsInner
data RunStepDetailsToolCallsObjectToolCallsInner = RunStepDetailsToolCallsObjectToolCallsInner
  { runStepDetailsToolCallsObjectToolCallsInnerId :: !(Text) -- ^ /Required/ "id" - The ID of the tool call object.
  , runStepDetailsToolCallsObjectToolCallsInnerType :: !(E'Role) -- ^ /Required/ "type" - The type of tool call. This is always going to be &#x60;function&#x60; for this type of tool call.
  , runStepDetailsToolCallsObjectToolCallsInnerCodeInterpreter :: !(RunStepDetailsToolCallsCodeObjectCodeInterpreter) -- ^ /Required/ "code_interpreter"
  , runStepDetailsToolCallsObjectToolCallsInnerRetrieval :: !(A.Value) -- ^ /Required/ "retrieval" - For now, this is always going to be an empty object.
  , runStepDetailsToolCallsObjectToolCallsInnerFunction :: !(RunStepDetailsToolCallsFunctionObjectFunction) -- ^ /Required/ "function"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON RunStepDetailsToolCallsObjectToolCallsInner
instance A.FromJSON RunStepDetailsToolCallsObjectToolCallsInner where
  parseJSON = A.withObject "RunStepDetailsToolCallsObjectToolCallsInner" $ \o ->
    RunStepDetailsToolCallsObjectToolCallsInner
      <$> (o .:  "id")
      <*> (o .:  "type")
      <*> (o .:  "code_interpreter")
      <*> (o .:  "retrieval")
      <*> (o .:  "function")

-- | ToJSON RunStepDetailsToolCallsObjectToolCallsInner
instance A.ToJSON RunStepDetailsToolCallsObjectToolCallsInner where
  toJSON RunStepDetailsToolCallsObjectToolCallsInner {..} =
   _omitNulls
      [ "id" .= runStepDetailsToolCallsObjectToolCallsInnerId
      , "type" .= runStepDetailsToolCallsObjectToolCallsInnerType
      , "code_interpreter" .= runStepDetailsToolCallsObjectToolCallsInnerCodeInterpreter
      , "retrieval" .= runStepDetailsToolCallsObjectToolCallsInnerRetrieval
      , "function" .= runStepDetailsToolCallsObjectToolCallsInnerFunction
      ]


-- | Construct a value of type 'RunStepDetailsToolCallsObjectToolCallsInner' (by applying it's required fields, if any)
mkRunStepDetailsToolCallsObjectToolCallsInner
  :: Text -- ^ 'runStepDetailsToolCallsObjectToolCallsInnerId': The ID of the tool call object.
  -> E'Role -- ^ 'runStepDetailsToolCallsObjectToolCallsInnerType': The type of tool call. This is always going to be `function` for this type of tool call.
  -> RunStepDetailsToolCallsCodeObjectCodeInterpreter -- ^ 'runStepDetailsToolCallsObjectToolCallsInnerCodeInterpreter' 
  -> A.Value -- ^ 'runStepDetailsToolCallsObjectToolCallsInnerRetrieval': For now, this is always going to be an empty object.
  -> RunStepDetailsToolCallsFunctionObjectFunction -- ^ 'runStepDetailsToolCallsObjectToolCallsInnerFunction' 
  -> RunStepDetailsToolCallsObjectToolCallsInner
mkRunStepDetailsToolCallsObjectToolCallsInner runStepDetailsToolCallsObjectToolCallsInnerId runStepDetailsToolCallsObjectToolCallsInnerType runStepDetailsToolCallsObjectToolCallsInnerCodeInterpreter runStepDetailsToolCallsObjectToolCallsInnerRetrieval runStepDetailsToolCallsObjectToolCallsInnerFunction =
  RunStepDetailsToolCallsObjectToolCallsInner
  { runStepDetailsToolCallsObjectToolCallsInnerId
  , runStepDetailsToolCallsObjectToolCallsInnerType
  , runStepDetailsToolCallsObjectToolCallsInnerCodeInterpreter
  , runStepDetailsToolCallsObjectToolCallsInnerRetrieval
  , runStepDetailsToolCallsObjectToolCallsInnerFunction
  }

-- ** RunStepDetailsToolCallsRetrievalObject
-- | RunStepDetailsToolCallsRetrievalObject
-- Retrieval tool call
-- 
data RunStepDetailsToolCallsRetrievalObject = RunStepDetailsToolCallsRetrievalObject
  { runStepDetailsToolCallsRetrievalObjectId :: !(Text) -- ^ /Required/ "id" - The ID of the tool call object.
  , runStepDetailsToolCallsRetrievalObjectType :: !(E'Type4) -- ^ /Required/ "type" - The type of tool call. This is always going to be &#x60;retrieval&#x60; for this type of tool call.
  , runStepDetailsToolCallsRetrievalObjectRetrieval :: !(A.Value) -- ^ /Required/ "retrieval" - For now, this is always going to be an empty object.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON RunStepDetailsToolCallsRetrievalObject
instance A.FromJSON RunStepDetailsToolCallsRetrievalObject where
  parseJSON = A.withObject "RunStepDetailsToolCallsRetrievalObject" $ \o ->
    RunStepDetailsToolCallsRetrievalObject
      <$> (o .:  "id")
      <*> (o .:  "type")
      <*> (o .:  "retrieval")

-- | ToJSON RunStepDetailsToolCallsRetrievalObject
instance A.ToJSON RunStepDetailsToolCallsRetrievalObject where
  toJSON RunStepDetailsToolCallsRetrievalObject {..} =
   _omitNulls
      [ "id" .= runStepDetailsToolCallsRetrievalObjectId
      , "type" .= runStepDetailsToolCallsRetrievalObjectType
      , "retrieval" .= runStepDetailsToolCallsRetrievalObjectRetrieval
      ]


-- | Construct a value of type 'RunStepDetailsToolCallsRetrievalObject' (by applying it's required fields, if any)
mkRunStepDetailsToolCallsRetrievalObject
  :: Text -- ^ 'runStepDetailsToolCallsRetrievalObjectId': The ID of the tool call object.
  -> E'Type4 -- ^ 'runStepDetailsToolCallsRetrievalObjectType': The type of tool call. This is always going to be `retrieval` for this type of tool call.
  -> A.Value -- ^ 'runStepDetailsToolCallsRetrievalObjectRetrieval': For now, this is always going to be an empty object.
  -> RunStepDetailsToolCallsRetrievalObject
mkRunStepDetailsToolCallsRetrievalObject runStepDetailsToolCallsRetrievalObjectId runStepDetailsToolCallsRetrievalObjectType runStepDetailsToolCallsRetrievalObjectRetrieval =
  RunStepDetailsToolCallsRetrievalObject
  { runStepDetailsToolCallsRetrievalObjectId
  , runStepDetailsToolCallsRetrievalObjectType
  , runStepDetailsToolCallsRetrievalObjectRetrieval
  }

-- ** RunStepObject
-- | RunStepObject
-- Run steps
-- 
-- Represents a step in execution of a run. 
data RunStepObject = RunStepObject
  { runStepObjectId :: !(Text) -- ^ /Required/ "id" - The identifier of the run step, which can be referenced in API endpoints.
  , runStepObjectObject :: !(E'Object16) -- ^ /Required/ "object" - The object type, which is always &#x60;thread.run.step&#x60;.
  , runStepObjectCreatedAt :: !(Int) -- ^ /Required/ "created_at" - The Unix timestamp (in seconds) for when the run step was created.
  , runStepObjectAssistantId :: !(Text) -- ^ /Required/ "assistant_id" - The ID of the [assistant](/docs/api-reference/assistants) associated with the run step.
  , runStepObjectThreadId :: !(Text) -- ^ /Required/ "thread_id" - The ID of the [thread](/docs/api-reference/threads) that was run.
  , runStepObjectRunId :: !(Text) -- ^ /Required/ "run_id" - The ID of the [run](/docs/api-reference/runs) that this run step is a part of.
  , runStepObjectType :: !(E'Type8) -- ^ /Required/ "type" - The type of run step, which can be either &#x60;message_creation&#x60; or &#x60;tool_calls&#x60;.
  , runStepObjectStatus :: !(E'Status4) -- ^ /Required/ "status" - The status of the run step, which can be either &#x60;in_progress&#x60;, &#x60;cancelled&#x60;, &#x60;failed&#x60;, &#x60;completed&#x60;, or &#x60;expired&#x60;.
  , runStepObjectStepDetails :: !(RunStepObjectStepDetails) -- ^ /Required/ "step_details"
  , runStepObjectLastError :: !(RunStepObjectLastError) -- ^ /Required/ "last_error"
  , runStepObjectExpiredAt :: !(Int) -- ^ /Required/ "expired_at" - The Unix timestamp (in seconds) for when the run step expired. A step is considered expired if the parent run is expired.
  , runStepObjectCancelledAt :: !(Int) -- ^ /Required/ "cancelled_at" - The Unix timestamp (in seconds) for when the run step was cancelled.
  , runStepObjectFailedAt :: !(Int) -- ^ /Required/ "failed_at" - The Unix timestamp (in seconds) for when the run step failed.
  , runStepObjectCompletedAt :: !(Int) -- ^ /Required/ "completed_at" - The Unix timestamp (in seconds) for when the run step completed.
  , runStepObjectMetadata :: !(A.Value) -- ^ /Required/ "metadata" - Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long. 
  , runStepObjectUsage :: !(RunStepCompletionUsage) -- ^ /Required/ "usage"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON RunStepObject
instance A.FromJSON RunStepObject where
  parseJSON = A.withObject "RunStepObject" $ \o ->
    RunStepObject
      <$> (o .:  "id")
      <*> (o .:  "object")
      <*> (o .:  "created_at")
      <*> (o .:  "assistant_id")
      <*> (o .:  "thread_id")
      <*> (o .:  "run_id")
      <*> (o .:  "type")
      <*> (o .:  "status")
      <*> (o .:  "step_details")
      <*> (o .:  "last_error")
      <*> (o .:  "expired_at")
      <*> (o .:  "cancelled_at")
      <*> (o .:  "failed_at")
      <*> (o .:  "completed_at")
      <*> (o .:  "metadata")
      <*> (o .:  "usage")

-- | ToJSON RunStepObject
instance A.ToJSON RunStepObject where
  toJSON RunStepObject {..} =
   _omitNulls
      [ "id" .= runStepObjectId
      , "object" .= runStepObjectObject
      , "created_at" .= runStepObjectCreatedAt
      , "assistant_id" .= runStepObjectAssistantId
      , "thread_id" .= runStepObjectThreadId
      , "run_id" .= runStepObjectRunId
      , "type" .= runStepObjectType
      , "status" .= runStepObjectStatus
      , "step_details" .= runStepObjectStepDetails
      , "last_error" .= runStepObjectLastError
      , "expired_at" .= runStepObjectExpiredAt
      , "cancelled_at" .= runStepObjectCancelledAt
      , "failed_at" .= runStepObjectFailedAt
      , "completed_at" .= runStepObjectCompletedAt
      , "metadata" .= runStepObjectMetadata
      , "usage" .= runStepObjectUsage
      ]


-- | Construct a value of type 'RunStepObject' (by applying it's required fields, if any)
mkRunStepObject
  :: Text -- ^ 'runStepObjectId': The identifier of the run step, which can be referenced in API endpoints.
  -> E'Object16 -- ^ 'runStepObjectObject': The object type, which is always `thread.run.step`.
  -> Int -- ^ 'runStepObjectCreatedAt': The Unix timestamp (in seconds) for when the run step was created.
  -> Text -- ^ 'runStepObjectAssistantId': The ID of the [assistant](/docs/api-reference/assistants) associated with the run step.
  -> Text -- ^ 'runStepObjectThreadId': The ID of the [thread](/docs/api-reference/threads) that was run.
  -> Text -- ^ 'runStepObjectRunId': The ID of the [run](/docs/api-reference/runs) that this run step is a part of.
  -> E'Type8 -- ^ 'runStepObjectType': The type of run step, which can be either `message_creation` or `tool_calls`.
  -> E'Status4 -- ^ 'runStepObjectStatus': The status of the run step, which can be either `in_progress`, `cancelled`, `failed`, `completed`, or `expired`.
  -> RunStepObjectStepDetails -- ^ 'runStepObjectStepDetails' 
  -> RunStepObjectLastError -- ^ 'runStepObjectLastError' 
  -> Int -- ^ 'runStepObjectExpiredAt': The Unix timestamp (in seconds) for when the run step expired. A step is considered expired if the parent run is expired.
  -> Int -- ^ 'runStepObjectCancelledAt': The Unix timestamp (in seconds) for when the run step was cancelled.
  -> Int -- ^ 'runStepObjectFailedAt': The Unix timestamp (in seconds) for when the run step failed.
  -> Int -- ^ 'runStepObjectCompletedAt': The Unix timestamp (in seconds) for when the run step completed.
  -> A.Value -- ^ 'runStepObjectMetadata': Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long. 
  -> RunStepCompletionUsage -- ^ 'runStepObjectUsage' 
  -> RunStepObject
mkRunStepObject runStepObjectId runStepObjectObject runStepObjectCreatedAt runStepObjectAssistantId runStepObjectThreadId runStepObjectRunId runStepObjectType runStepObjectStatus runStepObjectStepDetails runStepObjectLastError runStepObjectExpiredAt runStepObjectCancelledAt runStepObjectFailedAt runStepObjectCompletedAt runStepObjectMetadata runStepObjectUsage =
  RunStepObject
  { runStepObjectId
  , runStepObjectObject
  , runStepObjectCreatedAt
  , runStepObjectAssistantId
  , runStepObjectThreadId
  , runStepObjectRunId
  , runStepObjectType
  , runStepObjectStatus
  , runStepObjectStepDetails
  , runStepObjectLastError
  , runStepObjectExpiredAt
  , runStepObjectCancelledAt
  , runStepObjectFailedAt
  , runStepObjectCompletedAt
  , runStepObjectMetadata
  , runStepObjectUsage
  }

-- ** RunStepObjectLastError
-- | RunStepObjectLastError
-- The last error associated with this run step. Will be `null` if there are no errors.
data RunStepObjectLastError = RunStepObjectLastError
  { runStepObjectLastErrorCode :: !(E'Code2) -- ^ /Required/ "code" - One of &#x60;server_error&#x60; or &#x60;rate_limit_exceeded&#x60;.
  , runStepObjectLastErrorMessage :: !(Text) -- ^ /Required/ "message" - A human-readable description of the error.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON RunStepObjectLastError
instance A.FromJSON RunStepObjectLastError where
  parseJSON = A.withObject "RunStepObjectLastError" $ \o ->
    RunStepObjectLastError
      <$> (o .:  "code")
      <*> (o .:  "message")

-- | ToJSON RunStepObjectLastError
instance A.ToJSON RunStepObjectLastError where
  toJSON RunStepObjectLastError {..} =
   _omitNulls
      [ "code" .= runStepObjectLastErrorCode
      , "message" .= runStepObjectLastErrorMessage
      ]


-- | Construct a value of type 'RunStepObjectLastError' (by applying it's required fields, if any)
mkRunStepObjectLastError
  :: E'Code2 -- ^ 'runStepObjectLastErrorCode': One of `server_error` or `rate_limit_exceeded`.
  -> Text -- ^ 'runStepObjectLastErrorMessage': A human-readable description of the error.
  -> RunStepObjectLastError
mkRunStepObjectLastError runStepObjectLastErrorCode runStepObjectLastErrorMessage =
  RunStepObjectLastError
  { runStepObjectLastErrorCode
  , runStepObjectLastErrorMessage
  }

-- ** RunStepObjectStepDetails
-- | RunStepObjectStepDetails
-- The details of the run step.
data RunStepObjectStepDetails = RunStepObjectStepDetails
  { runStepObjectStepDetailsType :: !(E'Type10) -- ^ /Required/ "type" - Always &#x60;tool_calls&#x60;.
  , runStepObjectStepDetailsMessageCreation :: !(RunStepDetailsMessageCreationObjectMessageCreation) -- ^ /Required/ "message_creation"
  , runStepObjectStepDetailsToolCalls :: !([RunStepDetailsToolCallsObjectToolCallsInner]) -- ^ /Required/ "tool_calls" - An array of tool calls the run step was involved in. These can be associated with one of three types of tools: &#x60;code_interpreter&#x60;, &#x60;retrieval&#x60;, or &#x60;function&#x60;. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON RunStepObjectStepDetails
instance A.FromJSON RunStepObjectStepDetails where
  parseJSON = A.withObject "RunStepObjectStepDetails" $ \o ->
    RunStepObjectStepDetails
      <$> (o .:  "type")
      <*> (o .:  "message_creation")
      <*> (o .:  "tool_calls")

-- | ToJSON RunStepObjectStepDetails
instance A.ToJSON RunStepObjectStepDetails where
  toJSON RunStepObjectStepDetails {..} =
   _omitNulls
      [ "type" .= runStepObjectStepDetailsType
      , "message_creation" .= runStepObjectStepDetailsMessageCreation
      , "tool_calls" .= runStepObjectStepDetailsToolCalls
      ]


-- | Construct a value of type 'RunStepObjectStepDetails' (by applying it's required fields, if any)
mkRunStepObjectStepDetails
  :: E'Type10 -- ^ 'runStepObjectStepDetailsType': Always `tool_calls`.
  -> RunStepDetailsMessageCreationObjectMessageCreation -- ^ 'runStepObjectStepDetailsMessageCreation' 
  -> [RunStepDetailsToolCallsObjectToolCallsInner] -- ^ 'runStepObjectStepDetailsToolCalls': An array of tool calls the run step was involved in. These can be associated with one of three types of tools: `code_interpreter`, `retrieval`, or `function`. 
  -> RunStepObjectStepDetails
mkRunStepObjectStepDetails runStepObjectStepDetailsType runStepObjectStepDetailsMessageCreation runStepObjectStepDetailsToolCalls =
  RunStepObjectStepDetails
  { runStepObjectStepDetailsType
  , runStepObjectStepDetailsMessageCreation
  , runStepObjectStepDetailsToolCalls
  }

-- ** RunToolCallObject
-- | RunToolCallObject
-- Tool call objects
data RunToolCallObject = RunToolCallObject
  { runToolCallObjectId :: !(Text) -- ^ /Required/ "id" - The ID of the tool call. This ID must be referenced when you submit the tool outputs in using the [Submit tool outputs to run](/docs/api-reference/runs/submitToolOutputs) endpoint.
  , runToolCallObjectType :: !(E'Role) -- ^ /Required/ "type" - The type of tool call the output is required for. For now, this is always &#x60;function&#x60;.
  , runToolCallObjectFunction :: !(RunToolCallObjectFunction) -- ^ /Required/ "function"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON RunToolCallObject
instance A.FromJSON RunToolCallObject where
  parseJSON = A.withObject "RunToolCallObject" $ \o ->
    RunToolCallObject
      <$> (o .:  "id")
      <*> (o .:  "type")
      <*> (o .:  "function")

-- | ToJSON RunToolCallObject
instance A.ToJSON RunToolCallObject where
  toJSON RunToolCallObject {..} =
   _omitNulls
      [ "id" .= runToolCallObjectId
      , "type" .= runToolCallObjectType
      , "function" .= runToolCallObjectFunction
      ]


-- | Construct a value of type 'RunToolCallObject' (by applying it's required fields, if any)
mkRunToolCallObject
  :: Text -- ^ 'runToolCallObjectId': The ID of the tool call. This ID must be referenced when you submit the tool outputs in using the [Submit tool outputs to run](/docs/api-reference/runs/submitToolOutputs) endpoint.
  -> E'Role -- ^ 'runToolCallObjectType': The type of tool call the output is required for. For now, this is always `function`.
  -> RunToolCallObjectFunction -- ^ 'runToolCallObjectFunction' 
  -> RunToolCallObject
mkRunToolCallObject runToolCallObjectId runToolCallObjectType runToolCallObjectFunction =
  RunToolCallObject
  { runToolCallObjectId
  , runToolCallObjectType
  , runToolCallObjectFunction
  }

-- ** RunToolCallObjectFunction
-- | RunToolCallObjectFunction
-- The function definition.
data RunToolCallObjectFunction = RunToolCallObjectFunction
  { runToolCallObjectFunctionName :: !(Text) -- ^ /Required/ "name" - The name of the function.
  , runToolCallObjectFunctionArguments :: !(Text) -- ^ /Required/ "arguments" - The arguments that the model expects you to pass to the function.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON RunToolCallObjectFunction
instance A.FromJSON RunToolCallObjectFunction where
  parseJSON = A.withObject "RunToolCallObjectFunction" $ \o ->
    RunToolCallObjectFunction
      <$> (o .:  "name")
      <*> (o .:  "arguments")

-- | ToJSON RunToolCallObjectFunction
instance A.ToJSON RunToolCallObjectFunction where
  toJSON RunToolCallObjectFunction {..} =
   _omitNulls
      [ "name" .= runToolCallObjectFunctionName
      , "arguments" .= runToolCallObjectFunctionArguments
      ]


-- | Construct a value of type 'RunToolCallObjectFunction' (by applying it's required fields, if any)
mkRunToolCallObjectFunction
  :: Text -- ^ 'runToolCallObjectFunctionName': The name of the function.
  -> Text -- ^ 'runToolCallObjectFunctionArguments': The arguments that the model expects you to pass to the function.
  -> RunToolCallObjectFunction
mkRunToolCallObjectFunction runToolCallObjectFunctionName runToolCallObjectFunctionArguments =
  RunToolCallObjectFunction
  { runToolCallObjectFunctionName
  , runToolCallObjectFunctionArguments
  }

-- ** SubmitToolOutputsRunRequest
-- | SubmitToolOutputsRunRequest
data SubmitToolOutputsRunRequest = SubmitToolOutputsRunRequest
  { submitToolOutputsRunRequestToolOutputs :: !([SubmitToolOutputsRunRequestToolOutputsInner]) -- ^ /Required/ "tool_outputs" - A list of tools for which the outputs are being submitted.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SubmitToolOutputsRunRequest
instance A.FromJSON SubmitToolOutputsRunRequest where
  parseJSON = A.withObject "SubmitToolOutputsRunRequest" $ \o ->
    SubmitToolOutputsRunRequest
      <$> (o .:  "tool_outputs")

-- | ToJSON SubmitToolOutputsRunRequest
instance A.ToJSON SubmitToolOutputsRunRequest where
  toJSON SubmitToolOutputsRunRequest {..} =
   _omitNulls
      [ "tool_outputs" .= submitToolOutputsRunRequestToolOutputs
      ]


-- | Construct a value of type 'SubmitToolOutputsRunRequest' (by applying it's required fields, if any)
mkSubmitToolOutputsRunRequest
  :: [SubmitToolOutputsRunRequestToolOutputsInner] -- ^ 'submitToolOutputsRunRequestToolOutputs': A list of tools for which the outputs are being submitted.
  -> SubmitToolOutputsRunRequest
mkSubmitToolOutputsRunRequest submitToolOutputsRunRequestToolOutputs =
  SubmitToolOutputsRunRequest
  { submitToolOutputsRunRequestToolOutputs
  }

-- ** SubmitToolOutputsRunRequestToolOutputsInner
-- | SubmitToolOutputsRunRequestToolOutputsInner
data SubmitToolOutputsRunRequestToolOutputsInner = SubmitToolOutputsRunRequestToolOutputsInner
  { submitToolOutputsRunRequestToolOutputsInnerToolCallId :: !(Maybe Text) -- ^ "tool_call_id" - The ID of the tool call in the &#x60;required_action&#x60; object within the run object the output is being submitted for.
  , submitToolOutputsRunRequestToolOutputsInnerOutput :: !(Maybe Text) -- ^ "output" - The output of the tool call to be submitted to continue the run.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON SubmitToolOutputsRunRequestToolOutputsInner
instance A.FromJSON SubmitToolOutputsRunRequestToolOutputsInner where
  parseJSON = A.withObject "SubmitToolOutputsRunRequestToolOutputsInner" $ \o ->
    SubmitToolOutputsRunRequestToolOutputsInner
      <$> (o .:? "tool_call_id")
      <*> (o .:? "output")

-- | ToJSON SubmitToolOutputsRunRequestToolOutputsInner
instance A.ToJSON SubmitToolOutputsRunRequestToolOutputsInner where
  toJSON SubmitToolOutputsRunRequestToolOutputsInner {..} =
   _omitNulls
      [ "tool_call_id" .= submitToolOutputsRunRequestToolOutputsInnerToolCallId
      , "output" .= submitToolOutputsRunRequestToolOutputsInnerOutput
      ]


-- | Construct a value of type 'SubmitToolOutputsRunRequestToolOutputsInner' (by applying it's required fields, if any)
mkSubmitToolOutputsRunRequestToolOutputsInner
  :: SubmitToolOutputsRunRequestToolOutputsInner
mkSubmitToolOutputsRunRequestToolOutputsInner =
  SubmitToolOutputsRunRequestToolOutputsInner
  { submitToolOutputsRunRequestToolOutputsInnerToolCallId = Nothing
  , submitToolOutputsRunRequestToolOutputsInnerOutput = Nothing
  }

-- ** ThreadObject
-- | ThreadObject
-- Thread
-- 
-- Represents a thread that contains [messages](/docs/api-reference/messages).
data ThreadObject = ThreadObject
  { threadObjectId :: !(Text) -- ^ /Required/ "id" - The identifier, which can be referenced in API endpoints.
  , threadObjectObject :: !(E'Object12) -- ^ /Required/ "object" - The object type, which is always &#x60;thread&#x60;.
  , threadObjectCreatedAt :: !(Int) -- ^ /Required/ "created_at" - The Unix timestamp (in seconds) for when the thread was created.
  , threadObjectMetadata :: !(A.Value) -- ^ /Required/ "metadata" - Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long. 
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ThreadObject
instance A.FromJSON ThreadObject where
  parseJSON = A.withObject "ThreadObject" $ \o ->
    ThreadObject
      <$> (o .:  "id")
      <*> (o .:  "object")
      <*> (o .:  "created_at")
      <*> (o .:  "metadata")

-- | ToJSON ThreadObject
instance A.ToJSON ThreadObject where
  toJSON ThreadObject {..} =
   _omitNulls
      [ "id" .= threadObjectId
      , "object" .= threadObjectObject
      , "created_at" .= threadObjectCreatedAt
      , "metadata" .= threadObjectMetadata
      ]


-- | Construct a value of type 'ThreadObject' (by applying it's required fields, if any)
mkThreadObject
  :: Text -- ^ 'threadObjectId': The identifier, which can be referenced in API endpoints.
  -> E'Object12 -- ^ 'threadObjectObject': The object type, which is always `thread`.
  -> Int -- ^ 'threadObjectCreatedAt': The Unix timestamp (in seconds) for when the thread was created.
  -> A.Value -- ^ 'threadObjectMetadata': Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maxium of 512 characters long. 
  -> ThreadObject
mkThreadObject threadObjectId threadObjectObject threadObjectCreatedAt threadObjectMetadata =
  ThreadObject
  { threadObjectId
  , threadObjectObject
  , threadObjectCreatedAt
  , threadObjectMetadata
  }

-- ** TranscriptionSegment
-- | TranscriptionSegment
data TranscriptionSegment = TranscriptionSegment
  { transcriptionSegmentId :: !(Int) -- ^ /Required/ "id" - Unique identifier of the segment.
  , transcriptionSegmentSeek :: !(Int) -- ^ /Required/ "seek" - Seek offset of the segment.
  , transcriptionSegmentStart :: !(Float) -- ^ /Required/ "start" - Start time of the segment in seconds.
  , transcriptionSegmentEnd :: !(Float) -- ^ /Required/ "end" - End time of the segment in seconds.
  , transcriptionSegmentText :: !(Text) -- ^ /Required/ "text" - Text content of the segment.
  , transcriptionSegmentTokens :: !([Int]) -- ^ /Required/ "tokens" - Array of token IDs for the text content.
  , transcriptionSegmentTemperature :: !(Float) -- ^ /Required/ "temperature" - Temperature parameter used for generating the segment.
  , transcriptionSegmentAvgLogprob :: !(Float) -- ^ /Required/ "avg_logprob" - Average logprob of the segment. If the value is lower than -1, consider the logprobs failed.
  , transcriptionSegmentCompressionRatio :: !(Float) -- ^ /Required/ "compression_ratio" - Compression ratio of the segment. If the value is greater than 2.4, consider the compression failed.
  , transcriptionSegmentNoSpeechProb :: !(Float) -- ^ /Required/ "no_speech_prob" - Probability of no speech in the segment. If the value is higher than 1.0 and the &#x60;avg_logprob&#x60; is below -1, consider this segment silent.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TranscriptionSegment
instance A.FromJSON TranscriptionSegment where
  parseJSON = A.withObject "TranscriptionSegment" $ \o ->
    TranscriptionSegment
      <$> (o .:  "id")
      <*> (o .:  "seek")
      <*> (o .:  "start")
      <*> (o .:  "end")
      <*> (o .:  "text")
      <*> (o .:  "tokens")
      <*> (o .:  "temperature")
      <*> (o .:  "avg_logprob")
      <*> (o .:  "compression_ratio")
      <*> (o .:  "no_speech_prob")

-- | ToJSON TranscriptionSegment
instance A.ToJSON TranscriptionSegment where
  toJSON TranscriptionSegment {..} =
   _omitNulls
      [ "id" .= transcriptionSegmentId
      , "seek" .= transcriptionSegmentSeek
      , "start" .= transcriptionSegmentStart
      , "end" .= transcriptionSegmentEnd
      , "text" .= transcriptionSegmentText
      , "tokens" .= transcriptionSegmentTokens
      , "temperature" .= transcriptionSegmentTemperature
      , "avg_logprob" .= transcriptionSegmentAvgLogprob
      , "compression_ratio" .= transcriptionSegmentCompressionRatio
      , "no_speech_prob" .= transcriptionSegmentNoSpeechProb
      ]


-- | Construct a value of type 'TranscriptionSegment' (by applying it's required fields, if any)
mkTranscriptionSegment
  :: Int -- ^ 'transcriptionSegmentId': Unique identifier of the segment.
  -> Int -- ^ 'transcriptionSegmentSeek': Seek offset of the segment.
  -> Float -- ^ 'transcriptionSegmentStart': Start time of the segment in seconds.
  -> Float -- ^ 'transcriptionSegmentEnd': End time of the segment in seconds.
  -> Text -- ^ 'transcriptionSegmentText': Text content of the segment.
  -> [Int] -- ^ 'transcriptionSegmentTokens': Array of token IDs for the text content.
  -> Float -- ^ 'transcriptionSegmentTemperature': Temperature parameter used for generating the segment.
  -> Float -- ^ 'transcriptionSegmentAvgLogprob': Average logprob of the segment. If the value is lower than -1, consider the logprobs failed.
  -> Float -- ^ 'transcriptionSegmentCompressionRatio': Compression ratio of the segment. If the value is greater than 2.4, consider the compression failed.
  -> Float -- ^ 'transcriptionSegmentNoSpeechProb': Probability of no speech in the segment. If the value is higher than 1.0 and the `avg_logprob` is below -1, consider this segment silent.
  -> TranscriptionSegment
mkTranscriptionSegment transcriptionSegmentId transcriptionSegmentSeek transcriptionSegmentStart transcriptionSegmentEnd transcriptionSegmentText transcriptionSegmentTokens transcriptionSegmentTemperature transcriptionSegmentAvgLogprob transcriptionSegmentCompressionRatio transcriptionSegmentNoSpeechProb =
  TranscriptionSegment
  { transcriptionSegmentId
  , transcriptionSegmentSeek
  , transcriptionSegmentStart
  , transcriptionSegmentEnd
  , transcriptionSegmentText
  , transcriptionSegmentTokens
  , transcriptionSegmentTemperature
  , transcriptionSegmentAvgLogprob
  , transcriptionSegmentCompressionRatio
  , transcriptionSegmentNoSpeechProb
  }

-- ** TranscriptionWord
-- | TranscriptionWord
data TranscriptionWord = TranscriptionWord
  { transcriptionWordWord :: !(Text) -- ^ /Required/ "word" - The text content of the word.
  , transcriptionWordStart :: !(Float) -- ^ /Required/ "start" - Start time of the word in seconds.
  , transcriptionWordEnd :: !(Float) -- ^ /Required/ "end" - End time of the word in seconds.
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON TranscriptionWord
instance A.FromJSON TranscriptionWord where
  parseJSON = A.withObject "TranscriptionWord" $ \o ->
    TranscriptionWord
      <$> (o .:  "word")
      <*> (o .:  "start")
      <*> (o .:  "end")

-- | ToJSON TranscriptionWord
instance A.ToJSON TranscriptionWord where
  toJSON TranscriptionWord {..} =
   _omitNulls
      [ "word" .= transcriptionWordWord
      , "start" .= transcriptionWordStart
      , "end" .= transcriptionWordEnd
      ]


-- | Construct a value of type 'TranscriptionWord' (by applying it's required fields, if any)
mkTranscriptionWord
  :: Text -- ^ 'transcriptionWordWord': The text content of the word.
  -> Float -- ^ 'transcriptionWordStart': Start time of the word in seconds.
  -> Float -- ^ 'transcriptionWordEnd': End time of the word in seconds.
  -> TranscriptionWord
mkTranscriptionWord transcriptionWordWord transcriptionWordStart transcriptionWordEnd =
  TranscriptionWord
  { transcriptionWordWord
  , transcriptionWordStart
  , transcriptionWordEnd
  }


-- * Enums


-- ** ChatCompletionRole

-- | Enum of 'Text' .
-- The role of the author of a message
data ChatCompletionRole
  = ChatCompletionRole'System -- ^ @"system"@
  | ChatCompletionRole'User -- ^ @"user"@
  | ChatCompletionRole'Assistant -- ^ @"assistant"@
  | ChatCompletionRole'Tool -- ^ @"tool"@
  | ChatCompletionRole'Function -- ^ @"function"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON ChatCompletionRole where toJSON = A.toJSON . fromChatCompletionRole
instance A.FromJSON ChatCompletionRole where parseJSON o = P.either P.fail (pure . P.id) . toChatCompletionRole =<< A.parseJSON o
instance WH.ToHttpApiData ChatCompletionRole where toQueryParam = WH.toQueryParam . fromChatCompletionRole
instance WH.FromHttpApiData ChatCompletionRole where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toChatCompletionRole
instance MimeRender MimeMultipartFormData ChatCompletionRole where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'ChatCompletionRole' enum
fromChatCompletionRole :: ChatCompletionRole -> Text
fromChatCompletionRole = \case
  ChatCompletionRole'System -> "system"
  ChatCompletionRole'User -> "user"
  ChatCompletionRole'Assistant -> "assistant"
  ChatCompletionRole'Tool -> "tool"
  ChatCompletionRole'Function -> "function"

-- | parse 'ChatCompletionRole' enum
toChatCompletionRole :: Text -> P.Either String ChatCompletionRole
toChatCompletionRole = \case
  "system" -> P.Right ChatCompletionRole'System
  "user" -> P.Right ChatCompletionRole'User
  "assistant" -> P.Right ChatCompletionRole'Assistant
  "tool" -> P.Right ChatCompletionRole'Tool
  "function" -> P.Right ChatCompletionRole'Function
  s -> P.Left $ "toChatCompletionRole: enum parse failure: " P.++ P.show s


-- ** E'AnyOf1

-- | Enum of 'Text'
data E'AnyOf1
  = E'AnyOf1'Gpt_3_5_turbo_instruct -- ^ @"gpt-3.5-turbo-instruct"@
  | E'AnyOf1'Davinci_002 -- ^ @"davinci-002"@
  | E'AnyOf1'Babbage_002 -- ^ @"babbage-002"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'AnyOf1 where toJSON = A.toJSON . fromE'AnyOf1
instance A.FromJSON E'AnyOf1 where parseJSON o = P.either P.fail (pure . P.id) . toE'AnyOf1 =<< A.parseJSON o
instance WH.ToHttpApiData E'AnyOf1 where toQueryParam = WH.toQueryParam . fromE'AnyOf1
instance WH.FromHttpApiData E'AnyOf1 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'AnyOf1
instance MimeRender MimeMultipartFormData E'AnyOf1 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'AnyOf1' enum
fromE'AnyOf1 :: E'AnyOf1 -> Text
fromE'AnyOf1 = \case
  E'AnyOf1'Gpt_3_5_turbo_instruct -> "gpt-3.5-turbo-instruct"
  E'AnyOf1'Davinci_002 -> "davinci-002"
  E'AnyOf1'Babbage_002 -> "babbage-002"

-- | parse 'E'AnyOf1' enum
toE'AnyOf1 :: Text -> P.Either String E'AnyOf1
toE'AnyOf1 = \case
  "gpt-3.5-turbo-instruct" -> P.Right E'AnyOf1'Gpt_3_5_turbo_instruct
  "davinci-002" -> P.Right E'AnyOf1'Davinci_002
  "babbage-002" -> P.Right E'AnyOf1'Babbage_002
  s -> P.Left $ "toE'AnyOf1: enum parse failure: " P.++ P.show s


-- ** E'AnyOf2

-- | Enum of 'Text'
data E'AnyOf2
  = E'AnyOf2'4_0125_preview -- ^ @"gpt-4-0125-preview"@
  | E'AnyOf2'4_turbo_preview -- ^ @"gpt-4-turbo-preview"@
  | E'AnyOf2'4_1106_preview -- ^ @"gpt-4-1106-preview"@
  | E'AnyOf2'4_vision_preview -- ^ @"gpt-4-vision-preview"@
  | E'AnyOf2'4 -- ^ @"gpt-4"@
  | E'AnyOf2'4_0314 -- ^ @"gpt-4-0314"@
  | E'AnyOf2'4_0613 -- ^ @"gpt-4-0613"@
  | E'AnyOf2'4_32k -- ^ @"gpt-4-32k"@
  | E'AnyOf2'4_32k_0314 -- ^ @"gpt-4-32k-0314"@
  | E'AnyOf2'4_32k_0613 -- ^ @"gpt-4-32k-0613"@
  | E'AnyOf2'3_5_turbo -- ^ @"gpt-3.5-turbo"@
  | E'AnyOf2'3_5_turbo_16k -- ^ @"gpt-3.5-turbo-16k"@
  | E'AnyOf2'3_5_turbo_0301 -- ^ @"gpt-3.5-turbo-0301"@
  | E'AnyOf2'3_5_turbo_0613 -- ^ @"gpt-3.5-turbo-0613"@
  | E'AnyOf2'3_5_turbo_1106 -- ^ @"gpt-3.5-turbo-1106"@
  | E'AnyOf2'3_5_turbo_0125 -- ^ @"gpt-3.5-turbo-0125"@
  | E'AnyOf2'3_5_turbo_16k_0613 -- ^ @"gpt-3.5-turbo-16k-0613"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'AnyOf2 where toJSON = A.toJSON . fromE'AnyOf2
instance A.FromJSON E'AnyOf2 where parseJSON o = P.either P.fail (pure . P.id) . toE'AnyOf2 =<< A.parseJSON o
instance WH.ToHttpApiData E'AnyOf2 where toQueryParam = WH.toQueryParam . fromE'AnyOf2
instance WH.FromHttpApiData E'AnyOf2 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'AnyOf2
instance MimeRender MimeMultipartFormData E'AnyOf2 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'AnyOf2' enum
fromE'AnyOf2 :: E'AnyOf2 -> Text
fromE'AnyOf2 = \case
  E'AnyOf2'4_0125_preview -> "gpt-4-0125-preview"
  E'AnyOf2'4_turbo_preview -> "gpt-4-turbo-preview"
  E'AnyOf2'4_1106_preview -> "gpt-4-1106-preview"
  E'AnyOf2'4_vision_preview -> "gpt-4-vision-preview"
  E'AnyOf2'4 -> "gpt-4"
  E'AnyOf2'4_0314 -> "gpt-4-0314"
  E'AnyOf2'4_0613 -> "gpt-4-0613"
  E'AnyOf2'4_32k -> "gpt-4-32k"
  E'AnyOf2'4_32k_0314 -> "gpt-4-32k-0314"
  E'AnyOf2'4_32k_0613 -> "gpt-4-32k-0613"
  E'AnyOf2'3_5_turbo -> "gpt-3.5-turbo"
  E'AnyOf2'3_5_turbo_16k -> "gpt-3.5-turbo-16k"
  E'AnyOf2'3_5_turbo_0301 -> "gpt-3.5-turbo-0301"
  E'AnyOf2'3_5_turbo_0613 -> "gpt-3.5-turbo-0613"
  E'AnyOf2'3_5_turbo_1106 -> "gpt-3.5-turbo-1106"
  E'AnyOf2'3_5_turbo_0125 -> "gpt-3.5-turbo-0125"
  E'AnyOf2'3_5_turbo_16k_0613 -> "gpt-3.5-turbo-16k-0613"

-- | parse 'E'AnyOf2' enum
toE'AnyOf2 :: Text -> P.Either String E'AnyOf2
toE'AnyOf2 = \case
  "gpt-4-0125-preview" -> P.Right E'AnyOf2'4_0125_preview
  "gpt-4-turbo-preview" -> P.Right E'AnyOf2'4_turbo_preview
  "gpt-4-1106-preview" -> P.Right E'AnyOf2'4_1106_preview
  "gpt-4-vision-preview" -> P.Right E'AnyOf2'4_vision_preview
  "gpt-4" -> P.Right E'AnyOf2'4
  "gpt-4-0314" -> P.Right E'AnyOf2'4_0314
  "gpt-4-0613" -> P.Right E'AnyOf2'4_0613
  "gpt-4-32k" -> P.Right E'AnyOf2'4_32k
  "gpt-4-32k-0314" -> P.Right E'AnyOf2'4_32k_0314
  "gpt-4-32k-0613" -> P.Right E'AnyOf2'4_32k_0613
  "gpt-3.5-turbo" -> P.Right E'AnyOf2'3_5_turbo
  "gpt-3.5-turbo-16k" -> P.Right E'AnyOf2'3_5_turbo_16k
  "gpt-3.5-turbo-0301" -> P.Right E'AnyOf2'3_5_turbo_0301
  "gpt-3.5-turbo-0613" -> P.Right E'AnyOf2'3_5_turbo_0613
  "gpt-3.5-turbo-1106" -> P.Right E'AnyOf2'3_5_turbo_1106
  "gpt-3.5-turbo-0125" -> P.Right E'AnyOf2'3_5_turbo_0125
  "gpt-3.5-turbo-16k-0613" -> P.Right E'AnyOf2'3_5_turbo_16k_0613
  s -> P.Left $ "toE'AnyOf2: enum parse failure: " P.++ P.show s


-- ** E'AnyOf3

-- | Enum of 'Text'
data E'AnyOf3
  = E'AnyOf3'2 -- ^ @"dall-e-2"@
  | E'AnyOf3'3 -- ^ @"dall-e-3"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'AnyOf3 where toJSON = A.toJSON . fromE'AnyOf3
instance A.FromJSON E'AnyOf3 where parseJSON o = P.either P.fail (pure . P.id) . toE'AnyOf3 =<< A.parseJSON o
instance WH.ToHttpApiData E'AnyOf3 where toQueryParam = WH.toQueryParam . fromE'AnyOf3
instance WH.FromHttpApiData E'AnyOf3 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'AnyOf3
instance MimeRender MimeMultipartFormData E'AnyOf3 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'AnyOf3' enum
fromE'AnyOf3 :: E'AnyOf3 -> Text
fromE'AnyOf3 = \case
  E'AnyOf3'2 -> "dall-e-2"
  E'AnyOf3'3 -> "dall-e-3"

-- | parse 'E'AnyOf3' enum
toE'AnyOf3 :: Text -> P.Either String E'AnyOf3
toE'AnyOf3 = \case
  "dall-e-2" -> P.Right E'AnyOf3'2
  "dall-e-3" -> P.Right E'AnyOf3'3
  s -> P.Left $ "toE'AnyOf3: enum parse failure: " P.++ P.show s


-- ** E'AnyOf4

-- | Enum of 'Text'
data E'AnyOf4
  = E'AnyOf4'Latest -- ^ @"text-moderation-latest"@
  | E'AnyOf4'Stable -- ^ @"text-moderation-stable"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'AnyOf4 where toJSON = A.toJSON . fromE'AnyOf4
instance A.FromJSON E'AnyOf4 where parseJSON o = P.either P.fail (pure . P.id) . toE'AnyOf4 =<< A.parseJSON o
instance WH.ToHttpApiData E'AnyOf4 where toQueryParam = WH.toQueryParam . fromE'AnyOf4
instance WH.FromHttpApiData E'AnyOf4 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'AnyOf4
instance MimeRender MimeMultipartFormData E'AnyOf4 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'AnyOf4' enum
fromE'AnyOf4 :: E'AnyOf4 -> Text
fromE'AnyOf4 = \case
  E'AnyOf4'Latest -> "text-moderation-latest"
  E'AnyOf4'Stable -> "text-moderation-stable"

-- | parse 'E'AnyOf4' enum
toE'AnyOf4 :: Text -> P.Either String E'AnyOf4
toE'AnyOf4 = \case
  "text-moderation-latest" -> P.Right E'AnyOf4'Latest
  "text-moderation-stable" -> P.Right E'AnyOf4'Stable
  s -> P.Left $ "toE'AnyOf4: enum parse failure: " P.++ P.show s


-- ** E'AnyOf5

-- | Enum of 'Text'
data E'AnyOf5
  = E'AnyOf5'Babbage_002 -- ^ @"babbage-002"@
  | E'AnyOf5'Davinci_002 -- ^ @"davinci-002"@
  | E'AnyOf5'Gpt_3_5_turbo -- ^ @"gpt-3.5-turbo"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'AnyOf5 where toJSON = A.toJSON . fromE'AnyOf5
instance A.FromJSON E'AnyOf5 where parseJSON o = P.either P.fail (pure . P.id) . toE'AnyOf5 =<< A.parseJSON o
instance WH.ToHttpApiData E'AnyOf5 where toQueryParam = WH.toQueryParam . fromE'AnyOf5
instance WH.FromHttpApiData E'AnyOf5 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'AnyOf5
instance MimeRender MimeMultipartFormData E'AnyOf5 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'AnyOf5' enum
fromE'AnyOf5 :: E'AnyOf5 -> Text
fromE'AnyOf5 = \case
  E'AnyOf5'Babbage_002 -> "babbage-002"
  E'AnyOf5'Davinci_002 -> "davinci-002"
  E'AnyOf5'Gpt_3_5_turbo -> "gpt-3.5-turbo"

-- | parse 'E'AnyOf5' enum
toE'AnyOf5 :: Text -> P.Either String E'AnyOf5
toE'AnyOf5 = \case
  "babbage-002" -> P.Right E'AnyOf5'Babbage_002
  "davinci-002" -> P.Right E'AnyOf5'Davinci_002
  "gpt-3.5-turbo" -> P.Right E'AnyOf5'Gpt_3_5_turbo
  s -> P.Left $ "toE'AnyOf5: enum parse failure: " P.++ P.show s


-- ** E'AnyOf6

-- | Enum of 'Text'
data E'AnyOf6
  = E'AnyOf6'Ada_002 -- ^ @"text-embedding-ada-002"@
  | E'AnyOf6'3_small -- ^ @"text-embedding-3-small"@
  | E'AnyOf6'3_large -- ^ @"text-embedding-3-large"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'AnyOf6 where toJSON = A.toJSON . fromE'AnyOf6
instance A.FromJSON E'AnyOf6 where parseJSON o = P.either P.fail (pure . P.id) . toE'AnyOf6 =<< A.parseJSON o
instance WH.ToHttpApiData E'AnyOf6 where toQueryParam = WH.toQueryParam . fromE'AnyOf6
instance WH.FromHttpApiData E'AnyOf6 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'AnyOf6
instance MimeRender MimeMultipartFormData E'AnyOf6 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'AnyOf6' enum
fromE'AnyOf6 :: E'AnyOf6 -> Text
fromE'AnyOf6 = \case
  E'AnyOf6'Ada_002 -> "text-embedding-ada-002"
  E'AnyOf6'3_small -> "text-embedding-3-small"
  E'AnyOf6'3_large -> "text-embedding-3-large"

-- | parse 'E'AnyOf6' enum
toE'AnyOf6 :: Text -> P.Either String E'AnyOf6
toE'AnyOf6 = \case
  "text-embedding-ada-002" -> P.Right E'AnyOf6'Ada_002
  "text-embedding-3-small" -> P.Right E'AnyOf6'3_small
  "text-embedding-3-large" -> P.Right E'AnyOf6'3_large
  s -> P.Left $ "toE'AnyOf6: enum parse failure: " P.++ P.show s


-- ** E'AnyOf7

-- | Enum of 'Text'
data E'AnyOf7
  = E'AnyOf7'1 -- ^ @"tts-1"@
  | E'AnyOf7'1_hd -- ^ @"tts-1-hd"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'AnyOf7 where toJSON = A.toJSON . fromE'AnyOf7
instance A.FromJSON E'AnyOf7 where parseJSON o = P.either P.fail (pure . P.id) . toE'AnyOf7 =<< A.parseJSON o
instance WH.ToHttpApiData E'AnyOf7 where toQueryParam = WH.toQueryParam . fromE'AnyOf7
instance WH.FromHttpApiData E'AnyOf7 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'AnyOf7
instance MimeRender MimeMultipartFormData E'AnyOf7 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'AnyOf7' enum
fromE'AnyOf7 :: E'AnyOf7 -> Text
fromE'AnyOf7 = \case
  E'AnyOf7'1 -> "tts-1"
  E'AnyOf7'1_hd -> "tts-1-hd"

-- | parse 'E'AnyOf7' enum
toE'AnyOf7 :: Text -> P.Either String E'AnyOf7
toE'AnyOf7 = \case
  "tts-1" -> P.Right E'AnyOf7'1
  "tts-1-hd" -> P.Right E'AnyOf7'1_hd
  s -> P.Left $ "toE'AnyOf7: enum parse failure: " P.++ P.show s


-- ** E'Code

-- | Enum of 'Text' .
-- One of `server_error`, `rate_limit_exceeded`, or `invalid_prompt`.
data E'Code
  = E'Code'Server_error -- ^ @"server_error"@
  | E'Code'Rate_limit_exceeded -- ^ @"rate_limit_exceeded"@
  | E'Code'Invalid_prompt -- ^ @"invalid_prompt"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Code where toJSON = A.toJSON . fromE'Code
instance A.FromJSON E'Code where parseJSON o = P.either P.fail (pure . P.id) . toE'Code =<< A.parseJSON o
instance WH.ToHttpApiData E'Code where toQueryParam = WH.toQueryParam . fromE'Code
instance WH.FromHttpApiData E'Code where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Code
instance MimeRender MimeMultipartFormData E'Code where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Code' enum
fromE'Code :: E'Code -> Text
fromE'Code = \case
  E'Code'Server_error -> "server_error"
  E'Code'Rate_limit_exceeded -> "rate_limit_exceeded"
  E'Code'Invalid_prompt -> "invalid_prompt"

-- | parse 'E'Code' enum
toE'Code :: Text -> P.Either String E'Code
toE'Code = \case
  "server_error" -> P.Right E'Code'Server_error
  "rate_limit_exceeded" -> P.Right E'Code'Rate_limit_exceeded
  "invalid_prompt" -> P.Right E'Code'Invalid_prompt
  s -> P.Left $ "toE'Code: enum parse failure: " P.++ P.show s


-- ** E'Code2

-- | Enum of 'Text' .
-- One of `server_error` or `rate_limit_exceeded`.
data E'Code2
  = E'Code2'Server_error -- ^ @"server_error"@
  | E'Code2'Rate_limit_exceeded -- ^ @"rate_limit_exceeded"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Code2 where toJSON = A.toJSON . fromE'Code2
instance A.FromJSON E'Code2 where parseJSON o = P.either P.fail (pure . P.id) . toE'Code2 =<< A.parseJSON o
instance WH.ToHttpApiData E'Code2 where toQueryParam = WH.toQueryParam . fromE'Code2
instance WH.FromHttpApiData E'Code2 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Code2
instance MimeRender MimeMultipartFormData E'Code2 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Code2' enum
fromE'Code2 :: E'Code2 -> Text
fromE'Code2 = \case
  E'Code2'Server_error -> "server_error"
  E'Code2'Rate_limit_exceeded -> "rate_limit_exceeded"

-- | parse 'E'Code2' enum
toE'Code2 :: Text -> P.Either String E'Code2
toE'Code2 = \case
  "server_error" -> P.Right E'Code2'Server_error
  "rate_limit_exceeded" -> P.Right E'Code2'Rate_limit_exceeded
  s -> P.Left $ "toE'Code2: enum parse failure: " P.++ P.show s


-- ** E'Detail

-- | Enum of 'Text' .
-- Specifies the detail level of the image. Learn more in the [Vision guide](/docs/guides/vision/low-or-high-fidelity-image-understanding).
data E'Detail
  = E'Detail'Auto -- ^ @"auto"@
  | E'Detail'Low -- ^ @"low"@
  | E'Detail'High -- ^ @"high"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Detail where toJSON = A.toJSON . fromE'Detail
instance A.FromJSON E'Detail where parseJSON o = P.either P.fail (pure . P.id) . toE'Detail =<< A.parseJSON o
instance WH.ToHttpApiData E'Detail where toQueryParam = WH.toQueryParam . fromE'Detail
instance WH.FromHttpApiData E'Detail where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Detail
instance MimeRender MimeMultipartFormData E'Detail where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Detail' enum
fromE'Detail :: E'Detail -> Text
fromE'Detail = \case
  E'Detail'Auto -> "auto"
  E'Detail'Low -> "low"
  E'Detail'High -> "high"

-- | parse 'E'Detail' enum
toE'Detail :: Text -> P.Either String E'Detail
toE'Detail = \case
  "auto" -> P.Right E'Detail'Auto
  "low" -> P.Right E'Detail'Low
  "high" -> P.Right E'Detail'High
  s -> P.Left $ "toE'Detail: enum parse failure: " P.++ P.show s


-- ** E'EncodingFormat

-- | Enum of 'Text' .
-- The format to return the embeddings in. Can be either `float` or [`base64`](https://pypi.org/project/pybase64/).
data E'EncodingFormat
  = E'EncodingFormat'Float -- ^ @"float"@
  | E'EncodingFormat'Base64 -- ^ @"base64"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'EncodingFormat where toJSON = A.toJSON . fromE'EncodingFormat
instance A.FromJSON E'EncodingFormat where parseJSON o = P.either P.fail (pure . P.id) . toE'EncodingFormat =<< A.parseJSON o
instance WH.ToHttpApiData E'EncodingFormat where toQueryParam = WH.toQueryParam . fromE'EncodingFormat
instance WH.FromHttpApiData E'EncodingFormat where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'EncodingFormat
instance MimeRender MimeMultipartFormData E'EncodingFormat where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'EncodingFormat' enum
fromE'EncodingFormat :: E'EncodingFormat -> Text
fromE'EncodingFormat = \case
  E'EncodingFormat'Float -> "float"
  E'EncodingFormat'Base64 -> "base64"

-- | parse 'E'EncodingFormat' enum
toE'EncodingFormat :: Text -> P.Either String E'EncodingFormat
toE'EncodingFormat = \case
  "float" -> P.Right E'EncodingFormat'Float
  "base64" -> P.Right E'EncodingFormat'Base64
  s -> P.Left $ "toE'EncodingFormat: enum parse failure: " P.++ P.show s


-- ** E'FinishReason

-- | Enum of 'Text' .
-- The reason the model stopped generating tokens. This will be `stop` if the model hit a natural stop point or a provided stop sequence, `length` if the maximum number of tokens specified in the request was reached, or `content_filter` if content was omitted due to a flag from our content filters. 
data E'FinishReason
  = E'FinishReason'Stop -- ^ @"stop"@
  | E'FinishReason'Length -- ^ @"length"@
  | E'FinishReason'Content_filter -- ^ @"content_filter"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'FinishReason where toJSON = A.toJSON . fromE'FinishReason
instance A.FromJSON E'FinishReason where parseJSON o = P.either P.fail (pure . P.id) . toE'FinishReason =<< A.parseJSON o
instance WH.ToHttpApiData E'FinishReason where toQueryParam = WH.toQueryParam . fromE'FinishReason
instance WH.FromHttpApiData E'FinishReason where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'FinishReason
instance MimeRender MimeMultipartFormData E'FinishReason where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'FinishReason' enum
fromE'FinishReason :: E'FinishReason -> Text
fromE'FinishReason = \case
  E'FinishReason'Stop -> "stop"
  E'FinishReason'Length -> "length"
  E'FinishReason'Content_filter -> "content_filter"

-- | parse 'E'FinishReason' enum
toE'FinishReason :: Text -> P.Either String E'FinishReason
toE'FinishReason = \case
  "stop" -> P.Right E'FinishReason'Stop
  "length" -> P.Right E'FinishReason'Length
  "content_filter" -> P.Right E'FinishReason'Content_filter
  s -> P.Left $ "toE'FinishReason: enum parse failure: " P.++ P.show s


-- ** E'FinishReason2

-- | Enum of 'Text' .
-- The reason the model stopped generating tokens. This will be `stop` if the model hit a natural stop point or a provided stop sequence, `length` if the maximum number of tokens specified in the request was reached, `content_filter` if content was omitted due to a flag from our content filters, `tool_calls` if the model called a tool, or `function_call` (deprecated) if the model called a function. 
data E'FinishReason2
  = E'FinishReason2'Stop -- ^ @"stop"@
  | E'FinishReason2'Length -- ^ @"length"@
  | E'FinishReason2'Tool_calls -- ^ @"tool_calls"@
  | E'FinishReason2'Content_filter -- ^ @"content_filter"@
  | E'FinishReason2'Function_call -- ^ @"function_call"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'FinishReason2 where toJSON = A.toJSON . fromE'FinishReason2
instance A.FromJSON E'FinishReason2 where parseJSON o = P.either P.fail (pure . P.id) . toE'FinishReason2 =<< A.parseJSON o
instance WH.ToHttpApiData E'FinishReason2 where toQueryParam = WH.toQueryParam . fromE'FinishReason2
instance WH.FromHttpApiData E'FinishReason2 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'FinishReason2
instance MimeRender MimeMultipartFormData E'FinishReason2 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'FinishReason2' enum
fromE'FinishReason2 :: E'FinishReason2 -> Text
fromE'FinishReason2 = \case
  E'FinishReason2'Stop -> "stop"
  E'FinishReason2'Length -> "length"
  E'FinishReason2'Tool_calls -> "tool_calls"
  E'FinishReason2'Content_filter -> "content_filter"
  E'FinishReason2'Function_call -> "function_call"

-- | parse 'E'FinishReason2' enum
toE'FinishReason2 :: Text -> P.Either String E'FinishReason2
toE'FinishReason2 = \case
  "stop" -> P.Right E'FinishReason2'Stop
  "length" -> P.Right E'FinishReason2'Length
  "tool_calls" -> P.Right E'FinishReason2'Tool_calls
  "content_filter" -> P.Right E'FinishReason2'Content_filter
  "function_call" -> P.Right E'FinishReason2'Function_call
  s -> P.Left $ "toE'FinishReason2: enum parse failure: " P.++ P.show s


-- ** E'FinishReason3

-- | Enum of 'Text' .
-- The reason the model stopped generating tokens. This will be `stop` if the model hit a natural stop point or a provided stop sequence, `length` if the maximum number of tokens specified in the request was reached, `content_filter` if content was omitted due to a flag from our content filters, or `function_call` if the model called a function. 
data E'FinishReason3
  = E'FinishReason3'Stop -- ^ @"stop"@
  | E'FinishReason3'Length -- ^ @"length"@
  | E'FinishReason3'Function_call -- ^ @"function_call"@
  | E'FinishReason3'Content_filter -- ^ @"content_filter"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'FinishReason3 where toJSON = A.toJSON . fromE'FinishReason3
instance A.FromJSON E'FinishReason3 where parseJSON o = P.either P.fail (pure . P.id) . toE'FinishReason3 =<< A.parseJSON o
instance WH.ToHttpApiData E'FinishReason3 where toQueryParam = WH.toQueryParam . fromE'FinishReason3
instance WH.FromHttpApiData E'FinishReason3 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'FinishReason3
instance MimeRender MimeMultipartFormData E'FinishReason3 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'FinishReason3' enum
fromE'FinishReason3 :: E'FinishReason3 -> Text
fromE'FinishReason3 = \case
  E'FinishReason3'Stop -> "stop"
  E'FinishReason3'Length -> "length"
  E'FinishReason3'Function_call -> "function_call"
  E'FinishReason3'Content_filter -> "content_filter"

-- | parse 'E'FinishReason3' enum
toE'FinishReason3 :: Text -> P.Either String E'FinishReason3
toE'FinishReason3 = \case
  "stop" -> P.Right E'FinishReason3'Stop
  "length" -> P.Right E'FinishReason3'Length
  "function_call" -> P.Right E'FinishReason3'Function_call
  "content_filter" -> P.Right E'FinishReason3'Content_filter
  s -> P.Left $ "toE'FinishReason3: enum parse failure: " P.++ P.show s


-- ** E'Level

-- | Enum of 'Text'
data E'Level
  = E'Level'Info -- ^ @"info"@
  | E'Level'Warn -- ^ @"warn"@
  | E'Level'Error -- ^ @"error"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Level where toJSON = A.toJSON . fromE'Level
instance A.FromJSON E'Level where parseJSON o = P.either P.fail (pure . P.id) . toE'Level =<< A.parseJSON o
instance WH.ToHttpApiData E'Level where toQueryParam = WH.toQueryParam . fromE'Level
instance WH.FromHttpApiData E'Level where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Level
instance MimeRender MimeMultipartFormData E'Level where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Level' enum
fromE'Level :: E'Level -> Text
fromE'Level = \case
  E'Level'Info -> "info"
  E'Level'Warn -> "warn"
  E'Level'Error -> "error"

-- | parse 'E'Level' enum
toE'Level :: Text -> P.Either String E'Level
toE'Level = \case
  "info" -> P.Right E'Level'Info
  "warn" -> P.Right E'Level'Warn
  "error" -> P.Right E'Level'Error
  s -> P.Left $ "toE'Level: enum parse failure: " P.++ P.show s


-- ** E'Object

-- | Enum of 'Text'
data E'Object
  = E'Object'List -- ^ @"list"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Object where toJSON = A.toJSON . fromE'Object
instance A.FromJSON E'Object where parseJSON o = P.either P.fail (pure . P.id) . toE'Object =<< A.parseJSON o
instance WH.ToHttpApiData E'Object where toQueryParam = WH.toQueryParam . fromE'Object
instance WH.FromHttpApiData E'Object where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Object
instance MimeRender MimeMultipartFormData E'Object where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Object' enum
fromE'Object :: E'Object -> Text
fromE'Object = \case
  E'Object'List -> "list"

-- | parse 'E'Object' enum
toE'Object :: Text -> P.Either String E'Object
toE'Object = \case
  "list" -> P.Right E'Object'List
  s -> P.Left $ "toE'Object: enum parse failure: " P.++ P.show s


-- ** E'Object10

-- | Enum of 'Text'
data E'Object10
  = E'Object10'Assistant_deleted -- ^ @"assistant.deleted"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Object10 where toJSON = A.toJSON . fromE'Object10
instance A.FromJSON E'Object10 where parseJSON o = P.either P.fail (pure . P.id) . toE'Object10 =<< A.parseJSON o
instance WH.ToHttpApiData E'Object10 where toQueryParam = WH.toQueryParam . fromE'Object10
instance WH.FromHttpApiData E'Object10 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Object10
instance MimeRender MimeMultipartFormData E'Object10 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Object10' enum
fromE'Object10 :: E'Object10 -> Text
fromE'Object10 = \case
  E'Object10'Assistant_deleted -> "assistant.deleted"

-- | parse 'E'Object10' enum
toE'Object10 :: Text -> P.Either String E'Object10
toE'Object10 = \case
  "assistant.deleted" -> P.Right E'Object10'Assistant_deleted
  s -> P.Left $ "toE'Object10: enum parse failure: " P.++ P.show s


-- ** E'Object11

-- | Enum of 'Text' .
-- The object type, which is always `thread.run`.
data E'Object11
  = E'Object11'Thread_run -- ^ @"thread.run"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Object11 where toJSON = A.toJSON . fromE'Object11
instance A.FromJSON E'Object11 where parseJSON o = P.either P.fail (pure . P.id) . toE'Object11 =<< A.parseJSON o
instance WH.ToHttpApiData E'Object11 where toQueryParam = WH.toQueryParam . fromE'Object11
instance WH.FromHttpApiData E'Object11 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Object11
instance MimeRender MimeMultipartFormData E'Object11 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Object11' enum
fromE'Object11 :: E'Object11 -> Text
fromE'Object11 = \case
  E'Object11'Thread_run -> "thread.run"

-- | parse 'E'Object11' enum
toE'Object11 :: Text -> P.Either String E'Object11
toE'Object11 = \case
  "thread.run" -> P.Right E'Object11'Thread_run
  s -> P.Left $ "toE'Object11: enum parse failure: " P.++ P.show s


-- ** E'Object12

-- | Enum of 'Text' .
-- The object type, which is always `thread`.
data E'Object12
  = E'Object12'Thread -- ^ @"thread"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Object12 where toJSON = A.toJSON . fromE'Object12
instance A.FromJSON E'Object12 where parseJSON o = P.either P.fail (pure . P.id) . toE'Object12 =<< A.parseJSON o
instance WH.ToHttpApiData E'Object12 where toQueryParam = WH.toQueryParam . fromE'Object12
instance WH.FromHttpApiData E'Object12 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Object12
instance MimeRender MimeMultipartFormData E'Object12 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Object12' enum
fromE'Object12 :: E'Object12 -> Text
fromE'Object12 = \case
  E'Object12'Thread -> "thread"

-- | parse 'E'Object12' enum
toE'Object12 :: Text -> P.Either String E'Object12
toE'Object12 = \case
  "thread" -> P.Right E'Object12'Thread
  s -> P.Left $ "toE'Object12: enum parse failure: " P.++ P.show s


-- ** E'Object13

-- | Enum of 'Text'
data E'Object13
  = E'Object13'Thread_deleted -- ^ @"thread.deleted"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Object13 where toJSON = A.toJSON . fromE'Object13
instance A.FromJSON E'Object13 where parseJSON o = P.either P.fail (pure . P.id) . toE'Object13 =<< A.parseJSON o
instance WH.ToHttpApiData E'Object13 where toQueryParam = WH.toQueryParam . fromE'Object13
instance WH.FromHttpApiData E'Object13 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Object13
instance MimeRender MimeMultipartFormData E'Object13 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Object13' enum
fromE'Object13 :: E'Object13 -> Text
fromE'Object13 = \case
  E'Object13'Thread_deleted -> "thread.deleted"

-- | parse 'E'Object13' enum
toE'Object13 :: Text -> P.Either String E'Object13
toE'Object13 = \case
  "thread.deleted" -> P.Right E'Object13'Thread_deleted
  s -> P.Left $ "toE'Object13: enum parse failure: " P.++ P.show s


-- ** E'Object14

-- | Enum of 'Text' .
-- The object type, which is always `thread.message`.
data E'Object14
  = E'Object14'Thread_message -- ^ @"thread.message"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Object14 where toJSON = A.toJSON . fromE'Object14
instance A.FromJSON E'Object14 where parseJSON o = P.either P.fail (pure . P.id) . toE'Object14 =<< A.parseJSON o
instance WH.ToHttpApiData E'Object14 where toQueryParam = WH.toQueryParam . fromE'Object14
instance WH.FromHttpApiData E'Object14 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Object14
instance MimeRender MimeMultipartFormData E'Object14 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Object14' enum
fromE'Object14 :: E'Object14 -> Text
fromE'Object14 = \case
  E'Object14'Thread_message -> "thread.message"

-- | parse 'E'Object14' enum
toE'Object14 :: Text -> P.Either String E'Object14
toE'Object14 = \case
  "thread.message" -> P.Right E'Object14'Thread_message
  s -> P.Left $ "toE'Object14: enum parse failure: " P.++ P.show s


-- ** E'Object15

-- | Enum of 'Text'
data E'Object15
  = E'Object15'Thread_message_deleted -- ^ @"thread.message.deleted"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Object15 where toJSON = A.toJSON . fromE'Object15
instance A.FromJSON E'Object15 where parseJSON o = P.either P.fail (pure . P.id) . toE'Object15 =<< A.parseJSON o
instance WH.ToHttpApiData E'Object15 where toQueryParam = WH.toQueryParam . fromE'Object15
instance WH.FromHttpApiData E'Object15 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Object15
instance MimeRender MimeMultipartFormData E'Object15 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Object15' enum
fromE'Object15 :: E'Object15 -> Text
fromE'Object15 = \case
  E'Object15'Thread_message_deleted -> "thread.message.deleted"

-- | parse 'E'Object15' enum
toE'Object15 :: Text -> P.Either String E'Object15
toE'Object15 = \case
  "thread.message.deleted" -> P.Right E'Object15'Thread_message_deleted
  s -> P.Left $ "toE'Object15: enum parse failure: " P.++ P.show s


-- ** E'Object16

-- | Enum of 'Text' .
-- The object type, which is always `thread.run.step`.
data E'Object16
  = E'Object16'Thread_run_step -- ^ @"thread.run.step"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Object16 where toJSON = A.toJSON . fromE'Object16
instance A.FromJSON E'Object16 where parseJSON o = P.either P.fail (pure . P.id) . toE'Object16 =<< A.parseJSON o
instance WH.ToHttpApiData E'Object16 where toQueryParam = WH.toQueryParam . fromE'Object16
instance WH.FromHttpApiData E'Object16 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Object16
instance MimeRender MimeMultipartFormData E'Object16 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Object16' enum
fromE'Object16 :: E'Object16 -> Text
fromE'Object16 = \case
  E'Object16'Thread_run_step -> "thread.run.step"

-- | parse 'E'Object16' enum
toE'Object16 :: Text -> P.Either String E'Object16
toE'Object16 = \case
  "thread.run.step" -> P.Right E'Object16'Thread_run_step
  s -> P.Left $ "toE'Object16: enum parse failure: " P.++ P.show s


-- ** E'Object17

-- | Enum of 'Text' .
-- The object type, which is always `assistant.file`.
data E'Object17
  = E'Object17'Assistant_file -- ^ @"assistant.file"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Object17 where toJSON = A.toJSON . fromE'Object17
instance A.FromJSON E'Object17 where parseJSON o = P.either P.fail (pure . P.id) . toE'Object17 =<< A.parseJSON o
instance WH.ToHttpApiData E'Object17 where toQueryParam = WH.toQueryParam . fromE'Object17
instance WH.FromHttpApiData E'Object17 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Object17
instance MimeRender MimeMultipartFormData E'Object17 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Object17' enum
fromE'Object17 :: E'Object17 -> Text
fromE'Object17 = \case
  E'Object17'Assistant_file -> "assistant.file"

-- | parse 'E'Object17' enum
toE'Object17 :: Text -> P.Either String E'Object17
toE'Object17 = \case
  "assistant.file" -> P.Right E'Object17'Assistant_file
  s -> P.Left $ "toE'Object17: enum parse failure: " P.++ P.show s


-- ** E'Object18

-- | Enum of 'Text'
data E'Object18
  = E'Object18'Assistant_file_deleted -- ^ @"assistant.file.deleted"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Object18 where toJSON = A.toJSON . fromE'Object18
instance A.FromJSON E'Object18 where parseJSON o = P.either P.fail (pure . P.id) . toE'Object18 =<< A.parseJSON o
instance WH.ToHttpApiData E'Object18 where toQueryParam = WH.toQueryParam . fromE'Object18
instance WH.FromHttpApiData E'Object18 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Object18
instance MimeRender MimeMultipartFormData E'Object18 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Object18' enum
fromE'Object18 :: E'Object18 -> Text
fromE'Object18 = \case
  E'Object18'Assistant_file_deleted -> "assistant.file.deleted"

-- | parse 'E'Object18' enum
toE'Object18 :: Text -> P.Either String E'Object18
toE'Object18 = \case
  "assistant.file.deleted" -> P.Right E'Object18'Assistant_file_deleted
  s -> P.Left $ "toE'Object18: enum parse failure: " P.++ P.show s


-- ** E'Object19

-- | Enum of 'Text' .
-- The object type, which is always `thread.message.file`.
data E'Object19
  = E'Object19'Thread_message_file -- ^ @"thread.message.file"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Object19 where toJSON = A.toJSON . fromE'Object19
instance A.FromJSON E'Object19 where parseJSON o = P.either P.fail (pure . P.id) . toE'Object19 =<< A.parseJSON o
instance WH.ToHttpApiData E'Object19 where toQueryParam = WH.toQueryParam . fromE'Object19
instance WH.FromHttpApiData E'Object19 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Object19
instance MimeRender MimeMultipartFormData E'Object19 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Object19' enum
fromE'Object19 :: E'Object19 -> Text
fromE'Object19 = \case
  E'Object19'Thread_message_file -> "thread.message.file"

-- | parse 'E'Object19' enum
toE'Object19 :: Text -> P.Either String E'Object19
toE'Object19 = \case
  "thread.message.file" -> P.Right E'Object19'Thread_message_file
  s -> P.Left $ "toE'Object19: enum parse failure: " P.++ P.show s


-- ** E'Object2

-- | Enum of 'Text' .
-- The object type, which is always \"text_completion\"
data E'Object2
  = E'Object2'Text_completion -- ^ @"text_completion"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Object2 where toJSON = A.toJSON . fromE'Object2
instance A.FromJSON E'Object2 where parseJSON o = P.either P.fail (pure . P.id) . toE'Object2 =<< A.parseJSON o
instance WH.ToHttpApiData E'Object2 where toQueryParam = WH.toQueryParam . fromE'Object2
instance WH.FromHttpApiData E'Object2 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Object2
instance MimeRender MimeMultipartFormData E'Object2 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Object2' enum
fromE'Object2 :: E'Object2 -> Text
fromE'Object2 = \case
  E'Object2'Text_completion -> "text_completion"

-- | parse 'E'Object2' enum
toE'Object2 :: Text -> P.Either String E'Object2
toE'Object2 = \case
  "text_completion" -> P.Right E'Object2'Text_completion
  s -> P.Left $ "toE'Object2: enum parse failure: " P.++ P.show s


-- ** E'Object3

-- | Enum of 'Text' .
-- The object type, which is always `chat.completion`.
data E'Object3
  = E'Object3'Chat_completion -- ^ @"chat.completion"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Object3 where toJSON = A.toJSON . fromE'Object3
instance A.FromJSON E'Object3 where parseJSON o = P.either P.fail (pure . P.id) . toE'Object3 =<< A.parseJSON o
instance WH.ToHttpApiData E'Object3 where toQueryParam = WH.toQueryParam . fromE'Object3
instance WH.FromHttpApiData E'Object3 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Object3
instance MimeRender MimeMultipartFormData E'Object3 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Object3' enum
fromE'Object3 :: E'Object3 -> Text
fromE'Object3 = \case
  E'Object3'Chat_completion -> "chat.completion"

-- | parse 'E'Object3' enum
toE'Object3 :: Text -> P.Either String E'Object3
toE'Object3 = \case
  "chat.completion" -> P.Right E'Object3'Chat_completion
  s -> P.Left $ "toE'Object3: enum parse failure: " P.++ P.show s


-- ** E'Object4

-- | Enum of 'Text' .
-- The object type, which is always `chat.completion.chunk`.
data E'Object4
  = E'Object4'Chat_completion_chunk -- ^ @"chat.completion.chunk"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Object4 where toJSON = A.toJSON . fromE'Object4
instance A.FromJSON E'Object4 where parseJSON o = P.either P.fail (pure . P.id) . toE'Object4 =<< A.parseJSON o
instance WH.ToHttpApiData E'Object4 where toQueryParam = WH.toQueryParam . fromE'Object4
instance WH.FromHttpApiData E'Object4 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Object4
instance MimeRender MimeMultipartFormData E'Object4 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Object4' enum
fromE'Object4 :: E'Object4 -> Text
fromE'Object4 = \case
  E'Object4'Chat_completion_chunk -> "chat.completion.chunk"

-- | parse 'E'Object4' enum
toE'Object4 :: Text -> P.Either String E'Object4
toE'Object4 = \case
  "chat.completion.chunk" -> P.Right E'Object4'Chat_completion_chunk
  s -> P.Left $ "toE'Object4: enum parse failure: " P.++ P.show s


-- ** E'Object5

-- | Enum of 'Text'
data E'Object5
  = E'Object5'File -- ^ @"file"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Object5 where toJSON = A.toJSON . fromE'Object5
instance A.FromJSON E'Object5 where parseJSON o = P.either P.fail (pure . P.id) . toE'Object5 =<< A.parseJSON o
instance WH.ToHttpApiData E'Object5 where toQueryParam = WH.toQueryParam . fromE'Object5
instance WH.FromHttpApiData E'Object5 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Object5
instance MimeRender MimeMultipartFormData E'Object5 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Object5' enum
fromE'Object5 :: E'Object5 -> Text
fromE'Object5 = \case
  E'Object5'File -> "file"

-- | parse 'E'Object5' enum
toE'Object5 :: Text -> P.Either String E'Object5
toE'Object5 = \case
  "file" -> P.Right E'Object5'File
  s -> P.Left $ "toE'Object5: enum parse failure: " P.++ P.show s


-- ** E'Object6

-- | Enum of 'Text' .
-- The object type, which is always \"model\".
data E'Object6
  = E'Object6'Model -- ^ @"model"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Object6 where toJSON = A.toJSON . fromE'Object6
instance A.FromJSON E'Object6 where parseJSON o = P.either P.fail (pure . P.id) . toE'Object6 =<< A.parseJSON o
instance WH.ToHttpApiData E'Object6 where toQueryParam = WH.toQueryParam . fromE'Object6
instance WH.FromHttpApiData E'Object6 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Object6
instance MimeRender MimeMultipartFormData E'Object6 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Object6' enum
fromE'Object6 :: E'Object6 -> Text
fromE'Object6 = \case
  E'Object6'Model -> "model"

-- | parse 'E'Object6' enum
toE'Object6 :: Text -> P.Either String E'Object6
toE'Object6 = \case
  "model" -> P.Right E'Object6'Model
  s -> P.Left $ "toE'Object6: enum parse failure: " P.++ P.show s


-- ** E'Object7

-- | Enum of 'Text' .
-- The object type, which is always \"embedding\".
data E'Object7
  = E'Object7'Embedding -- ^ @"embedding"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Object7 where toJSON = A.toJSON . fromE'Object7
instance A.FromJSON E'Object7 where parseJSON o = P.either P.fail (pure . P.id) . toE'Object7 =<< A.parseJSON o
instance WH.ToHttpApiData E'Object7 where toQueryParam = WH.toQueryParam . fromE'Object7
instance WH.FromHttpApiData E'Object7 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Object7
instance MimeRender MimeMultipartFormData E'Object7 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Object7' enum
fromE'Object7 :: E'Object7 -> Text
fromE'Object7 = \case
  E'Object7'Embedding -> "embedding"

-- | parse 'E'Object7' enum
toE'Object7 :: Text -> P.Either String E'Object7
toE'Object7 = \case
  "embedding" -> P.Right E'Object7'Embedding
  s -> P.Left $ "toE'Object7: enum parse failure: " P.++ P.show s


-- ** E'Object8

-- | Enum of 'Text' .
-- The object type, which is always \"fine_tuning.job\".
data E'Object8
  = E'Object8'Fine_tuning_job -- ^ @"fine_tuning.job"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Object8 where toJSON = A.toJSON . fromE'Object8
instance A.FromJSON E'Object8 where parseJSON o = P.either P.fail (pure . P.id) . toE'Object8 =<< A.parseJSON o
instance WH.ToHttpApiData E'Object8 where toQueryParam = WH.toQueryParam . fromE'Object8
instance WH.FromHttpApiData E'Object8 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Object8
instance MimeRender MimeMultipartFormData E'Object8 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Object8' enum
fromE'Object8 :: E'Object8 -> Text
fromE'Object8 = \case
  E'Object8'Fine_tuning_job -> "fine_tuning.job"

-- | parse 'E'Object8' enum
toE'Object8 :: Text -> P.Either String E'Object8
toE'Object8 = \case
  "fine_tuning.job" -> P.Right E'Object8'Fine_tuning_job
  s -> P.Left $ "toE'Object8: enum parse failure: " P.++ P.show s


-- ** E'Object9

-- | Enum of 'Text'
data E'Object9
  = E'Object9'Fine_tuning_job_event -- ^ @"fine_tuning.job.event"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Object9 where toJSON = A.toJSON . fromE'Object9
instance A.FromJSON E'Object9 where parseJSON o = P.either P.fail (pure . P.id) . toE'Object9 =<< A.parseJSON o
instance WH.ToHttpApiData E'Object9 where toQueryParam = WH.toQueryParam . fromE'Object9
instance WH.FromHttpApiData E'Object9 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Object9
instance MimeRender MimeMultipartFormData E'Object9 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Object9' enum
fromE'Object9 :: E'Object9 -> Text
fromE'Object9 = \case
  E'Object9'Fine_tuning_job_event -> "fine_tuning.job.event"

-- | parse 'E'Object9' enum
toE'Object9 :: Text -> P.Either String E'Object9
toE'Object9 = \case
  "fine_tuning.job.event" -> P.Right E'Object9'Fine_tuning_job_event
  s -> P.Left $ "toE'Object9: enum parse failure: " P.++ P.show s


-- ** E'OneOf0

-- | Enum of 'Text' .
-- `none` means the model will not call a function and instead generates a message. `auto` means the model can pick between generating a message or calling a function. 
data E'OneOf0
  = E'OneOf0'None -- ^ @"none"@
  | E'OneOf0'Auto -- ^ @"auto"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'OneOf0 where toJSON = A.toJSON . fromE'OneOf0
instance A.FromJSON E'OneOf0 where parseJSON o = P.either P.fail (pure . P.id) . toE'OneOf0 =<< A.parseJSON o
instance WH.ToHttpApiData E'OneOf0 where toQueryParam = WH.toQueryParam . fromE'OneOf0
instance WH.FromHttpApiData E'OneOf0 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'OneOf0
instance MimeRender MimeMultipartFormData E'OneOf0 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'OneOf0' enum
fromE'OneOf0 :: E'OneOf0 -> Text
fromE'OneOf0 = \case
  E'OneOf0'None -> "none"
  E'OneOf0'Auto -> "auto"

-- | parse 'E'OneOf0' enum
toE'OneOf0 :: Text -> P.Either String E'OneOf0
toE'OneOf0 = \case
  "none" -> P.Right E'OneOf0'None
  "auto" -> P.Right E'OneOf0'Auto
  s -> P.Left $ "toE'OneOf0: enum parse failure: " P.++ P.show s


-- ** E'OneOf1

-- | Enum of 'Text'
data E'OneOf1
  = E'OneOf1'Auto -- ^ @"auto"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'OneOf1 where toJSON = A.toJSON . fromE'OneOf1
instance A.FromJSON E'OneOf1 where parseJSON o = P.either P.fail (pure . P.id) . toE'OneOf1 =<< A.parseJSON o
instance WH.ToHttpApiData E'OneOf1 where toQueryParam = WH.toQueryParam . fromE'OneOf1
instance WH.FromHttpApiData E'OneOf1 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'OneOf1
instance MimeRender MimeMultipartFormData E'OneOf1 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'OneOf1' enum
fromE'OneOf1 :: E'OneOf1 -> Text
fromE'OneOf1 = \case
  E'OneOf1'Auto -> "auto"

-- | parse 'E'OneOf1' enum
toE'OneOf1 :: Text -> P.Either String E'OneOf1
toE'OneOf1 = \case
  "auto" -> P.Right E'OneOf1'Auto
  s -> P.Left $ "toE'OneOf1: enum parse failure: " P.++ P.show s


-- ** E'Order

-- | Enum of 'Text'
data E'Order
  = E'Order'Asc -- ^ @"asc"@
  | E'Order'Desc -- ^ @"desc"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Order where toJSON = A.toJSON . fromE'Order
instance A.FromJSON E'Order where parseJSON o = P.either P.fail (pure . P.id) . toE'Order =<< A.parseJSON o
instance WH.ToHttpApiData E'Order where toQueryParam = WH.toQueryParam . fromE'Order
instance WH.FromHttpApiData E'Order where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Order
instance MimeRender MimeMultipartFormData E'Order where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Order' enum
fromE'Order :: E'Order -> Text
fromE'Order = \case
  E'Order'Asc -> "asc"
  E'Order'Desc -> "desc"

-- | parse 'E'Order' enum
toE'Order :: Text -> P.Either String E'Order
toE'Order = \case
  "asc" -> P.Right E'Order'Asc
  "desc" -> P.Right E'Order'Desc
  s -> P.Left $ "toE'Order: enum parse failure: " P.++ P.show s


-- ** E'Purpose

-- | Enum of 'Text' .
-- The intended purpose of the file. Supported values are `fine-tune`, `fine-tune-results`, `assistants`, and `assistants_output`.
data E'Purpose
  = E'Purpose'Fine_tune -- ^ @"fine-tune"@
  | E'Purpose'Fine_tune_results -- ^ @"fine-tune-results"@
  | E'Purpose'Assistants -- ^ @"assistants"@
  | E'Purpose'Assistants_output -- ^ @"assistants_output"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Purpose where toJSON = A.toJSON . fromE'Purpose
instance A.FromJSON E'Purpose where parseJSON o = P.either P.fail (pure . P.id) . toE'Purpose =<< A.parseJSON o
instance WH.ToHttpApiData E'Purpose where toQueryParam = WH.toQueryParam . fromE'Purpose
instance WH.FromHttpApiData E'Purpose where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Purpose
instance MimeRender MimeMultipartFormData E'Purpose where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Purpose' enum
fromE'Purpose :: E'Purpose -> Text
fromE'Purpose = \case
  E'Purpose'Fine_tune -> "fine-tune"
  E'Purpose'Fine_tune_results -> "fine-tune-results"
  E'Purpose'Assistants -> "assistants"
  E'Purpose'Assistants_output -> "assistants_output"

-- | parse 'E'Purpose' enum
toE'Purpose :: Text -> P.Either String E'Purpose
toE'Purpose = \case
  "fine-tune" -> P.Right E'Purpose'Fine_tune
  "fine-tune-results" -> P.Right E'Purpose'Fine_tune_results
  "assistants" -> P.Right E'Purpose'Assistants
  "assistants_output" -> P.Right E'Purpose'Assistants_output
  s -> P.Left $ "toE'Purpose: enum parse failure: " P.++ P.show s


-- ** E'Purpose2

-- | Enum of 'Text' .
-- The intended purpose of the uploaded file.  Use \"fine-tune\" for [Fine-tuning](/docs/api-reference/fine-tuning) and \"assistants\" for [Assistants](/docs/api-reference/assistants) and [Messages](/docs/api-reference/messages). This allows us to validate the format of the uploaded file is correct for fine-tuning. 
data E'Purpose2
  = E'Purpose2'Fine_tune -- ^ @"fine-tune"@
  | E'Purpose2'Assistants -- ^ @"assistants"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Purpose2 where toJSON = A.toJSON . fromE'Purpose2
instance A.FromJSON E'Purpose2 where parseJSON o = P.either P.fail (pure . P.id) . toE'Purpose2 =<< A.parseJSON o
instance WH.ToHttpApiData E'Purpose2 where toQueryParam = WH.toQueryParam . fromE'Purpose2
instance WH.FromHttpApiData E'Purpose2 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Purpose2
instance MimeRender MimeMultipartFormData E'Purpose2 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Purpose2' enum
fromE'Purpose2 :: E'Purpose2 -> Text
fromE'Purpose2 = \case
  E'Purpose2'Fine_tune -> "fine-tune"
  E'Purpose2'Assistants -> "assistants"

-- | parse 'E'Purpose2' enum
toE'Purpose2 :: Text -> P.Either String E'Purpose2
toE'Purpose2 = \case
  "fine-tune" -> P.Right E'Purpose2'Fine_tune
  "assistants" -> P.Right E'Purpose2'Assistants
  s -> P.Left $ "toE'Purpose2: enum parse failure: " P.++ P.show s


-- ** E'Quality

-- | Enum of 'Text' .
-- The quality of the image that will be generated. `hd` creates images with finer details and greater consistency across the image. This param is only supported for `dall-e-3`.
data E'Quality
  = E'Quality'Standard -- ^ @"standard"@
  | E'Quality'Hd -- ^ @"hd"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Quality where toJSON = A.toJSON . fromE'Quality
instance A.FromJSON E'Quality where parseJSON o = P.either P.fail (pure . P.id) . toE'Quality =<< A.parseJSON o
instance WH.ToHttpApiData E'Quality where toQueryParam = WH.toQueryParam . fromE'Quality
instance WH.FromHttpApiData E'Quality where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Quality
instance MimeRender MimeMultipartFormData E'Quality where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Quality' enum
fromE'Quality :: E'Quality -> Text
fromE'Quality = \case
  E'Quality'Standard -> "standard"
  E'Quality'Hd -> "hd"

-- | parse 'E'Quality' enum
toE'Quality :: Text -> P.Either String E'Quality
toE'Quality = \case
  "standard" -> P.Right E'Quality'Standard
  "hd" -> P.Right E'Quality'Hd
  s -> P.Left $ "toE'Quality: enum parse failure: " P.++ P.show s


-- ** E'ResponseFormat

-- | Enum of 'Text' .
-- The format in which the generated images are returned. Must be one of `url` or `b64_json`. URLs are only valid for 60 minutes after the image has been generated.
data E'ResponseFormat
  = E'ResponseFormat'Url -- ^ @"url"@
  | E'ResponseFormat'B64_json -- ^ @"b64_json"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'ResponseFormat where toJSON = A.toJSON . fromE'ResponseFormat
instance A.FromJSON E'ResponseFormat where parseJSON o = P.either P.fail (pure . P.id) . toE'ResponseFormat =<< A.parseJSON o
instance WH.ToHttpApiData E'ResponseFormat where toQueryParam = WH.toQueryParam . fromE'ResponseFormat
instance WH.FromHttpApiData E'ResponseFormat where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'ResponseFormat
instance MimeRender MimeMultipartFormData E'ResponseFormat where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'ResponseFormat' enum
fromE'ResponseFormat :: E'ResponseFormat -> Text
fromE'ResponseFormat = \case
  E'ResponseFormat'Url -> "url"
  E'ResponseFormat'B64_json -> "b64_json"

-- | parse 'E'ResponseFormat' enum
toE'ResponseFormat :: Text -> P.Either String E'ResponseFormat
toE'ResponseFormat = \case
  "url" -> P.Right E'ResponseFormat'Url
  "b64_json" -> P.Right E'ResponseFormat'B64_json
  s -> P.Left $ "toE'ResponseFormat: enum parse failure: " P.++ P.show s


-- ** E'ResponseFormat2

-- | Enum of 'Text' .
-- The format to audio in. Supported formats are `mp3`, `opus`, `aac`, `flac`, `wav`, and `pcm`.
data E'ResponseFormat2
  = E'ResponseFormat2'Mp3 -- ^ @"mp3"@
  | E'ResponseFormat2'Opus -- ^ @"opus"@
  | E'ResponseFormat2'Aac -- ^ @"aac"@
  | E'ResponseFormat2'Flac -- ^ @"flac"@
  | E'ResponseFormat2'Wav -- ^ @"wav"@
  | E'ResponseFormat2'Pcm -- ^ @"pcm"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'ResponseFormat2 where toJSON = A.toJSON . fromE'ResponseFormat2
instance A.FromJSON E'ResponseFormat2 where parseJSON o = P.either P.fail (pure . P.id) . toE'ResponseFormat2 =<< A.parseJSON o
instance WH.ToHttpApiData E'ResponseFormat2 where toQueryParam = WH.toQueryParam . fromE'ResponseFormat2
instance WH.FromHttpApiData E'ResponseFormat2 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'ResponseFormat2
instance MimeRender MimeMultipartFormData E'ResponseFormat2 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'ResponseFormat2' enum
fromE'ResponseFormat2 :: E'ResponseFormat2 -> Text
fromE'ResponseFormat2 = \case
  E'ResponseFormat2'Mp3 -> "mp3"
  E'ResponseFormat2'Opus -> "opus"
  E'ResponseFormat2'Aac -> "aac"
  E'ResponseFormat2'Flac -> "flac"
  E'ResponseFormat2'Wav -> "wav"
  E'ResponseFormat2'Pcm -> "pcm"

-- | parse 'E'ResponseFormat2' enum
toE'ResponseFormat2 :: Text -> P.Either String E'ResponseFormat2
toE'ResponseFormat2 = \case
  "mp3" -> P.Right E'ResponseFormat2'Mp3
  "opus" -> P.Right E'ResponseFormat2'Opus
  "aac" -> P.Right E'ResponseFormat2'Aac
  "flac" -> P.Right E'ResponseFormat2'Flac
  "wav" -> P.Right E'ResponseFormat2'Wav
  "pcm" -> P.Right E'ResponseFormat2'Pcm
  s -> P.Left $ "toE'ResponseFormat2: enum parse failure: " P.++ P.show s


-- ** E'ResponseFormat3

-- | Enum of 'Text' .
-- The format of the transcript output, in one of these options: `json`, `text`, `srt`, `verbose_json`, or `vtt`. 
data E'ResponseFormat3
  = E'ResponseFormat3'Json -- ^ @"json"@
  | E'ResponseFormat3'Text -- ^ @"text"@
  | E'ResponseFormat3'Srt -- ^ @"srt"@
  | E'ResponseFormat3'Verbose_json -- ^ @"verbose_json"@
  | E'ResponseFormat3'Vtt -- ^ @"vtt"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'ResponseFormat3 where toJSON = A.toJSON . fromE'ResponseFormat3
instance A.FromJSON E'ResponseFormat3 where parseJSON o = P.either P.fail (pure . P.id) . toE'ResponseFormat3 =<< A.parseJSON o
instance WH.ToHttpApiData E'ResponseFormat3 where toQueryParam = WH.toQueryParam . fromE'ResponseFormat3
instance WH.FromHttpApiData E'ResponseFormat3 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'ResponseFormat3
instance MimeRender MimeMultipartFormData E'ResponseFormat3 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'ResponseFormat3' enum
fromE'ResponseFormat3 :: E'ResponseFormat3 -> Text
fromE'ResponseFormat3 = \case
  E'ResponseFormat3'Json -> "json"
  E'ResponseFormat3'Text -> "text"
  E'ResponseFormat3'Srt -> "srt"
  E'ResponseFormat3'Verbose_json -> "verbose_json"
  E'ResponseFormat3'Vtt -> "vtt"

-- | parse 'E'ResponseFormat3' enum
toE'ResponseFormat3 :: Text -> P.Either String E'ResponseFormat3
toE'ResponseFormat3 = \case
  "json" -> P.Right E'ResponseFormat3'Json
  "text" -> P.Right E'ResponseFormat3'Text
  "srt" -> P.Right E'ResponseFormat3'Srt
  "verbose_json" -> P.Right E'ResponseFormat3'Verbose_json
  "vtt" -> P.Right E'ResponseFormat3'Vtt
  s -> P.Left $ "toE'ResponseFormat3: enum parse failure: " P.++ P.show s


-- ** E'Role

-- | Enum of 'Text' .
-- The role of the messages author, in this case `function`.
data E'Role
  = E'Role'Function -- ^ @"function"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Role where toJSON = A.toJSON . fromE'Role
instance A.FromJSON E'Role where parseJSON o = P.either P.fail (pure . P.id) . toE'Role =<< A.parseJSON o
instance WH.ToHttpApiData E'Role where toQueryParam = WH.toQueryParam . fromE'Role
instance WH.FromHttpApiData E'Role where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Role
instance MimeRender MimeMultipartFormData E'Role where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Role' enum
fromE'Role :: E'Role -> Text
fromE'Role = \case
  E'Role'Function -> "function"

-- | parse 'E'Role' enum
toE'Role :: Text -> P.Either String E'Role
toE'Role = \case
  "function" -> P.Right E'Role'Function
  s -> P.Left $ "toE'Role: enum parse failure: " P.++ P.show s


-- ** E'Role2

-- | Enum of 'Text' .
-- The role of the messages author, in this case `system`.
data E'Role2
  = E'Role2'System -- ^ @"system"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Role2 where toJSON = A.toJSON . fromE'Role2
instance A.FromJSON E'Role2 where parseJSON o = P.either P.fail (pure . P.id) . toE'Role2 =<< A.parseJSON o
instance WH.ToHttpApiData E'Role2 where toQueryParam = WH.toQueryParam . fromE'Role2
instance WH.FromHttpApiData E'Role2 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Role2
instance MimeRender MimeMultipartFormData E'Role2 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Role2' enum
fromE'Role2 :: E'Role2 -> Text
fromE'Role2 = \case
  E'Role2'System -> "system"

-- | parse 'E'Role2' enum
toE'Role2 :: Text -> P.Either String E'Role2
toE'Role2 = \case
  "system" -> P.Right E'Role2'System
  s -> P.Left $ "toE'Role2: enum parse failure: " P.++ P.show s


-- ** E'Role3

-- | Enum of 'Text' .
-- The role of the messages author, in this case `user`.
data E'Role3
  = E'Role3'User -- ^ @"user"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Role3 where toJSON = A.toJSON . fromE'Role3
instance A.FromJSON E'Role3 where parseJSON o = P.either P.fail (pure . P.id) . toE'Role3 =<< A.parseJSON o
instance WH.ToHttpApiData E'Role3 where toQueryParam = WH.toQueryParam . fromE'Role3
instance WH.FromHttpApiData E'Role3 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Role3
instance MimeRender MimeMultipartFormData E'Role3 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Role3' enum
fromE'Role3 :: E'Role3 -> Text
fromE'Role3 = \case
  E'Role3'User -> "user"

-- | parse 'E'Role3' enum
toE'Role3 :: Text -> P.Either String E'Role3
toE'Role3 = \case
  "user" -> P.Right E'Role3'User
  s -> P.Left $ "toE'Role3: enum parse failure: " P.++ P.show s


-- ** E'Role4

-- | Enum of 'Text' .
-- The role of the messages author, in this case `assistant`.
data E'Role4
  = E'Role4'Assistant -- ^ @"assistant"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Role4 where toJSON = A.toJSON . fromE'Role4
instance A.FromJSON E'Role4 where parseJSON o = P.either P.fail (pure . P.id) . toE'Role4 =<< A.parseJSON o
instance WH.ToHttpApiData E'Role4 where toQueryParam = WH.toQueryParam . fromE'Role4
instance WH.FromHttpApiData E'Role4 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Role4
instance MimeRender MimeMultipartFormData E'Role4 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Role4' enum
fromE'Role4 :: E'Role4 -> Text
fromE'Role4 = \case
  E'Role4'Assistant -> "assistant"

-- | parse 'E'Role4' enum
toE'Role4 :: Text -> P.Either String E'Role4
toE'Role4 = \case
  "assistant" -> P.Right E'Role4'Assistant
  s -> P.Left $ "toE'Role4: enum parse failure: " P.++ P.show s


-- ** E'Role5

-- | Enum of 'Text' .
-- The role of the messages author, in this case `tool`.
data E'Role5
  = E'Role5'Tool -- ^ @"tool"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Role5 where toJSON = A.toJSON . fromE'Role5
instance A.FromJSON E'Role5 where parseJSON o = P.either P.fail (pure . P.id) . toE'Role5 =<< A.parseJSON o
instance WH.ToHttpApiData E'Role5 where toQueryParam = WH.toQueryParam . fromE'Role5
instance WH.FromHttpApiData E'Role5 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Role5
instance MimeRender MimeMultipartFormData E'Role5 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Role5' enum
fromE'Role5 :: E'Role5 -> Text
fromE'Role5 = \case
  E'Role5'Tool -> "tool"

-- | parse 'E'Role5' enum
toE'Role5 :: Text -> P.Either String E'Role5
toE'Role5 = \case
  "tool" -> P.Right E'Role5'Tool
  s -> P.Left $ "toE'Role5: enum parse failure: " P.++ P.show s


-- ** E'Role6

-- | Enum of 'Text' .
-- The role of the author of this message.
data E'Role6
  = E'Role6'System -- ^ @"system"@
  | E'Role6'User -- ^ @"user"@
  | E'Role6'Assistant -- ^ @"assistant"@
  | E'Role6'Tool -- ^ @"tool"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Role6 where toJSON = A.toJSON . fromE'Role6
instance A.FromJSON E'Role6 where parseJSON o = P.either P.fail (pure . P.id) . toE'Role6 =<< A.parseJSON o
instance WH.ToHttpApiData E'Role6 where toQueryParam = WH.toQueryParam . fromE'Role6
instance WH.FromHttpApiData E'Role6 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Role6
instance MimeRender MimeMultipartFormData E'Role6 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Role6' enum
fromE'Role6 :: E'Role6 -> Text
fromE'Role6 = \case
  E'Role6'System -> "system"
  E'Role6'User -> "user"
  E'Role6'Assistant -> "assistant"
  E'Role6'Tool -> "tool"

-- | parse 'E'Role6' enum
toE'Role6 :: Text -> P.Either String E'Role6
toE'Role6 = \case
  "system" -> P.Right E'Role6'System
  "user" -> P.Right E'Role6'User
  "assistant" -> P.Right E'Role6'Assistant
  "tool" -> P.Right E'Role6'Tool
  s -> P.Left $ "toE'Role6: enum parse failure: " P.++ P.show s


-- ** E'Role7

-- | Enum of 'Text' .
-- The entity that produced the message. One of `user` or `assistant`.
data E'Role7
  = E'Role7'User -- ^ @"user"@
  | E'Role7'Assistant -- ^ @"assistant"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Role7 where toJSON = A.toJSON . fromE'Role7
instance A.FromJSON E'Role7 where parseJSON o = P.either P.fail (pure . P.id) . toE'Role7 =<< A.parseJSON o
instance WH.ToHttpApiData E'Role7 where toQueryParam = WH.toQueryParam . fromE'Role7
instance WH.FromHttpApiData E'Role7 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Role7
instance MimeRender MimeMultipartFormData E'Role7 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Role7' enum
fromE'Role7 :: E'Role7 -> Text
fromE'Role7 = \case
  E'Role7'User -> "user"
  E'Role7'Assistant -> "assistant"

-- | parse 'E'Role7' enum
toE'Role7 :: Text -> P.Either String E'Role7
toE'Role7 = \case
  "user" -> P.Right E'Role7'User
  "assistant" -> P.Right E'Role7'Assistant
  s -> P.Left $ "toE'Role7: enum parse failure: " P.++ P.show s


-- ** E'Size

-- | Enum of 'Text' .
-- The size of the generated images. Must be one of `256x256`, `512x512`, or `1024x1024` for `dall-e-2`. Must be one of `1024x1024`, `1792x1024`, or `1024x1792` for `dall-e-3` models.
data E'Size
  = E'Size'256x256 -- ^ @"256x256"@
  | E'Size'512x512 -- ^ @"512x512"@
  | E'Size'1024x1024 -- ^ @"1024x1024"@
  | E'Size'1792x1024 -- ^ @"1792x1024"@
  | E'Size'1024x1792 -- ^ @"1024x1792"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Size where toJSON = A.toJSON . fromE'Size
instance A.FromJSON E'Size where parseJSON o = P.either P.fail (pure . P.id) . toE'Size =<< A.parseJSON o
instance WH.ToHttpApiData E'Size where toQueryParam = WH.toQueryParam . fromE'Size
instance WH.FromHttpApiData E'Size where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Size
instance MimeRender MimeMultipartFormData E'Size where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Size' enum
fromE'Size :: E'Size -> Text
fromE'Size = \case
  E'Size'256x256 -> "256x256"
  E'Size'512x512 -> "512x512"
  E'Size'1024x1024 -> "1024x1024"
  E'Size'1792x1024 -> "1792x1024"
  E'Size'1024x1792 -> "1024x1792"

-- | parse 'E'Size' enum
toE'Size :: Text -> P.Either String E'Size
toE'Size = \case
  "256x256" -> P.Right E'Size'256x256
  "512x512" -> P.Right E'Size'512x512
  "1024x1024" -> P.Right E'Size'1024x1024
  "1792x1024" -> P.Right E'Size'1792x1024
  "1024x1792" -> P.Right E'Size'1024x1792
  s -> P.Left $ "toE'Size: enum parse failure: " P.++ P.show s


-- ** E'Size2

-- | Enum of 'Text' .
-- The size of the generated images. Must be one of `256x256`, `512x512`, or `1024x1024`.
data E'Size2
  = E'Size2'256x256 -- ^ @"256x256"@
  | E'Size2'512x512 -- ^ @"512x512"@
  | E'Size2'1024x1024 -- ^ @"1024x1024"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Size2 where toJSON = A.toJSON . fromE'Size2
instance A.FromJSON E'Size2 where parseJSON o = P.either P.fail (pure . P.id) . toE'Size2 =<< A.parseJSON o
instance WH.ToHttpApiData E'Size2 where toQueryParam = WH.toQueryParam . fromE'Size2
instance WH.FromHttpApiData E'Size2 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Size2
instance MimeRender MimeMultipartFormData E'Size2 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Size2' enum
fromE'Size2 :: E'Size2 -> Text
fromE'Size2 = \case
  E'Size2'256x256 -> "256x256"
  E'Size2'512x512 -> "512x512"
  E'Size2'1024x1024 -> "1024x1024"

-- | parse 'E'Size2' enum
toE'Size2 :: Text -> P.Either String E'Size2
toE'Size2 = \case
  "256x256" -> P.Right E'Size2'256x256
  "512x512" -> P.Right E'Size2'512x512
  "1024x1024" -> P.Right E'Size2'1024x1024
  s -> P.Left $ "toE'Size2: enum parse failure: " P.++ P.show s


-- ** E'Status

-- | Enum of 'Text' .
-- Deprecated. The current status of the file, which can be either `uploaded`, `processed`, or `error`.
data E'Status
  = E'Status'Uploaded -- ^ @"uploaded"@
  | E'Status'Processed -- ^ @"processed"@
  | E'Status'Error -- ^ @"error"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Status where toJSON = A.toJSON . fromE'Status
instance A.FromJSON E'Status where parseJSON o = P.either P.fail (pure . P.id) . toE'Status =<< A.parseJSON o
instance WH.ToHttpApiData E'Status where toQueryParam = WH.toQueryParam . fromE'Status
instance WH.FromHttpApiData E'Status where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Status
instance MimeRender MimeMultipartFormData E'Status where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Status' enum
fromE'Status :: E'Status -> Text
fromE'Status = \case
  E'Status'Uploaded -> "uploaded"
  E'Status'Processed -> "processed"
  E'Status'Error -> "error"

-- | parse 'E'Status' enum
toE'Status :: Text -> P.Either String E'Status
toE'Status = \case
  "uploaded" -> P.Right E'Status'Uploaded
  "processed" -> P.Right E'Status'Processed
  "error" -> P.Right E'Status'Error
  s -> P.Left $ "toE'Status: enum parse failure: " P.++ P.show s


-- ** E'Status2

-- | Enum of 'Text' .
-- The current status of the fine-tuning job, which can be either `validating_files`, `queued`, `running`, `succeeded`, `failed`, or `cancelled`.
data E'Status2
  = E'Status2'Validating_files -- ^ @"validating_files"@
  | E'Status2'Queued -- ^ @"queued"@
  | E'Status2'Running -- ^ @"running"@
  | E'Status2'Succeeded -- ^ @"succeeded"@
  | E'Status2'Failed -- ^ @"failed"@
  | E'Status2'Cancelled -- ^ @"cancelled"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Status2 where toJSON = A.toJSON . fromE'Status2
instance A.FromJSON E'Status2 where parseJSON o = P.either P.fail (pure . P.id) . toE'Status2 =<< A.parseJSON o
instance WH.ToHttpApiData E'Status2 where toQueryParam = WH.toQueryParam . fromE'Status2
instance WH.FromHttpApiData E'Status2 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Status2
instance MimeRender MimeMultipartFormData E'Status2 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Status2' enum
fromE'Status2 :: E'Status2 -> Text
fromE'Status2 = \case
  E'Status2'Validating_files -> "validating_files"
  E'Status2'Queued -> "queued"
  E'Status2'Running -> "running"
  E'Status2'Succeeded -> "succeeded"
  E'Status2'Failed -> "failed"
  E'Status2'Cancelled -> "cancelled"

-- | parse 'E'Status2' enum
toE'Status2 :: Text -> P.Either String E'Status2
toE'Status2 = \case
  "validating_files" -> P.Right E'Status2'Validating_files
  "queued" -> P.Right E'Status2'Queued
  "running" -> P.Right E'Status2'Running
  "succeeded" -> P.Right E'Status2'Succeeded
  "failed" -> P.Right E'Status2'Failed
  "cancelled" -> P.Right E'Status2'Cancelled
  s -> P.Left $ "toE'Status2: enum parse failure: " P.++ P.show s


-- ** E'Status3

-- | Enum of 'Text' .
-- The status of the run, which can be either `queued`, `in_progress`, `requires_action`, `cancelling`, `cancelled`, `failed`, `completed`, or `expired`.
data E'Status3
  = E'Status3'Queued -- ^ @"queued"@
  | E'Status3'In_progress -- ^ @"in_progress"@
  | E'Status3'Requires_action -- ^ @"requires_action"@
  | E'Status3'Cancelling -- ^ @"cancelling"@
  | E'Status3'Cancelled -- ^ @"cancelled"@
  | E'Status3'Failed -- ^ @"failed"@
  | E'Status3'Completed -- ^ @"completed"@
  | E'Status3'Expired -- ^ @"expired"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Status3 where toJSON = A.toJSON . fromE'Status3
instance A.FromJSON E'Status3 where parseJSON o = P.either P.fail (pure . P.id) . toE'Status3 =<< A.parseJSON o
instance WH.ToHttpApiData E'Status3 where toQueryParam = WH.toQueryParam . fromE'Status3
instance WH.FromHttpApiData E'Status3 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Status3
instance MimeRender MimeMultipartFormData E'Status3 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Status3' enum
fromE'Status3 :: E'Status3 -> Text
fromE'Status3 = \case
  E'Status3'Queued -> "queued"
  E'Status3'In_progress -> "in_progress"
  E'Status3'Requires_action -> "requires_action"
  E'Status3'Cancelling -> "cancelling"
  E'Status3'Cancelled -> "cancelled"
  E'Status3'Failed -> "failed"
  E'Status3'Completed -> "completed"
  E'Status3'Expired -> "expired"

-- | parse 'E'Status3' enum
toE'Status3 :: Text -> P.Either String E'Status3
toE'Status3 = \case
  "queued" -> P.Right E'Status3'Queued
  "in_progress" -> P.Right E'Status3'In_progress
  "requires_action" -> P.Right E'Status3'Requires_action
  "cancelling" -> P.Right E'Status3'Cancelling
  "cancelled" -> P.Right E'Status3'Cancelled
  "failed" -> P.Right E'Status3'Failed
  "completed" -> P.Right E'Status3'Completed
  "expired" -> P.Right E'Status3'Expired
  s -> P.Left $ "toE'Status3: enum parse failure: " P.++ P.show s


-- ** E'Status4

-- | Enum of 'Text' .
-- The status of the run step, which can be either `in_progress`, `cancelled`, `failed`, `completed`, or `expired`.
data E'Status4
  = E'Status4'In_progress -- ^ @"in_progress"@
  | E'Status4'Cancelled -- ^ @"cancelled"@
  | E'Status4'Failed -- ^ @"failed"@
  | E'Status4'Completed -- ^ @"completed"@
  | E'Status4'Expired -- ^ @"expired"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Status4 where toJSON = A.toJSON . fromE'Status4
instance A.FromJSON E'Status4 where parseJSON o = P.either P.fail (pure . P.id) . toE'Status4 =<< A.parseJSON o
instance WH.ToHttpApiData E'Status4 where toQueryParam = WH.toQueryParam . fromE'Status4
instance WH.FromHttpApiData E'Status4 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Status4
instance MimeRender MimeMultipartFormData E'Status4 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Status4' enum
fromE'Status4 :: E'Status4 -> Text
fromE'Status4 = \case
  E'Status4'In_progress -> "in_progress"
  E'Status4'Cancelled -> "cancelled"
  E'Status4'Failed -> "failed"
  E'Status4'Completed -> "completed"
  E'Status4'Expired -> "expired"

-- | parse 'E'Status4' enum
toE'Status4 :: Text -> P.Either String E'Status4
toE'Status4 = \case
  "in_progress" -> P.Right E'Status4'In_progress
  "cancelled" -> P.Right E'Status4'Cancelled
  "failed" -> P.Right E'Status4'Failed
  "completed" -> P.Right E'Status4'Completed
  "expired" -> P.Right E'Status4'Expired
  s -> P.Left $ "toE'Status4: enum parse failure: " P.++ P.show s


-- ** E'Style

-- | Enum of 'Text' .
-- The style of the generated images. Must be one of `vivid` or `natural`. Vivid causes the model to lean towards generating hyper-real and dramatic images. Natural causes the model to produce more natural, less hyper-real looking images. This param is only supported for `dall-e-3`.
data E'Style
  = E'Style'Vivid -- ^ @"vivid"@
  | E'Style'Natural -- ^ @"natural"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Style where toJSON = A.toJSON . fromE'Style
instance A.FromJSON E'Style where parseJSON o = P.either P.fail (pure . P.id) . toE'Style =<< A.parseJSON o
instance WH.ToHttpApiData E'Style where toQueryParam = WH.toQueryParam . fromE'Style
instance WH.FromHttpApiData E'Style where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Style
instance MimeRender MimeMultipartFormData E'Style where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Style' enum
fromE'Style :: E'Style -> Text
fromE'Style = \case
  E'Style'Vivid -> "vivid"
  E'Style'Natural -> "natural"

-- | parse 'E'Style' enum
toE'Style :: Text -> P.Either String E'Style
toE'Style = \case
  "vivid" -> P.Right E'Style'Vivid
  "natural" -> P.Right E'Style'Natural
  s -> P.Left $ "toE'Style: enum parse failure: " P.++ P.show s


-- ** E'TimestampGranularities

-- | Enum of 'Text'
data E'TimestampGranularities
  = E'TimestampGranularities'Word -- ^ @"word"@
  | E'TimestampGranularities'Segment -- ^ @"segment"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'TimestampGranularities where toJSON = A.toJSON . fromE'TimestampGranularities
instance A.FromJSON E'TimestampGranularities where parseJSON o = P.either P.fail (pure . P.id) . toE'TimestampGranularities =<< A.parseJSON o
instance WH.ToHttpApiData E'TimestampGranularities where toQueryParam = WH.toQueryParam . fromE'TimestampGranularities
instance WH.FromHttpApiData E'TimestampGranularities where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'TimestampGranularities
instance MimeRender MimeMultipartFormData E'TimestampGranularities where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'TimestampGranularities' enum
fromE'TimestampGranularities :: E'TimestampGranularities -> Text
fromE'TimestampGranularities = \case
  E'TimestampGranularities'Word -> "word"
  E'TimestampGranularities'Segment -> "segment"

-- | parse 'E'TimestampGranularities' enum
toE'TimestampGranularities :: Text -> P.Either String E'TimestampGranularities
toE'TimestampGranularities = \case
  "word" -> P.Right E'TimestampGranularities'Word
  "segment" -> P.Right E'TimestampGranularities'Segment
  s -> P.Left $ "toE'TimestampGranularities: enum parse failure: " P.++ P.show s


-- ** E'Type

-- | Enum of 'Text' .
-- The type of the content part.
data E'Type
  = E'Type'Image_url -- ^ @"image_url"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Type where toJSON = A.toJSON . fromE'Type
instance A.FromJSON E'Type where parseJSON o = P.either P.fail (pure . P.id) . toE'Type =<< A.parseJSON o
instance WH.ToHttpApiData E'Type where toQueryParam = WH.toQueryParam . fromE'Type
instance WH.FromHttpApiData E'Type where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Type
instance MimeRender MimeMultipartFormData E'Type where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Type' enum
fromE'Type :: E'Type -> Text
fromE'Type = \case
  E'Type'Image_url -> "image_url"

-- | parse 'E'Type' enum
toE'Type :: Text -> P.Either String E'Type
toE'Type = \case
  "image_url" -> P.Right E'Type'Image_url
  s -> P.Left $ "toE'Type: enum parse failure: " P.++ P.show s


-- ** E'Type10

-- | Enum of 'Text' .
-- Always `tool_calls`.
data E'Type10
  = E'Type10'Tool_calls -- ^ @"tool_calls"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Type10 where toJSON = A.toJSON . fromE'Type10
instance A.FromJSON E'Type10 where parseJSON o = P.either P.fail (pure . P.id) . toE'Type10 =<< A.parseJSON o
instance WH.ToHttpApiData E'Type10 where toQueryParam = WH.toQueryParam . fromE'Type10
instance WH.FromHttpApiData E'Type10 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Type10
instance MimeRender MimeMultipartFormData E'Type10 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Type10' enum
fromE'Type10 :: E'Type10 -> Text
fromE'Type10 = \case
  E'Type10'Tool_calls -> "tool_calls"

-- | parse 'E'Type10' enum
toE'Type10 :: Text -> P.Either String E'Type10
toE'Type10 = \case
  "tool_calls" -> P.Right E'Type10'Tool_calls
  s -> P.Left $ "toE'Type10: enum parse failure: " P.++ P.show s


-- ** E'Type11

-- | Enum of 'Text' .
-- Always `logs`.
data E'Type11
  = E'Type11'Logs -- ^ @"logs"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Type11 where toJSON = A.toJSON . fromE'Type11
instance A.FromJSON E'Type11 where parseJSON o = P.either P.fail (pure . P.id) . toE'Type11 =<< A.parseJSON o
instance WH.ToHttpApiData E'Type11 where toQueryParam = WH.toQueryParam . fromE'Type11
instance WH.FromHttpApiData E'Type11 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Type11
instance MimeRender MimeMultipartFormData E'Type11 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Type11' enum
fromE'Type11 :: E'Type11 -> Text
fromE'Type11 = \case
  E'Type11'Logs -> "logs"

-- | parse 'E'Type11' enum
toE'Type11 :: Text -> P.Either String E'Type11
toE'Type11 = \case
  "logs" -> P.Right E'Type11'Logs
  s -> P.Left $ "toE'Type11: enum parse failure: " P.++ P.show s


-- ** E'Type12

-- | Enum of 'Text' .
-- Always `image`.
data E'Type12
  = E'Type12'Image -- ^ @"image"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Type12 where toJSON = A.toJSON . fromE'Type12
instance A.FromJSON E'Type12 where parseJSON o = P.either P.fail (pure . P.id) . toE'Type12 =<< A.parseJSON o
instance WH.ToHttpApiData E'Type12 where toQueryParam = WH.toQueryParam . fromE'Type12
instance WH.FromHttpApiData E'Type12 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Type12
instance MimeRender MimeMultipartFormData E'Type12 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Type12' enum
fromE'Type12 :: E'Type12 -> Text
fromE'Type12 = \case
  E'Type12'Image -> "image"

-- | parse 'E'Type12' enum
toE'Type12 :: Text -> P.Either String E'Type12
toE'Type12 = \case
  "image" -> P.Right E'Type12'Image
  s -> P.Left $ "toE'Type12: enum parse failure: " P.++ P.show s


-- ** E'Type13

-- | Enum of 'Text' .
-- Must be one of `text` or `json_object`.
data E'Type13
  = E'Type13'Text -- ^ @"text"@
  | E'Type13'Json_object -- ^ @"json_object"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Type13 where toJSON = A.toJSON . fromE'Type13
instance A.FromJSON E'Type13 where parseJSON o = P.either P.fail (pure . P.id) . toE'Type13 =<< A.parseJSON o
instance WH.ToHttpApiData E'Type13 where toQueryParam = WH.toQueryParam . fromE'Type13
instance WH.FromHttpApiData E'Type13 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Type13
instance MimeRender MimeMultipartFormData E'Type13 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Type13' enum
fromE'Type13 :: E'Type13 -> Text
fromE'Type13 = \case
  E'Type13'Text -> "text"
  E'Type13'Json_object -> "json_object"

-- | parse 'E'Type13' enum
toE'Type13 :: Text -> P.Either String E'Type13
toE'Type13 = \case
  "text" -> P.Right E'Type13'Text
  "json_object" -> P.Right E'Type13'Json_object
  s -> P.Left $ "toE'Type13: enum parse failure: " P.++ P.show s


-- ** E'Type14

-- | Enum of 'Text' .
-- For now, this is always `submit_tool_outputs`.
data E'Type14
  = E'Type14'Submit_tool_outputs -- ^ @"submit_tool_outputs"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Type14 where toJSON = A.toJSON . fromE'Type14
instance A.FromJSON E'Type14 where parseJSON o = P.either P.fail (pure . P.id) . toE'Type14 =<< A.parseJSON o
instance WH.ToHttpApiData E'Type14 where toQueryParam = WH.toQueryParam . fromE'Type14
instance WH.FromHttpApiData E'Type14 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Type14
instance MimeRender MimeMultipartFormData E'Type14 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Type14' enum
fromE'Type14 :: E'Type14 -> Text
fromE'Type14 = \case
  E'Type14'Submit_tool_outputs -> "submit_tool_outputs"

-- | parse 'E'Type14' enum
toE'Type14 :: Text -> P.Either String E'Type14
toE'Type14 = \case
  "submit_tool_outputs" -> P.Right E'Type14'Submit_tool_outputs
  s -> P.Left $ "toE'Type14: enum parse failure: " P.++ P.show s


-- ** E'Type2

-- | Enum of 'Text' .
-- The type of the content part.
data E'Type2
  = E'Type2'Text -- ^ @"text"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Type2 where toJSON = A.toJSON . fromE'Type2
instance A.FromJSON E'Type2 where parseJSON o = P.either P.fail (pure . P.id) . toE'Type2 =<< A.parseJSON o
instance WH.ToHttpApiData E'Type2 where toQueryParam = WH.toQueryParam . fromE'Type2
instance WH.FromHttpApiData E'Type2 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Type2
instance MimeRender MimeMultipartFormData E'Type2 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Type2' enum
fromE'Type2 :: E'Type2 -> Text
fromE'Type2 = \case
  E'Type2'Text -> "text"

-- | parse 'E'Type2' enum
toE'Type2 :: Text -> P.Either String E'Type2
toE'Type2 = \case
  "text" -> P.Right E'Type2'Text
  s -> P.Left $ "toE'Type2: enum parse failure: " P.++ P.show s


-- ** E'Type3

-- | Enum of 'Text' .
-- The type of tool being defined: `code_interpreter`
data E'Type3
  = E'Type3'Code_interpreter -- ^ @"code_interpreter"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Type3 where toJSON = A.toJSON . fromE'Type3
instance A.FromJSON E'Type3 where parseJSON o = P.either P.fail (pure . P.id) . toE'Type3 =<< A.parseJSON o
instance WH.ToHttpApiData E'Type3 where toQueryParam = WH.toQueryParam . fromE'Type3
instance WH.FromHttpApiData E'Type3 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Type3
instance MimeRender MimeMultipartFormData E'Type3 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Type3' enum
fromE'Type3 :: E'Type3 -> Text
fromE'Type3 = \case
  E'Type3'Code_interpreter -> "code_interpreter"

-- | parse 'E'Type3' enum
toE'Type3 :: Text -> P.Either String E'Type3
toE'Type3 = \case
  "code_interpreter" -> P.Right E'Type3'Code_interpreter
  s -> P.Left $ "toE'Type3: enum parse failure: " P.++ P.show s


-- ** E'Type4

-- | Enum of 'Text' .
-- The type of tool being defined: `retrieval`
data E'Type4
  = E'Type4'Retrieval -- ^ @"retrieval"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Type4 where toJSON = A.toJSON . fromE'Type4
instance A.FromJSON E'Type4 where parseJSON o = P.either P.fail (pure . P.id) . toE'Type4 =<< A.parseJSON o
instance WH.ToHttpApiData E'Type4 where toQueryParam = WH.toQueryParam . fromE'Type4
instance WH.FromHttpApiData E'Type4 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Type4
instance MimeRender MimeMultipartFormData E'Type4 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Type4' enum
fromE'Type4 :: E'Type4 -> Text
fromE'Type4 = \case
  E'Type4'Retrieval -> "retrieval"

-- | parse 'E'Type4' enum
toE'Type4 :: Text -> P.Either String E'Type4
toE'Type4 = \case
  "retrieval" -> P.Right E'Type4'Retrieval
  s -> P.Left $ "toE'Type4: enum parse failure: " P.++ P.show s


-- ** E'Type5

-- | Enum of 'Text' .
-- Always `image_file`.
data E'Type5
  = E'Type5'Image_file -- ^ @"image_file"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Type5 where toJSON = A.toJSON . fromE'Type5
instance A.FromJSON E'Type5 where parseJSON o = P.either P.fail (pure . P.id) . toE'Type5 =<< A.parseJSON o
instance WH.ToHttpApiData E'Type5 where toQueryParam = WH.toQueryParam . fromE'Type5
instance WH.FromHttpApiData E'Type5 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Type5
instance MimeRender MimeMultipartFormData E'Type5 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Type5' enum
fromE'Type5 :: E'Type5 -> Text
fromE'Type5 = \case
  E'Type5'Image_file -> "image_file"

-- | parse 'E'Type5' enum
toE'Type5 :: Text -> P.Either String E'Type5
toE'Type5 = \case
  "image_file" -> P.Right E'Type5'Image_file
  s -> P.Left $ "toE'Type5: enum parse failure: " P.++ P.show s


-- ** E'Type6

-- | Enum of 'Text' .
-- Always `file_citation`.
data E'Type6
  = E'Type6'File_citation -- ^ @"file_citation"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Type6 where toJSON = A.toJSON . fromE'Type6
instance A.FromJSON E'Type6 where parseJSON o = P.either P.fail (pure . P.id) . toE'Type6 =<< A.parseJSON o
instance WH.ToHttpApiData E'Type6 where toQueryParam = WH.toQueryParam . fromE'Type6
instance WH.FromHttpApiData E'Type6 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Type6
instance MimeRender MimeMultipartFormData E'Type6 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Type6' enum
fromE'Type6 :: E'Type6 -> Text
fromE'Type6 = \case
  E'Type6'File_citation -> "file_citation"

-- | parse 'E'Type6' enum
toE'Type6 :: Text -> P.Either String E'Type6
toE'Type6 = \case
  "file_citation" -> P.Right E'Type6'File_citation
  s -> P.Left $ "toE'Type6: enum parse failure: " P.++ P.show s


-- ** E'Type7

-- | Enum of 'Text' .
-- Always `file_path`.
data E'Type7
  = E'Type7'File_path -- ^ @"file_path"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Type7 where toJSON = A.toJSON . fromE'Type7
instance A.FromJSON E'Type7 where parseJSON o = P.either P.fail (pure . P.id) . toE'Type7 =<< A.parseJSON o
instance WH.ToHttpApiData E'Type7 where toQueryParam = WH.toQueryParam . fromE'Type7
instance WH.FromHttpApiData E'Type7 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Type7
instance MimeRender MimeMultipartFormData E'Type7 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Type7' enum
fromE'Type7 :: E'Type7 -> Text
fromE'Type7 = \case
  E'Type7'File_path -> "file_path"

-- | parse 'E'Type7' enum
toE'Type7 :: Text -> P.Either String E'Type7
toE'Type7 = \case
  "file_path" -> P.Right E'Type7'File_path
  s -> P.Left $ "toE'Type7: enum parse failure: " P.++ P.show s


-- ** E'Type8

-- | Enum of 'Text' .
-- The type of run step, which can be either `message_creation` or `tool_calls`.
data E'Type8
  = E'Type8'Message_creation -- ^ @"message_creation"@
  | E'Type8'Tool_calls -- ^ @"tool_calls"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Type8 where toJSON = A.toJSON . fromE'Type8
instance A.FromJSON E'Type8 where parseJSON o = P.either P.fail (pure . P.id) . toE'Type8 =<< A.parseJSON o
instance WH.ToHttpApiData E'Type8 where toQueryParam = WH.toQueryParam . fromE'Type8
instance WH.FromHttpApiData E'Type8 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Type8
instance MimeRender MimeMultipartFormData E'Type8 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Type8' enum
fromE'Type8 :: E'Type8 -> Text
fromE'Type8 = \case
  E'Type8'Message_creation -> "message_creation"
  E'Type8'Tool_calls -> "tool_calls"

-- | parse 'E'Type8' enum
toE'Type8 :: Text -> P.Either String E'Type8
toE'Type8 = \case
  "message_creation" -> P.Right E'Type8'Message_creation
  "tool_calls" -> P.Right E'Type8'Tool_calls
  s -> P.Left $ "toE'Type8: enum parse failure: " P.++ P.show s


-- ** E'Type9

-- | Enum of 'Text' .
-- Always `message_creation`.
data E'Type9
  = E'Type9'Message_creation -- ^ @"message_creation"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Type9 where toJSON = A.toJSON . fromE'Type9
instance A.FromJSON E'Type9 where parseJSON o = P.either P.fail (pure . P.id) . toE'Type9 =<< A.parseJSON o
instance WH.ToHttpApiData E'Type9 where toQueryParam = WH.toQueryParam . fromE'Type9
instance WH.FromHttpApiData E'Type9 where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Type9
instance MimeRender MimeMultipartFormData E'Type9 where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Type9' enum
fromE'Type9 :: E'Type9 -> Text
fromE'Type9 = \case
  E'Type9'Message_creation -> "message_creation"

-- | parse 'E'Type9' enum
toE'Type9 :: Text -> P.Either String E'Type9
toE'Type9 = \case
  "message_creation" -> P.Right E'Type9'Message_creation
  s -> P.Left $ "toE'Type9: enum parse failure: " P.++ P.show s


-- ** E'Voice

-- | Enum of 'Text' .
-- The voice to use when generating the audio. Supported voices are `alloy`, `echo`, `fable`, `onyx`, `nova`, and `shimmer`. Previews of the voices are available in the [Text to speech guide](/docs/guides/text-to-speech/voice-options).
data E'Voice
  = E'Voice'Alloy -- ^ @"alloy"@
  | E'Voice'Echo -- ^ @"echo"@
  | E'Voice'Fable -- ^ @"fable"@
  | E'Voice'Onyx -- ^ @"onyx"@
  | E'Voice'Nova -- ^ @"nova"@
  | E'Voice'Shimmer -- ^ @"shimmer"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Voice where toJSON = A.toJSON . fromE'Voice
instance A.FromJSON E'Voice where parseJSON o = P.either P.fail (pure . P.id) . toE'Voice =<< A.parseJSON o
instance WH.ToHttpApiData E'Voice where toQueryParam = WH.toQueryParam . fromE'Voice
instance WH.FromHttpApiData E'Voice where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Voice
instance MimeRender MimeMultipartFormData E'Voice where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Voice' enum
fromE'Voice :: E'Voice -> Text
fromE'Voice = \case
  E'Voice'Alloy -> "alloy"
  E'Voice'Echo -> "echo"
  E'Voice'Fable -> "fable"
  E'Voice'Onyx -> "onyx"
  E'Voice'Nova -> "nova"
  E'Voice'Shimmer -> "shimmer"

-- | parse 'E'Voice' enum
toE'Voice :: Text -> P.Either String E'Voice
toE'Voice = \case
  "alloy" -> P.Right E'Voice'Alloy
  "echo" -> P.Right E'Voice'Echo
  "fable" -> P.Right E'Voice'Fable
  "onyx" -> P.Right E'Voice'Onyx
  "nova" -> P.Right E'Voice'Nova
  "shimmer" -> P.Right E'Voice'Shimmer
  s -> P.Left $ "toE'Voice: enum parse failure: " P.++ P.show s


-- * Auth Methods

-- ** AuthBasicApiKeyAuth
data AuthBasicApiKeyAuth =
  AuthBasicApiKeyAuth B.ByteString B.ByteString -- ^ username password
  deriving (P.Eq, P.Show, P.Typeable)

instance AuthMethod AuthBasicApiKeyAuth where
  applyAuthMethod _ a@(AuthBasicApiKeyAuth user pw) req =
    P.pure $
    if (P.typeOf a `P.elem` rAuthTypes req)
      then req `setHeader` toHeader ("Authorization", T.decodeUtf8 cred)
           & L.over rAuthTypesL (P.filter (/= P.typeOf a))
      else req
    where cred = BC.append "Basic " (B64.encode $ BC.concat [ user, ":", pw ])


